32149121
Elasticsearch match exact terms with spaces across different fields
<p>My data in elastic is setup with different fields: categories, subcategories, instruments and moods. My goal is to provide results with only exact matches for all of the keywords passed to it and only return results that match everything. So far, this seems to work until I use a keyword that consists of multiple words separated with a space, like so:</p>&#xA;&#xA;<pre><code>"query": {&#xA;    "bool": {&#xA;      "must": [&#xA;        {&#xA;          "match": {&#xA;            "categories": "Electronic"&#xA;          }&#xA;        },&#xA;        {&#xA;          "match": {&#xA;            "categories": "Pop"&#xA;          }&#xA;        },&#xA;        {&#xA;          "match": {&#xA;            "instruments": "Female Vocal"&#xA;          }&#xA;        }&#xA;      ]&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>My data in ES consists of this type of data:</p>&#xA;&#xA;<pre><code>[name] =&gt; Some Data Name&#xA;[categories] =&gt; Electronic,Pop&#xA;[subcategories] =&gt; 1970s,Alternative,Experimental,Retro&#xA;[instruments] =&gt; Electronic Drums,Male Vocal,Synth&#xA;[moods] =&gt; Fun,Futuristic,Pulsing,Quirky,Rhythmic&#xA;</code></pre>&#xA;&#xA;<p>So, it's matching the "Vocal" part of the instruments field, but doesn't perform an exact match for "Female Vocal". </p>&#xA;&#xA;<p>Would this be solved by an ES filter perhaps? </p>&#xA;&#xA;<p><strong>EDIT</strong>:&#xA;To account for other characters, I expanded the sample data set a bit:</p>&#xA;&#xA;<pre><code>[categories]=&gt;R&amp;B,Dance/House&#xA;[instruments] =&gt; Electronic Drums,Male Vocal,Synth&#xA;[moods] =&gt; Fun,Futuristic,Pulsing,Quirky,Rhythmic&#xA;</code></pre>&#xA;&#xA;<p>So, there might be ampersands, slashes and spaces used. A comma would separate separate terms. </p>&#xA;&#xA;<p><strong>SOLVED</strong>&#xA;I ended up looking more into analyzers and realized that I probably need to create a custom one to account for the boundaries of my keywords. </p>&#xA;&#xA;<pre><code>myesurl/tracks/_settings    &#xA;{&#xA;      "index": {&#xA;        "analysis": {&#xA;          "tokenizer": {&#xA;            "comma": {&#xA;              "type": "pattern",&#xA;              "pattern": ","&#xA;            }&#xA;          },&#xA;          "analyzer": {&#xA;            "tracks_analyzer": {&#xA;              "type": "custom",&#xA;              "tokenizer": "comma",&#xA;              "filter": [&#xA;                "trim",&#xA;                "lowercase"&#xA;              ]&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;</code></pre>&#xA;&#xA;<p>Then I setup a mapping:</p>&#xA;&#xA;<pre><code>{&#xA;  "track": {&#xA;    "properties": {&#xA;      "categories": {&#xA;        "type": "string",&#xA;        "analyzer": "tracks_analyzer"&#xA;      },&#xA;      "subcategories": {&#xA;        "type": "string",&#xA;        "analyzer": "tracks_analyzer"&#xA;      },&#xA;      "instruments": {&#xA;        "type": "string",&#xA;        "analyzer": "tracks_analyzer"&#xA;      },&#xA;      "moods": {&#xA;        "type": "string",&#xA;        "analyzer": "tracks_analyzer"&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And then pushed the content into the elasticsearch. Seemed to work as intended. It now accounts for any character in the keyword, as long as the keyword matches to a token that was created by separated commas. </p>&#xA;
<p>Using <code>match</code> queries means that whatever string you put in are analyzed by the standard analyzer, and thus split on whitespaces and lowercased. So as you could see, you're fine as long as you're matching a single word per field, however, the fun comes whenever what you're searching contains space(s). </p>&#xA;&#xA;<p>What happens is that at indexing time, <code>Female Vocal</code> would be split in two tokens <code>female</code> and <code>vocal</code> and indexed into the <code>instruments</code> field. The same goes for <code>Male Vocal</code> being indexed as two tokens <code>male</code> and <code>vocal</code>. and thus would also match fields with <code>Male Vocal</code>. Then when you're <code>match</code>ing on <code>Female Vocal</code>, what happens is that the search terms are split and lowercased as well into <code>female</code> and <code>vocal</code> and the term <code>vocal</code> would match both documents with <code>Male Vocal</code> and <code>Female Vocal</code>.</p>&#xA;&#xA;<p>If you want exact matching, you need two things:&#xA;1. declare those string fields you need to match exactly as <code>not_analyzed</code> in your mapping&#xA;2. use <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html" rel="noreferrer"><code>term</code> queries</a> (or <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-filter.html" rel="noreferrer"><code>term</code> filters</a>) which do not analyze the search terms.</p>&#xA;&#xA;<p>The first point is easily made with such a mapping:</p>&#xA;&#xA;<pre><code>curl -XPUT localhost:9200/my_index -d '{&#xA;   "mappings": {&#xA;       "my_type": {&#xA;           "properties": {&#xA;               "categories": {&#xA;                   "type": "string",&#xA;                   "index": "not_analyzed"&#xA;               },&#xA;               "subcategories": {&#xA;                   "type": "string",&#xA;                   "index": "not_analyzed"&#xA;               },&#xA;               "instruments": {&#xA;                   "type": "string",&#xA;                   "index": "not_analyzed"&#xA;               },&#xA;               "moods": {&#xA;                   "type": "string",&#xA;                   "index": "not_analyzed"&#xA;               },&#xA;               ...&#xA;           }&#xA;       }&#xA;   }&#xA;}'&#xA;</code></pre>&#xA;&#xA;<p>With such a mapping, <code>Female Vocal</code> will not be analyzed (i.e. not indexed as <code>female</code> and <code>vocal</code>) but be indexed verbatim as <code>Female Vocal</code>.</p>&#xA;&#xA;<p>Then you can query exact field values with a query like this:</p>&#xA;&#xA;<pre><code>curl -XPOST localhost:9200/my_index/my_type/_search -d '{&#xA;    "query": {&#xA;        "bool": {&#xA;          "must": [&#xA;            {&#xA;              "term": {&#xA;                "categories": "Electronic"&#xA;              }&#xA;            },&#xA;            {&#xA;              "term": {&#xA;                "categories": "Pop"&#xA;              }&#xA;            },&#xA;            {&#xA;              "term": {&#xA;                "instruments": "Female Vocal"&#xA;              }&#xA;            }&#xA;          ]&#xA;        }&#xA;    }&#xA;}'&#xA;</code></pre>&#xA;
<p>I ended up looking more into analyzers and realized that I probably need to create a custom one to account for the boundaries of my keywords.</p>&#xA;&#xA;<pre><code>myesurl/tracks/_settings    &#xA;{&#xA;      "index": {&#xA;        "analysis": {&#xA;          "tokenizer": {&#xA;            "comma": {&#xA;              "type": "pattern",&#xA;              "pattern": ","&#xA;            }&#xA;          },&#xA;          "analyzer": {&#xA;            "tracks_analyzer": {&#xA;              "type": "custom",&#xA;              "tokenizer": "comma",&#xA;              "filter": [&#xA;                "trim",&#xA;                "lowercase"&#xA;              ]&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;</code></pre>&#xA;&#xA;<p>Then I setup a mapping:</p>&#xA;&#xA;<pre><code>{&#xA;  "track": {&#xA;    "properties": {&#xA;      "categories": {&#xA;        "type": "string",&#xA;        "analyzer": "tracks_analyzer"&#xA;      },&#xA;      "subcategories": {&#xA;        "type": "string",&#xA;        "analyzer": "tracks_analyzer"&#xA;      },&#xA;      "instruments": {&#xA;        "type": "string",&#xA;        "analyzer": "tracks_analyzer"&#xA;      },&#xA;      "moods": {&#xA;        "type": "string",&#xA;        "analyzer": "tracks_analyzer"&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And then pushed the content into the elasticsearch. Seemed to work as intended. It now accounts for any character in the keyword, as long as the keyword matches to a token that was created by separated commas.</p>&#xA;