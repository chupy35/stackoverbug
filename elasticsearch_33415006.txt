33415006
Retrieve docs that contains only allowed tags (exactly equals)
<p>For each search request I have allowed tags list. For example,</p>&#xA;&#xA;<pre><code>["search", "open_source", "freeware", "linux"]&#xA;</code></pre>&#xA;&#xA;<p>And I want to retrieve documents with all tags in this list. I want to retrieve:</p>&#xA;&#xA;<pre><code>{&#xA;    "tags": ["search", "freeware"]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>and exclude</p>&#xA;&#xA;<pre><code>{&#xA;    "tags": ["search", "windows"]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>because list doesn't contain <code>windows</code> tag.</p>&#xA;&#xA;<p>There is an example for equals exactly in Elasticsearch documentation:</p>&#xA;&#xA;<p><a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/_finding_multiple_exact_values.html">https://www.elastic.co/guide/en/elasticsearch/guide/current/_finding_multiple_exact_values.html</a></p>&#xA;&#xA;<p>Firstly, we include a field that maintains the number of tags:</p>&#xA;&#xA;<pre><code>{ "tags" : ["search"], "tag_count" : 1 }&#xA;{ "tags" : ["search", "open_source"], "tag_count" : 2 }&#xA;</code></pre>&#xA;&#xA;<p>Secondly, we retrieve with needed tag_count</p>&#xA;&#xA;<pre><code>GET /my_index/my_type/_search&#xA;{&#xA;    "query": {&#xA;        "filtered" : {&#xA;            "filter" : {&#xA;                 "bool" : {&#xA;                    "must" : [&#xA;                        { "term" : { "tags" : "search" } }, &#xA;                        { "term" : { "tags" : "open_source" } }, &#xA;                        { "term" : { "tag_count" : 2 } } &#xA;                    ]&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The problem is I don't know <code>tag_count</code>. </p>&#xA;&#xA;<p>Also I have tried to write query with <code>script_field</code> <code>tags_count</code>, write each allowed tag in terms query and set <code>minimal_should_match</code> to <code>tags_count</code>, but I can't set script variable in <code>minimal_should_match</code>.</p>&#xA;&#xA;<p>What can I investigate?</p>&#xA;
<p>Why not to use the bool with windows being added to must not clause. I hope that's what you are looking out for.</p>&#xA;
<p>So I admit this is not a great solution, but maybe it will inspire other better solutions?</p>&#xA;&#xA;<p>Given portions of the records you are searching look like what you have in your post with the tag_count fields:</p>&#xA;&#xA;<pre><code>"tags" : ["search"],&#xA;"tag_count" : 1&#xA;</code></pre>&#xA;&#xA;<p>or</p>&#xA;&#xA;<pre><code>"tags" : ["search", "open_source"],&#xA;"tag_count" : 2&#xA;</code></pre>&#xA;&#xA;<p>And you have a query like: </p>&#xA;&#xA;<pre><code>["search", "open_source", "freeware"]&#xA;</code></pre>&#xA;&#xA;<p>Then you might programmatically generate a query like: </p>&#xA;&#xA;<pre><code>{&#xA;    "query" : {&#xA;        "bool" : {&#xA;            "should" : [&#xA;                {&#xA;                    "bool" : {&#xA;                        "should" : [&#xA;                            { "term" : { "tags" : "search" } },&#xA;                            { "term" : { "tags" : "open_source" } },&#xA;                            { "term" : { "tags" : "freeware" } },&#xA;                            { "term" : { "tag_count" : 1 } },&#xA;                        ],&#xA;                        "minimum_should_match" : 2&#xA;                    }&#xA;                },&#xA;                {&#xA;                    "bool" : {&#xA;                        "should" : [&#xA;                            { "term" : { "tags" : "search" } },&#xA;                            { "term" : { "tags" : "open_source" } },&#xA;                            { "term" : { "tags" : "freeware" } },&#xA;                            { "term" : { "tag_count" : 2 } },&#xA;                        ],&#xA;                        "minimum_should_match" : 3&#xA;                    }&#xA;                },&#xA;                {&#xA;                    "bool" : {&#xA;                        "should" : [&#xA;                            { "term" : { "tags" : "search" } },&#xA;                            { "term" : { "tags" : "open_source" } },&#xA;                            { "term" : { "tags" : "freeware" } },&#xA;                            { "term" : { "tag_count" : 3 } },&#xA;                        ],&#xA;                        "minimum_should_match" : 4&#xA;                    }&#xA;                }&#xA;            ],&#xA;            "minimum_should_match" : 1&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The number of nested bool queries will match the number query of query tags (not great for a number of reasons - but with smaller queries / smaller indices, can perhaps get away with this?).  Basically each clause will handle every possible case of tag_count and minimum_should_match will be tag_count + 1 (so match tag_count and appropriate number of tags - tag_count amount).</p>&#xA;
<p>@Sergey Shuvalov, another way to get away with this without using scripting is by creating another field whose value contains all the sorted tags separated by a comma (e.g., or you can choose whatever separator suits you).</p>&#xA;&#xA;<p>So for instance, if you have a document like this:</p>&#xA;&#xA;<pre><code>{&#xA;    "tags": ["search", "open_source", "freeware", "linux"]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>You'd create another field <code>alltags</code> which contains the same tags, but sorted in lexicographical order and separated by commas, like this:</p>&#xA;&#xA;<pre><code>{&#xA;  "tags": ["search", "open_source", "freeware", "linux"]&#xA;  "alltags": "freeware,linux,open_source,search"&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>That new <code>alltags</code> field would be <code>not_analyzed</code> and thus have the following mapping:</p>&#xA;&#xA;<pre><code>{&#xA;  "mappings": {&#xA;    "doc": {&#xA;      "properties": {&#xA;        "tags": {&#xA;          "type": "string"&#xA;        },&#xA;        "alltags": {&#xA;          "type": "string",&#xA;          "index": "not_analyzed"&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Then you can issue a simple <code>term</code> query like the one below, you just need to make sure that the tags are also sorted and you'll get your matching documents.</p>&#xA;&#xA;<pre><code>{&#xA;  "query": {&#xA;    "term": {&#xA;      "alltags": "freeware,linux,open_source,search"&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>If you have a long list of tags, you might also decide to produce an MD5 or SHA1 out of the sorted list of tags and only store that value in the <code>alltags</code> field and use the same value during the search. The bottom line is that you need to produce some kind of "signature" for your tag list and know that that signature will always be the same given the same set of tags. The limit is the sky!</p>&#xA;
<p>If index size is medium size and tags cardinality is rather low I would just use <code>terms</code> aggregation to get distinct tags and create <code>must</code> and <code>must not</code> filters to filter out docs which contain tags you don't "allow". There are many ways to cache the list of all tags to an in-memory database like Redis, here are a few that came to my mind:</p>&#xA;&#xA;<ol>&#xA;<li>Have a time-to-live of a few minutes or hours, re-generate the list if cache has expired</li>&#xA;<li>Have a background process refreshing the list at regular intervals</li>&#xA;<li>Update the list when new docs are inserted, then doc deletions should be handled as well</li>&#xA;</ol>&#xA;&#xA;<p>A more performant and 100% accurate method could look like this:</p>&#xA;&#xA;<ol>&#xA;<li>Query all documents which have the requested tags but exclude docs with known other tags (as with the first solution)</li>&#xA;<li>Go through the list of returned docs</li>&#xA;<li>If a doc contains a tag which is not "allowed", it means it wasn't in known tags cache and thus must be added there, exclude this doc from the result set</li>&#xA;<li>Tags at Redis could have a TTL of for example one day or one week, this way old tags are automatically pruned and you get simpler ES queries</li>&#xA;</ol>&#xA;&#xA;<p>This way you don't need a backup process to maintain the list of tags or use the possibly heavy <code>terms</code> aggregation as it hits all docs, and get always the correct result set and fairly performant queries.</p>&#xA;&#xA;<p>This wouldn't work if subsequent aggregations are used as ES might return false documents which are pruned on the client side. However this could be detected by adding a <code>terms</code> aggregation as well and confirm that it doesn't have unexpected tags. If it does those need to be added to the tag cache, added to the <code>must_not</code> filter and query has to be re-executed. This isn't ideal if new tags are being created frequently.</p>&#xA;
<p>As I mentioned early I combine two nice answers. And this is what I have:</p>&#xA;&#xA;<pre><code>"query" : {&#xA;    "bool":{&#xA;        "should":[&#xA;            {"term":{"tag_count":1}},&#xA;            {&#xA;                "bool":{&#xA;                    "should":[&#xA;                        {"term":{"tags":"search"}},&#xA;                        {"term":{"tags":"open_source"}},&#xA;                        {"term":{"tags":"freeware"}}&#xA;                    ],&#xA;                    "filter":{"term":{"tag_count":2}},&#xA;                    "minimum_should_match":2&#xA;                }&#xA;            },&#xA;            {&#xA;                "bool":{&#xA;                    "should":[&#xA;                        {"term":{"tags":"search"}},&#xA;                        {"term":{"tags":"open_source"}},&#xA;                        {"term":{"tags":"freeware"}}&#xA;                    ],&#xA;                    "filter":{"term":{"tag_count":3}},&#xA;                    "minimum_should_match":3&#xA;                }&#xA;            },&#xA;            {&#xA;                "script": {&#xA;                    "script": "tags.containsAll(doc['tags'].values)",&#xA;                    "params": {"tags":["search", "open_source", "freeware"]}&#xA;                }&#xA;            }&#xA;        ],&#xA;        "filter":{ "terms" : {"tags" :["search", "open_source", "freeware"]}}&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>script condition works with nontrivial cases, and other conditions is here to consider simple cases.</p>&#xA;