28471242
Elasticsearch fuzzylike this query with multiple values in like_text
<p>I am new to Elasticsearch. We are using a fuzzy_like_this query as below</p>&#xA;&#xA;<pre><code>{&#xA;                      "query": {&#xA;                        "bool": {&#xA;                          "should": [&#xA;                            {&#xA;                              "flt": {&#xA;                                "fields": [&#xA;                                  "actor.id"&#xA;                                ],&#xA;                                "like_text": "kar@gmail.com"&#xA;                              }&#xA;                            }&#xA;                          ]&#xA;                        }&#xA;                      },&#xA;                      "size": "100",&#xA;                      "sort": [&#xA;                        {&#xA;                          "published": {&#xA;                            "order": "desc",&#xA;                            "ignore_unmapped": true&#xA;                          }&#xA;                        }&#xA;                      ]&#xA;                    }&#xA;</code></pre>&#xA;&#xA;<p>The like_text currently matches single string, we want to modify it to search for comma seperated values i.e <code>"like_text": "kar@gmail.com,xyz@yahoo.com"</code></p>&#xA;&#xA;<p>I tried analyzer and match options in flt but unable to get the expected result.Any help in this regard is appreciated. Thanks in Advance.</p>&#xA;
<p>Are you sure you need the fuzzy query? Have you tried just using a <a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-match-query.html" rel="nofollow">match query</a>? You can configure lots of options, but by default the <a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/analysis-standard-analyzer.html" rel="nofollow">standard analyzer</a> will be used to tokenize your query text, and it will tokenize on commas.</p>&#xA;&#xA;<p>As an illustration, I created a simple index and added a few docs:</p>&#xA;&#xA;<pre><code>PUT /test_index&#xA;{&#xA;    "settings": {&#xA;        "number_of_shards": 1,&#xA;        "number_of_replicas": 0&#xA;    }&#xA;}&#xA;&#xA;POST /test_index/_bulk&#xA;{"index":{"_index":"test_index","_type":"doc"}}&#xA;{"email": "kar@gmail.com"}&#xA;{"index":{"_index":"test_index","_type":"doc"}}&#xA;{"email": "xyz@yahoo.com"}&#xA;{"index":{"_index":"test_index","_type":"doc"}}&#xA;{"email": "somebody@somewhereelse.com"}&#xA;</code></pre>&#xA;&#xA;<p>then ran a simple match query, and got back the expected results:</p>&#xA;&#xA;<pre><code>POST /test_index/_search&#xA;{&#xA;   "query": {&#xA;      "match": {&#xA;         "email": "kar@gmail.com,xyz@yahoo.com"&#xA;      }&#xA;   }&#xA;}&#xA;...&#xA;{&#xA;   "took": 2,&#xA;   "timed_out": false,&#xA;   "_shards": {&#xA;      "total": 1,&#xA;      "successful": 1,&#xA;      "failed": 0&#xA;   },&#xA;   "hits": {&#xA;      "total": 2,&#xA;      "max_score": 0.43920785,&#xA;      "hits": [&#xA;         {&#xA;            "_index": "test_index",&#xA;            "_type": "doc",&#xA;            "_id": "AhjrGCcXSjW26eNDDYENHA",&#xA;            "_score": 0.43920785,&#xA;            "_source": {&#xA;               "email": "kar@gmail.com"&#xA;            }&#xA;         },&#xA;         {&#xA;            "_index": "test_index",&#xA;            "_type": "doc",&#xA;            "_id": "X7Fk6J1TQMWK5ZccsfBrVA",&#xA;            "_score": 0.43920785,&#xA;            "_source": {&#xA;               "email": "xyz@yahoo.com"&#xA;            }&#xA;         }&#xA;      ]&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Here is the code I used (if you're using ES 1.4 you'll have to enable CORS to be able to use the code in the browser):</p>&#xA;&#xA;<p><a href="http://sense.qbox.io/gist/633c2d284979b26406040db90815231ba71513bc" rel="nofollow">http://sense.qbox.io/gist/633c2d284979b26406040db90815231ba71513bc</a></p>&#xA;