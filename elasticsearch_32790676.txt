32790676
Elasticsearch Query Help - Multiple Nested AND/OR
<p>I am struggling with elasticsearch filters.  I have a <code>company_office</code> type that looks like this:</p>&#xA;&#xA;<pre><code>{&#xA;  "company_office_id": 1,&#xA;  "is_headquarters": true,&#xA;  "company": {&#xA;    "name": "Some Company Inc"&#xA;  },&#xA;  "attribute_values": [&#xA;      {&#xA;        "attribute_id": 1,&#xA;        "attribute_value": "attribute 1 value",&#xA;      },&#xA;      {&#xA;        "attribute_id": 2,&#xA;        "attribute_value": "ABC",&#xA;      },&#xA;      {&#xA;        "attribute_id": 3,&#xA;        "attribute_value": "DEF",&#xA;      },&#xA;      {&#xA;        "attribute_id": 3,&#xA;        "attribute_value": "HIJ",&#xA;      }&#xA;  ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Let's assume that attribute_value is <em>not_analyzed</em> - so I can match on it exactly.</p>&#xA;&#xA;<p>Now I want to filter on a combination of multiple attribute_id and value fields.  Something like this in SQL:</p>&#xA;&#xA;<pre><code>SELECT *&#xA;FROM CompanyOffice c&#xA;JOIN Attributes a --omitting the ON here, just assume the join is valid&#xA;WHERE &#xA;c.is_headquarters = true AND&#xA;(&#xA;  (a.attribute_id=2 AND a.attribute_value IN ('ABC')) OR&#xA;  (a.attribute_id=3 AND a.attribute_value IN ('DEF','HIJ')) &#xA;)&#xA;</code></pre>&#xA;&#xA;<p><strong>So I need to filter on specific fields + multiple combinations of id/value.</strong></p>&#xA;&#xA;<p>Here is the query I tried:</p>&#xA;&#xA;<pre><code>{&#xA;  "query" : {&#xA;    "filtered" : {&#xA;      "filter" : {&#xA;        "bool" : {&#xA;          "must" : [&#xA;&#xA;&#xA;            { "term": {"is_headquarters": true } },&#xA;            {"bool": { &#xA;                      "must":[&#xA;                        {"term": {"attribute_values.attribute_id": 1}},&#xA;                        {"bool": { "should": [{"term": {"attribute_values.attribute_value": "HIJ"}}]}}&#xA;                      ]&#xA;                     }}          &#xA;          ] &#xA;        } &#xA;      } &#xA;    } &#xA;  } &#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This query is returning results even the company_office does not have any id/value pairing of 1/'HIJ'.  My thinking here is that because this bool filter is sitting inside of the parent <code>must</code> section, then all items must be true:</p>&#xA;&#xA;<pre><code>            {"bool": { &#xA;                      "must":[&#xA;                        {"term": {"attribute_values.attribute_id": 1}},&#xA;                        {"bool": { "should": [{"term": {"attribute_values.attribute_value": "HIJ"}}]}}&#xA;                      ]&#xA;                     }}  &#xA;</code></pre>&#xA;&#xA;<p>Why would this query return results given the data sample provided at the beginning of the question?  Is there a different way to write the filter and accomplish what I am trying to do?</p>&#xA;&#xA;<p>Thanks so much for any help!</p>&#xA;
<p>If you want to query deeper objects without flattening their structure, you need to set</p>&#xA;&#xA;<pre><code>"type": "nested"&#xA;</code></pre>&#xA;&#xA;<p>on <code>"attribute_values"</code> property.</p>&#xA;&#xA;<p>Then refer how to write <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-nested-query.html" rel="nofollow">nested queries in documentation</a>, and you should correctly retrieve the whole document. Use <a href="https://www.elastic.co/guide/en/elasticsearch/reference/1.5/search-request-inner-hits.html#nested-inner-hits" rel="nofollow">inner hits</a> to retrieve matched <code>attribute_values</code>.</p>&#xA;&#xA;<p>By default, Elasticsearch does not nest properties when indexing. All subfields get's squashed into separate subfields without ability to query them by their actual structure. You will not see this effect, because original document is returned.</p>&#xA;&#xA;<p>Apart from that, your queries are a bit off. In the last <code>"should"</code> statement, you have only 1 term filter so it's effectively a <code>"must"</code> part, but they will have to be rewritten to nested format.</p>&#xA;