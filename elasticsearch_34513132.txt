34513132
Elasticsearch - what to do if fields have the same name but multiple mapping
<p>I use Elasticsearch for storing data sent from multiple sources outside of my system, i.e. I'm not controlling the incoming data - I just receive json document and store it. I have no logstash with its filters in the middle, only ES and Kibana. Each data source sent its own data type and all of them are stored in the same index (per tenant) but in different types. However since I cannot control the data that is sent to me, it is possible to receive documents of different types with the field having the same name and different structure.<br>&#xA;<strong>For example</strong>, assume that I have type1 and type2 with field FLD, which is an object in both cases but the structure of this object is not the same. Specifically FLD.name is a string field in type1 but an object in type2. And in this case, when type1 data arrives it is stored successfully but when type2 data arrives, it is rejected: </p>&#xA;&#xA;<blockquote>&#xA;  <p>failed to put mappings on indices [[myindex]], type [type2]<br>&#xA;  java.lang.IllegalArgumentException: Mapper for [FLD] conflicts with existing mapping in other types[Can't merge a non object mapping [FLD.name] with an object mapping [FLD.name]]</p>&#xA;</blockquote>&#xA;&#xA;<p>ES documentation clearly declare that fields with the same name in the same index in different mapping types mapped to the same field internally and must have the same mapping (<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html#field-conflicts" rel="noreferrer">see here</a>).  </p>&#xA;&#xA;<p><strong>My question</strong> is what can I do in this case? I'd prefer to keep all the types in the same index. Is it possible to add a unique-per-type suffix to field names or something like this? Any other solution? I'm a newbie in Elasticsearch so maybe I'm missing something simple... Thanks in advance.</p>&#xA;
<p>There is no way to do index arbitrary JSON without pre-processing before it's indexed - not even <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.4/dynamic-templates.html" rel="nofollow noreferrer">Dynamic templates</a> are flexible enough.</p>&#xA;&#xA;<p>You can flatten nested objects into key-value pairs and use a <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.4/nested.html" rel="nofollow noreferrer">Nested datatype</a>, <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.4/multi-fields.html" rel="nofollow noreferrer">Multi-fields</a>, and <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.4/ignore-malformed.html" rel="nofollow noreferrer"><code>ignore_malformed</code></a> to index arbitrary JSON (even with type conflicts) as described <a href="https://chrismwendt.github.io/blog/2017/04/08/indexing-arbitrary-json-into-elasticsearch.html" rel="nofollow noreferrer">here</a>. Unfortunately, Elasticsearch can still throw an exception at query time if you try to, for example, match a string to <code>kv_pairs.value.long</code>, so you'll have choose appropriate fields based on format of the value.</p>&#xA;