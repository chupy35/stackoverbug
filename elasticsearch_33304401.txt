33304401
Grouping match_phrase search results by match text in Elastic Search
<p>Given a phrase match query like this:</p>&#xA;&#xA;<pre><code>{&#xA;    'match_phrase': {&#xA;        'text.english': {&#xA;            'query': "The fox jumped over the wall",&#xA;            'phrase_slop': 4,&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Is there a way I can group results by the exact match?</p>&#xA;&#xA;<p>So if I have 1 document with <code>text.english</code> containing "The quick fox jumps over the small wall" and 3 documents containing "The lazy fox jumped over the big wall", I end up with those two groups of results.</p>&#xA;&#xA;<p>I'm OK with running multiple queries and doing some processing outside of ES, but I need a solution that performs reasonably over a large set of documents. Ideally I'm hoping there's a way to do this using aggregations that I've missed.</p>&#xA;&#xA;<p>The best solution I've come up with is to run the query above with highlights, parse out all of the highlights from all of the results, and group them based on highlight content. This is fine for very small result sets, however over a 1000+ document result set it is prohibitively slow.</p>&#xA;&#xA;<p><strong>EDIT:</strong>&#xA;Maybe I can make this a bit clearer. If I have sample documents with the following values:</p>&#xA;&#xA;<ol>&#xA;<li>"The quick fox jumps over the small wall. Blah blah blah many pages of unrelated text."</li>&#xA;<li>"The lazy fox jumped over the big wall. Blah blah blah many pages of unrelated text."</li>&#xA;<li>"The lazy fox jumped over the big wall. Blah blah blah many pages of unrelated text."</li>&#xA;<li>"The lazy fox jumped over the big wall. Blah blah blah many pages of unrelated text."</li>&#xA;</ol>&#xA;&#xA;<p>I want to be able to group my results as follows with query text "The fox jumped over the wall":</p>&#xA;&#xA;<ul>&#xA;<li>"The quick fox jumps over the small wall" - Document 1</li>&#xA;<li>"The lazy fox jumped over the big wall" - Documents 2, 3, 4</li>&#xA;</ul>&#xA;
<p>If the statements inside your text.english are "exactly" same then their score should be same. You could aggregate results based on Elastic Search _score. </p>&#xA;&#xA;<p>Please refer to this SO question <a href="https://stackoverflow.com/questions/24557645/elasticsearch-aggregation-on-score-field">ElasticSearch: aggregation on _score field?</a></p>&#xA;&#xA;<p>Since ES has disabled the dynamic scripting, this might help.&#xA;<a href="https://stackoverflow.com/questions/30086403/elasticsearch-aggregation-on-score-field-w-groovy-disabled?lq=1">ElasticSearch: aggregation on _score field w/ Groovy disabled</a></p>&#xA;
<p>I believe you could create a terms aggregation over a not analyzed version of the field.</p>&#xA;&#xA;<p>if <code>text.raw</code> is defined as <code>not_analyzed</code>, an aggregation should take the whole field value.</p>&#xA;&#xA;<p>I have not tested it, but I found something quite similar: <a href="https://stackoverflow.com/questions/22798170/elasticsearch-terms-aggregation-by-entire-field">ElasticSearch terms aggregation by entire field</a></p>&#xA;
<p>In my opinion, <code>highlighting</code> is the only option because it's the only way Elasticsearch will show which "parts" of text matched. And in your case, you want to group documents based on what "matched.</p>&#xA;&#xA;<p>If the text would have been shorter (like few words), maybe a more involved solution would have been to split the text in a <code>shingle</code>-kind of way and somehow group on those phrases... <em>maybe</em>.</p>&#xA;&#xA;<p>But for pages of text, I think the only option is to use highlighting and perform additional steps afterwards to group the highlighted parts.</p>&#xA;
<p>I have a similar problem/challenge in a product search application. I want to group products by brand, e.g. </p>&#xA;&#xA;<pre><code>Nikon&#xA;Nikos&#xA;</code></pre>&#xA;&#xA;<p>To solve this problem I'm experimenting with the <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters.html" rel="nofollow">Suggester&#xA;</a>. The idea behind is that the suggester will provide me with suggestions for my searches. The suggestions will be grouped and will not be repeated for all documents (even though there is possibly some other text around them). You can use a <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters-term.html" rel="nofollow">Term Suggester</a> or a <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters-phrase.html" rel="nofollow">Phrase Suggester</a></p>&#xA;&#xA;<p>This approach, however, requires you probably to change the handling of the results. You have to display the suggestions as the groups and handle search results separately. The advantage of this approach is that you don't have to do the grouping yourself. </p>&#xA;&#xA;<p>Another solution is to use a <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html" rel="nofollow">Terms Aggregation</a> using shingles. This aggregation would group word groups (shingles). To get your result, however, you have to take all aggregations and match them with your query input. See example mapping, data and query:</p>&#xA;&#xA;<pre><code>PUT /so&#xA;{&#xA;   "settings": {&#xA;      "analysis": {&#xA;         "analyzer": {&#xA;            "suggestion_analyzer": {&#xA;               "tokenizer": "standard",&#xA;               "filter": [&#xA;                  "lowercase"&#xA;               ]&#xA;            },&#xA;            "analyzer_shingle": {&#xA;               "type": "custom",&#xA;               "tokenizer": "standard",&#xA;               "filter": [&#xA;                  "filter_shingle"&#xA;               ]&#xA;            }&#xA;         },&#xA;         "filter": {&#xA;            "filter_shingle": {&#xA;               "type": "shingle",&#xA;               "min_shingle_size": 4,&#xA;               "max_shingle_size": 16,&#xA;               "output_unigrams": "false"&#xA;            }&#xA;         }&#xA;      }&#xA;   },&#xA;   "mappings": {&#xA;      "d": {&#xA;         "properties": {&#xA;            "text": {&#xA;               "properties": {&#xA;                  "english": {&#xA;                     "type": "string",&#xA;                     "fields": {&#xA;                        "shingles": {&#xA;                           "type": "string",&#xA;                           "analyzer": "analyzer_shingle"&#xA;                        },&#xA;                        "suggest": {&#xA;                           "type": "completion",&#xA;                           "index_analyzer": "analyzer_shingle",&#xA;                           "search_analyzer": "analyzer_shingle",&#xA;                           "payloads": true&#xA;                        }&#xA;                     }&#xA;                  }&#xA;               }&#xA;            }&#xA;         }&#xA;      }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Document 1:</p>&#xA;&#xA;<pre><code>POST /so/d/1&#xA;{&#xA;    "text": {&#xA;        "english": "The quick fox jumps over the big wall. JJKJKJKJ"&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Document 2:</p>&#xA;&#xA;<pre><code>POST /so/d/2&#xA;{&#xA;    "text": {&#xA;        "english": "The quick fox jumps over the small wall. JJKJKJKJ"&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Document 3:</p>&#xA;&#xA;<pre><code>POST /so/d/3&#xA;{&#xA;    "text": {&#xA;        "english": "The quick fox jumps over the gugus wall. LLLLLLL"&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Query: </p>&#xA;&#xA;<pre><code>POST /so/_search&#xA;{&#xA;    "size": 0,&#xA;    "query": {&#xA;        "match": {&#xA;           "text.english": "The quick fox jumps over the wall"&#xA;        }&#xA;    }, &#xA;    "aggs" : {&#xA;        "states" : {&#xA;            "terms" : {&#xA;                "field" : "text.english.shingles",&#xA;                "size": 40&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;