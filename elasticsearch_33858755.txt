33858755
Nested query in Elasticsearch?
<p>My team owns several dashboard and are considering the possibility to move to Elasticsearch in order to consolidate the software stacks. One type of common charts we expose is like "What's the pending workflow by the end of each day?". Here are some example data:</p>&#xA;&#xA;<pre><code>day workflow_id version status&#xA;20151101    1   1   In Progress&#xA;20151101    2   1   In Progress&#xA;20151102    1   2   In Progress&#xA;20151102    3   1   In Progress&#xA;20151102    4   1   In Progress&#xA;20151102    2   2   Completed&#xA;20151103    1   3   Completed&#xA;20151103    3   2   In Progress&#xA;20151104    3   3   Completed&#xA;20151105    4   2   Completed&#xA;</code></pre>&#xA;&#xA;<p>Every time when something changed in the workflow, a new record is inserted, which might or might not change the status. The record with the max(version) is the most recent data for the workflow_id. </p>&#xA;&#xA;<p>The goal is to have a chart to show what's the total number of 'In Progress' and 'Completed' workflows at the end of each day. This should only consider the record that has the largest version number until the day. This can be done in SQL with nested queries:</p>&#xA;&#xA;<pre><code>with &#xA;&#xA;snapshot_dates as &#xA;(select distinct day from workflow),&#xA;&#xA;snapshot as &#xA;(select d.day, w.workflow_id, max(w.version) as max_version&#xA;from snapshot_dates d, workflow w&#xA;where d.day &gt;= w.day&#xA;group by d.day, w.workflow_id&#xA;order by d.day, w.workflow_id)&#xA;&#xA;select s.day, w.status, count(1) &#xA;from workflow w join snapshot s on w.workflow_id=s.workflow_id and w.version = s.max_version&#xA;group by s.day, w.status&#xA;order by s.day, w.status;&#xA;</code></pre>&#xA;&#xA;<p>Here is expected output from the query:</p>&#xA;&#xA;<pre><code>day,status,count  &#xA;20151101,In Progress,2  &#xA;20151102,Completed,1  &#xA;20151102,In Progress,3  &#xA;20151103,Completed,2  &#xA;20151103,In Progress,2  &#xA;20151104,Completed,3  &#xA;20151104,In Progress,1  &#xA;20151105,Completed,4 &#xA;</code></pre>&#xA;&#xA;<p>I am still new to Elasticsearch and wonder if Elasticsearch can do a similar query without using application side logic by properly define the mapping and query. More generally, what is the best practice to solve such problem using Elasticsearch?</p>&#xA;
<p>I tried to find the solution using <a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/search-aggregations-pipeline-bucket-script-aggregation.html" rel="nofollow">bucket selector aggregation</a>, but I was stuck at one point. I discussed the same in <a href="https://discuss.elastic.co/t/bucket-selector-aggregation-script-access-doc-index-field-value/35516" rel="nofollow">elasticsearch forum</a>. Following is what suggested by <a href="https://discuss.elastic.co/users/Christian_Dahlqvist/activity" rel="nofollow">Christian Dahlqvist</a>.</p>&#xA;&#xA;<blockquote>&#xA;  <p>In addition to this you also index the record into a workflow-centric&#xA;  index with a unique identifier, e.g. workflow id, as the document id.&#xA;  If several updates come in for the same workflow, each will result in&#xA;  an update and the latest state will be preserved. Running aggregations&#xA;  across this index to find the current or latest state will be&#xA;  considerably more efficient and scalable as you only have a single&#xA;  record per workflow and do not need to filter out documents based on&#xA;  relationships to other documents.</p>&#xA;</blockquote>&#xA;&#xA;<p>So as per this suggestion, you should use <code>Workflow Id</code> as document id while indexing. And whenever there is an update for that workflow, you update new version and date using workflow id. Let's say the index name is <code>workflow</code> and index type is <code>workflow_status</code>. So mapping of this <code>workflow_status</code> type will be as follow:</p>&#xA;&#xA;<pre><code>{&#xA;    "workflow_status": {&#xA;        "properties": {&#xA;            "date": {&#xA;                "type": "date",&#xA;                "format": "strict_date_optional_time||epoch_millis"&#xA;            },&#xA;            "status": {&#xA;                "type": "string",&#xA;                "index": "not_analyzed"&#xA;            },&#xA;            "version": {&#xA;                "type": "long"&#xA;            },&#xA;            "workFlowId": {&#xA;                "type": "long"&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Keep adding/updating the documents to this index type keeping <code>workFlowId</code> as document id.</p>&#xA;&#xA;<p>Now for showing a chart day wise, you may need to create another index type, let's say <code>per_day_workflow</code> with following mapping:</p>&#xA;&#xA;<pre><code>{&#xA;    "per_day_workflow": {&#xA;        "properties": {&#xA;            "date": {&#xA;                "type": "date",&#xA;                "format": "strict_date_optional_time||epoch_millis"&#xA;            },            &#xA;            "in_progress": {&#xA;                "type": "long"&#xA;            },&#xA;            "completed": {&#xA;                "type": "long"&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This index will hold data for each day. So you need to create a job which will run at the end of day and fetch total "In Progress" &amp; "Completed" workflow from <code>workflow_status</code> index type using following aggregation search:</p>&#xA;&#xA;<pre><code>POST http://localhost:9200/workflow/workflow_status/_search?search_type=count&#xA;&#xA;    {&#xA;        "aggs": {&#xA;            "per_status": {&#xA;                "terms": {&#xA;                    "field": "status"&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;</code></pre>&#xA;&#xA;<p>Response will look as follow (I ran for date 2015-11-02 on your sample data):</p>&#xA;&#xA;<pre><code>{&#xA;    "took": 3,&#xA;    "timed_out": false,&#xA;    "_shards": {&#xA;        "total": 5,&#xA;        "successful": 5,&#xA;        "failed": 0&#xA;    },&#xA;    "hits": {&#xA;        "total": 4,&#xA;        "max_score": 0,&#xA;        "hits": []&#xA;    },&#xA;    "aggregations": {&#xA;        "per_status": {&#xA;            "doc_count_error_upper_bound": 0,&#xA;            "sum_other_doc_count": 0,&#xA;            "buckets": [&#xA;                {&#xA;                    "key": "In Progress",&#xA;                    "doc_count": 3&#xA;                },&#xA;                {&#xA;                    "key": "Completed",&#xA;                    "doc_count": 1&#xA;                }&#xA;            ]&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>From this response you need to extract <code>In Progress</code> and <code>Completed</code> count and add them to <code>per_day_workflow</code> index type with today's' date.</p>&#xA;&#xA;<p>Now when you need per day data for your graph, then you can fetch easily from this <code>per_day_workflow</code> index type.</p>&#xA;