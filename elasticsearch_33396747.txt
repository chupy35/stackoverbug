33396747
Why is my query ignoring my filter aggregation?
<p><strong>Preface</strong></p>&#xA;&#xA;<p>I have 4 days experience of Elasticsearch <code>1.7.2</code>.</p>&#xA;&#xA;<p><strong>Setup</strong></p>&#xA;&#xA;<p>I have a collection of documents, each document is a <code>User</code>. The <code>User</code> has a number of <code>Answers</code> which is linked through <code>UserAnswers</code>. Which gives a document reference of <code>user_answers.answer[]</code>. Where the <code>answers</code> array is an array of objects.</p>&#xA;&#xA;<p>The <code>user_answers.answer[].correct</code> is a boolean field which tells me if the answer given by the user is correct or not.</p>&#xA;&#xA;<p><strong>Objective</strong></p>&#xA;&#xA;<p>I would like to list the users and also display the total number of correct and incorrect answers they have.</p>&#xA;&#xA;<p><strong>Approach</strong></p>&#xA;&#xA;<p>So far I have tried a number of different approaches and the one I'll include here is as close as I've got so far in 1.5 days of trying.</p>&#xA;&#xA;<ul>&#xA;<li>Use a <code>terms</code> aggregation to create a bucket for each <code>User</code> by username.</li>&#xA;<li>Filter each bucket to leave only correct or incorrect answers.</li>&#xA;<li>Count the number of filtered answers.</li>&#xA;</ul>&#xA;&#xA;<p><strong>Query</strong></p>&#xA;&#xA;<pre class="lang-js prettyprint-override"><code>{&#xA;    "size": 0,&#xA;    "filter": {&#xA;        "bool": {&#xA;            "must_not": {&#xA;                // Remove users who already have this award&#xA;                "term": {"awards_users.award_id": 2}&#xA;            }&#xA;        }&#xA;    },&#xA;    "aggs": {&#xA;        "users": {&#xA;            "terms": {"field": "username"},&#xA;            "aggs": {&#xA;                "correct": {&#xA;                    "filter": {&#xA;                        "term": {"user_answers.answer.correct": true}&#xA;                    },&#xA;                    "aggs": {&#xA;                        "count": {&#xA;                            "value_count": {&#xA;                                "field": "user_answers.answer.id"&#xA;                            }&#xA;                        }&#xA;                    }&#xA;                },&#xA;                // Same for incorrect, but inverted correct value&#xA;            }&#xA;        }&#xA;    }&#xA;} &#xA;</code></pre>&#xA;&#xA;<p><strong>Sample response</strong></p>&#xA;&#xA;<pre class="lang-js prettyprint-override"><code>{&#xA;  "key": "neon1024",&#xA;  "doc_count": 1,&#xA;  "correct": {&#xA;    "doc_count": 1,&#xA;    "count": {&#xA;      "value": 7 // Expected 1 correct &amp; 6 incorrect&#xA;    }&#xA;  }&#xA;},&#xA;</code></pre>&#xA;&#xA;<p>This is the record which I am testing against, and I am expecting that <code>1</code> is returned instead of <code>7</code>. There are 7 answers in total, 6 incorrect and 1 correct. This I have verified in my document index.</p>&#xA;&#xA;<p><strong>The problem</strong></p>&#xA;&#xA;<p>For some reason the actual filter seems to be being ignored, and leaving all possible related answers in the bucket. Hence the aggregation is seeing them all, rather than showing the expected value.</p>&#xA;&#xA;<p><strong>Question</strong></p>&#xA;&#xA;<p>How can I use an aggregation to segregate my counts based on the value of the related answers values?</p>&#xA;&#xA;<p>Thanks for reading my long question!</p>&#xA;
<p>As suggested, you probably have your answers mapped as <code>object</code>,  while you should be using <code>nested</code> type.</p>&#xA;&#xA;<p>Using nested type, elasticsearch will store your answers as individual documents linked to the root one and will let you do expected aggregations on them.  You'll have to use nested type aggregation in your query to achieve that.</p>&#xA;&#xA;<p>So I'd say it would be best to map your document like this:</p>&#xA;&#xA;<pre><code>PUT /test&#xA;{&#xA;  "mappings" : {&#xA;    "your_type" : {&#xA;      "properties" : {&#xA;        "username" : {&#xA;          "type" : "string",&#xA;          "index" : "not_analyzed"&#xA;        },&#xA;        "user_answers" : {&#xA;          "type" : "nested",&#xA;          "properties" : {&#xA;            "id" : {&#xA;              "type" : "integer"&#xA;            },&#xA;            "answer" : {&#xA;              "type" : "string"&#xA;            },&#xA;            "correct" : {&#xA;              "type" : "boolean"&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Test document:</p>&#xA;&#xA;<pre><code>PUT /test/your_type/1&#xA;{&#xA;  "username": "neon1024",&#xA;  "user_answers": [&#xA;    {&#xA;      "id": 1,&#xA;      "answer": "answer1",&#xA;      "correct": true&#xA;    },&#xA;    {&#xA;      "id": 2,&#xA;      "answer": "answer2",&#xA;      "correct": true&#xA;    },&#xA;    {&#xA;      "id": 3,&#xA;      "answer": "answer3",&#xA;      "correct": false&#xA;    }&#xA;  ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Query:</p>&#xA;&#xA;<pre><code>POST /test/_search?search_type=count&#xA;{&#xA;  "aggs": {&#xA;    "users": {&#xA;      "terms": {&#xA;        "field": "username"&#xA;      },&#xA;      "aggs": {&#xA;        "DiveIn": {&#xA;          "nested": {&#xA;            "path": "user_answers"&#xA;          },&#xA;          "aggs": {&#xA;            "CorrectVsIncorrect": {&#xA;              "terms": {&#xA;                "field": "user_answers.correct",&#xA;                "size": 2&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And Final result:</p>&#xA;&#xA;<pre><code>{&#xA;   "took": 6,&#xA;   "timed_out": false,&#xA;   "_shards": {&#xA;      "total": 5,&#xA;      "successful": 5,&#xA;      "failed": 0&#xA;   },&#xA;   "hits": {&#xA;      "total": 1,&#xA;      "max_score": 0,&#xA;      "hits": []&#xA;   },&#xA;   "aggregations": {&#xA;      "users": {&#xA;         "doc_count_error_upper_bound": 0,&#xA;         "sum_other_doc_count": 0,&#xA;         "buckets": [&#xA;            {&#xA;               "key": "neon1024",&#xA;               "doc_count": 1,&#xA;               "DiveIn": {&#xA;                  "doc_count": 3,&#xA;                  "CorrectVsIncorrect": {&#xA;                     "doc_count_error_upper_bound": 0,&#xA;                     "sum_other_doc_count": 0,&#xA;                     "buckets": [&#xA;                        {&#xA;                           "key": "T",&#xA;                           "doc_count": 2&#xA;                        },&#xA;                        {&#xA;                           "key": "F",&#xA;                           "doc_count": 1&#xA;                        }&#xA;                     ]&#xA;                  }&#xA;               }&#xA;            }&#xA;         ]&#xA;      }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Where <code>"key": "T"</code> represents correct answers and <code>"doc_count": 2</code> represents amount of them.</p>&#xA;