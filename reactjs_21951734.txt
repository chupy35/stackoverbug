21951734
react.js custom events for communicating with parent nodes
<p>I'm making and listening for normal DOM <code>CustomEvent</code>s to communicate to parent nodes:</p>&#xA;&#xA;<p>In child:</p>&#xA;&#xA;<pre class="lang-js prettyprint-override"><code>  var moveEvent = new CustomEvent('the-graph-group-move', { &#xA;    detail: {&#xA;      nodes: this.props.nodes,&#xA;      x: deltaX,&#xA;      y: deltaY&#xA;    },&#xA;    bubbles: true&#xA;  });&#xA;  this.getDOMNode().dispatchEvent(moveEvent);&#xA;</code></pre>&#xA;&#xA;<p>In parent: </p>&#xA;&#xA;<pre class="lang-js prettyprint-override"><code>componentDidMount: function () {&#xA;  this.getDOMNode().addEventListener("the-graph-group-move", this.moveGroup);&#xA;},&#xA;</code></pre>&#xA;&#xA;<p>This works, but is there a React-specific way that would be better? </p>&#xA;
<p>As noted above:</p>&#xA;&#xA;<blockquote>&#xA;  <p>The React way would be to pass callbacks down to children explicitly via props â€” . There's no support for custom events w/ bubbling in React.</p>&#xA;</blockquote>&#xA;&#xA;<p>The reactive programming abstraction is orthogonal:</p>&#xA;&#xA;<blockquote>&#xA;  <p>Programming interactive systems by means of the observer pattern is hard and error-prone yet is still the implementation standard in many production environments. We present an approach to gradually deprecate observers in favor of reactive programming abstractions. Several library layers help programmers to smoothly migrate existing code from callbacks to a more declarative programming model.</p>&#xA;</blockquote>&#xA;&#xA;<p>The React philosophy is based on the Command pattern instead:</p>&#xA;&#xA;<p><a href="https://i.stack.imgur.com/UazA2.png" rel="noreferrer"><img src="https://i.stack.imgur.com/UazA2.png" alt="enter image description here"></a></p>&#xA;&#xA;<p><strong>References</strong></p>&#xA;&#xA;<ul>&#xA;<li><a href="http://lambda-the-ultimate.org/node/4028" rel="noreferrer">Deprecating the Observer Pattern</a></li>&#xA;<li><a href="http://www.cs.mcgill.ca/~hv/classes/CS400/01.hchen/doc/command/command.html" rel="noreferrer">Command Pattern: Command History</a></li>&#xA;<li><a href="http://addyosmani.com/blog/component-interop-with-react-and-custom-elements/" rel="noreferrer">Component Interop with React and Custom Elements</a></li>&#xA;<li><a href="http://blog.ng-book.com/introduction-to-redux-with-typescript-and-angular-2/" rel="noreferrer">Building Redux in TypeScript</a></li>&#xA;<li><a href="http://mithril.js.org/comparison.html" rel="noreferrer">How is Mithril Different from Other Frameworks - Mithril</a></li>&#xA;</ul>&#xA;
<p>There is another one I found which is quite reasonable as well especially if drilling holes from parent to child to child becomes cumbersome already. He called it less simple communication. Here's the link:</p>&#xA;&#xA;<p><a href="https://github.com/ryanflorence/react-training/blob/gh-pages/lessons/04-less-simple-communication.md" rel="nofollow">https://github.com/ryanflorence/react-training/blob/gh-pages/lessons/04-less-simple-communication.md</a></p>&#xA;
<p>A possible solution, if you absolutely <em>must</em> resort to the Observer pattern in a ReactJs app you can hijack a normal event. For example, if you want the delete key to cause a <code>&lt;div&gt;</code> that is marked for deletion, you could have the <code>&lt;div&gt;</code> listen for a keydown event which will be invoked by a customEvent. Trap the keydown on the body and dispatch a <code>customEvent</code> keydown event on the selected <code>&lt;div&gt;</code>. Sharing in case it helps someone.</p>&#xA;
<p>You could bubble events up through callbacks passed down via contexts: <a href="http://codepen.io/jedwards1211/pen/yOqGxK?editors=1111" rel="nofollow" title="[CodePen]">[CodePen]</a></p>&#xA;&#xA;<pre><code>import React, {Component, PropTypes} from 'react';&#xA;&#xA;class EventContext extends Component {&#xA;  static contextTypes = {&#xA;    onMyEvent: PropTypes.func&#xA;  };&#xA;  static childContextTypes = {&#xA;    onMyEvent: PropTypes.func.isRequired&#xA;  };&#xA;  static propTypes = {&#xA;    onMyEvent: PropTypes.func.isRequired&#xA;  };&#xA;  getChildContext() {&#xA;    let {onMyEvent} = this.props;&#xA;    return {&#xA;      onMyEvent: (...args) =&gt; {&#xA;        // stop propagation if handler returns false&#xA;        if (onMyEvent(...args) !== false) {&#xA;          // bubble the event&#xA;          this.context.onMyEvent &amp;&amp; this.context.onMyEvent(...args);&#xA;        }&#xA;      }&#xA;    };&#xA;  }&#xA;  render() {&#xA;    return this.props.children;&#xA;  }&#xA;}&#xA;&#xA;class MyComponent extends Component {&#xA;  static contextTypes = {&#xA;    onMyEvent: PropTypes.func&#xA;  };&#xA;  render() {&#xA;    let {onMyEvent} = this.context;&#xA;    return &lt;button onClick={onMyEvent}&gt;Click me&lt;/button&gt;;&#xA;  }&#xA;}&#xA;&#xA;export default &lt;EventContext onMyEvent={e =&gt; console.log('grandparent got event: ', e)}&gt;&#xA;  &lt;EventContext onMyEvent={e =&gt; console.log('parent got event: ', e)}&gt;&#xA;    &lt;MyComponent/&gt;&#xA;  &lt;/EventContext&gt;&#xA;&lt;/EventContext&gt;;&#xA;</code></pre>&#xA;
<p>A central store [Redux] that distributes state to clients, that then 'dispatch' state back up to the store is like an observer pattern too. A way of doing publish/subscribe only worse because of explicit (brittle ?) overhead connecting props/events paths. To hack down through hierarchy React provides context (provider pattern) or observable libraries that stink. Like MobX that introduces new decorators @observable, or Vue that introduces new template syntax "v-if". Event's are the primary way DOM and javascript event loop work anyway, so why not ? I think the satanists did it.  Lol </p>&#xA;
<p>you can write a simple service and then use it</p>&#xA;&#xA;<pre><code>/** eventsService */&#xA;module.exports = {&#xA;  callbacks: {},&#xA;&#xA;  /**&#xA;   * @param {string} eventName&#xA;   * @param {*} data&#xA;   */&#xA;  triggerEvent(eventName, data = null) {&#xA;    if (this.callbacks[eventName]) {&#xA;      Object.keys(this.callbacks[eventName]).forEach((id) =&gt; {&#xA;        this.callbacks[eventName][id](data);&#xA;      });&#xA;    }&#xA;  },&#xA;&#xA;  /**&#xA;   * @param {string} eventName name of event&#xA;   * @param {string} id callback identifier&#xA;   * @param {Function} callback&#xA;   */&#xA;  listenEvent(eventName, id, callback) {&#xA;    this.callbacks[eventName][id] = callback;&#xA;  },&#xA;&#xA;  /**&#xA;   * @param {string} eventName name of event&#xA;   * @param {string} id callback identifier&#xA;   */&#xA;  unlistenEvent(eventName, id) {&#xA;    delete this.callbacks[eventName][id];&#xA;  },&#xA;};&#xA;</code></pre>&#xA;&#xA;<p>example (same for triggering)</p>&#xA;&#xA;<pre><code>import eventsService from '../../../../services/events';&#xA;export default class FooterMenu extends Component {&#xA;  componentWillMount() {&#xA;    eventsService&#xA;      .listenEvent('cart', 'footer', this.cartUpdatedListener.bind(this));&#xA;  }&#xA;&#xA;  componentWillUnmount() {&#xA;    eventsService&#xA;      .unlistenEvent('cart', 'footer');&#xA;  }&#xA;&#xA;  cartUpdatedListener() {&#xA;    console.log('cart updated');&#xA;  }&#xA;}&#xA;</code></pre>&#xA;