30649740
Elasticsearch: find documents with distinct values and then aggregate over them
<p>My index has a log-like structure: I insert a version of a document whenever an event occurs. For example, here are documents in the index:</p>&#xA;&#xA;<pre><code>{ "key": "a", subkey: 0 }&#xA;{ "key": "a", subkey: 0 }&#xA;{ "key": "a", subkey: 1 }&#xA;{ "key": "a", subkey: 1 }&#xA;{ "key": "b", subkey: 0 }&#xA;{ "key": "b", subkey: 0 }&#xA;{ "key": "b", subkey: 1 }&#xA;{ "key": "b", subkey: 1 }&#xA;</code></pre>&#xA;&#xA;<p>I'm trying to construct a query in ElasticSearch which is basically equivalent to the following SQL query:</p>&#xA;&#xA;<pre><code>SELECT COUNT(*), key, subkey&#xA;FROM (SELECT DISTINCT key, subkey FROM t)&#xA;</code></pre>&#xA;&#xA;<p>The answer to this query would obviously be</p>&#xA;&#xA;<pre><code>(1, a, 0)&#xA;(1, a, 1)&#xA;(1, b, 0)&#xA;(1, b, 1)&#xA;</code></pre>&#xA;&#xA;<p>How would I replicate this query in Elasticsearch? I came up with the following:</p>&#xA;&#xA;<pre><code>GET test_index/test_type/_search?search_type=count&#xA;{&#xA;  "aggregations": {&#xA;    "count_aggr": {&#xA;      "terms": {&#xA;        "field": "concatenated_key"&#xA;      },&#xA;      "aggs": {&#xA;        "sample_doc": {&#xA;          "top_hits": {&#xA;            "size": 1&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><code>concatenated_key</code> is a concatenation of <code>key</code> and <code>subkey</code>. This query would create a bucket for each (key, subkey) combination and return a sample document from each bucket. However, I don't know how can I aggregate over the fields of <code>_source</code>.</p>&#xA;&#xA;<p>Would appreciate any ideas. Thanks!</p>&#xA;
<p>If you don't have the possibility to re-index the documents and to add <strong>your own concatenated key</strong> field, this is a way of doing it:</p>&#xA;&#xA;<pre><code>GET /my_index/my_type/_search?search_type=count&#xA;{&#xA;  "aggs": {&#xA;    "key_agg": {&#xA;      "terms": {&#xA;        "field": "key",&#xA;        "size": 10&#xA;      },&#xA;      "aggs": {&#xA;        "sub_key_agg": {&#xA;          "terms": {&#xA;            "field": "subkey",&#xA;            "size": 10&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>It will give you something like this:</p>&#xA;&#xA;<pre><code>     "buckets": [&#xA;        {&#xA;           "key": "a",&#xA;           "doc_count": 4,&#xA;           "sub_key_agg": {&#xA;              "doc_count_error_upper_bound": 0,&#xA;              "sum_other_doc_count": 0,&#xA;              "buckets": [&#xA;                 {&#xA;                    "key": 0,&#xA;                    "doc_count": 2&#xA;                 },&#xA;                 {&#xA;                    "key": 1,&#xA;                    "doc_count": 2&#xA;                 }&#xA;              ]&#xA;           }&#xA;        },&#xA;        {&#xA;           "key": "b",&#xA;           "doc_count": 4,&#xA;           "sub_key_agg": {&#xA;              "doc_count_error_upper_bound": 0,&#xA;              "sum_other_doc_count": 0,&#xA;              "buckets": [&#xA;                 {&#xA;                    "key": 0,&#xA;                    "doc_count": 2&#xA;                 },&#xA;                 {&#xA;                    "key": 1,&#xA;                    "doc_count": 2&#xA;                 }&#xA;              ]&#xA;           }&#xA;        }&#xA;     ]&#xA;</code></pre>&#xA;&#xA;<p>where you have the key - <code>"key": "a"</code> - and then each combination with this key and the number of docs that match key=a and subkey=0 or key=a and subkey=1:</p>&#xA;&#xA;<pre><code>             "buckets": [&#xA;                 {&#xA;                    "key": 0,&#xA;                    "doc_count": 2&#xA;                 },&#xA;                 {&#xA;                    "key": 1,&#xA;                    "doc_count": 2&#xA;                 }&#xA;              ]&#xA;</code></pre>&#xA;&#xA;<p>Same goes for the other key.</p>&#xA;