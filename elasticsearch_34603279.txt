34603279
Elasticsearch: filtering by max value on a field that is a collection in a nested object
<p>When I do a query in ES, I'd like it to look only at the max value of the <code>discounts.percent_value</code> field if there are multiple discounts (elements) in the collection of <code>discounts</code>. In the example below, I'd only like the nested query to operate on the document's discounts and having it only aware of the the 60% discount. </p>&#xA;&#xA;<p><strong>My existing filter looks something like this:</strong></p>&#xA;&#xA;<pre><code>discount_filter = { &#xA;  nested: {&#xA;    path: "discounts", query: { bool: { must: [&#xA;      { range: { "discounts.percent_value" =&gt; { lte: query_filter.discount_max } } },&#xA;      { range: { "discounts.starts_at"     =&gt; { lte: "now" } } },&#xA;      { range: { "discounts.ends_at"       =&gt; { gte: "now" } } }&#xA;    ] } },&#xA;    filter: { &#xA;      script: { &#xA;        script: "doc['discounts.percent_value'].values.max" &#xA;      } &#xA;    }&#xA;  } &#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>Mapping:</strong></p>&#xA;&#xA;<pre><code>"mappings": {&#xA;  "product": {&#xA;    "properties": {&#xA;      "discounts": {&#xA;        "type": "nested",&#xA;        "properties": {&#xA;          "ends_at": {&#xA;            "type": "date",&#xA;            "format": "dateOptionalTime"&#xA;          },&#xA;          "percent": {&#xA;            "type": "string"&#xA;            },&#xA;          "percent_value": {&#xA;            "type": "float"&#xA;          },&#xA;          "return_policy_key": {&#xA;            "type": "string",&#xA;            "index": "not_analyzed"&#xA;          },&#xA;          "starts_at": {&#xA;            "type": "date",&#xA;            "format": "dateOptionalTime"&#xA;          }&#xA;        }&#xA;      } &#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>Sample Document (with multiple discounts):</strong></p>&#xA;&#xA;<pre><code>{&#xA;  "_index": "products_test_index",&#xA;  "_type": "product",&#xA;  "_id": "6",&#xA;  "_score": 1,&#xA;  "_source": {&#xA;    "id": 6,&#xA;    "name": "Some Product",&#xA;    "permalink": "some-product-42",&#xA;    "price": 100,&#xA;    "minimum_price": 0,&#xA;    "discounts": [&#xA;      {&#xA;        "starts_at": "2016-01-03T01:37:02Z",&#xA;        "ends_at": "2016-01-07T01:37:02Z",&#xA;        "percent": "40.0",&#xA;        "percent_value": "40.0",&#xA;        "return_policy_key": "0.0"&#xA;      },&#xA;      {&#xA;        "starts_at": "2016-01-03T01:37:02Z",&#xA;        "ends_at": "2016-01-07T01:37:02Z",&#xA;        "percent": "60.0",&#xA;        "percent_value": "60.0",&#xA;        "return_policy_key": "0.0"&#xA;      }&#xA;    ]&#xA;  }&#xA;}&#xA;</code></pre>&#xA;
<p>The way I'd approach this is to select only the nested active discounts (i.e. the ones whose start/end date interval contains now) and then use a combination of <code>nested</code> + <code>max</code> aggregation in order to retrieve the biggest discount:</p>&#xA;&#xA;<pre><code>{&#xA;  "query": {&#xA;    "nested": {&#xA;      "path": "discounts",&#xA;      "query": {&#xA;        "bool": {&#xA;          "must": [&#xA;            {&#xA;              "range": {&#xA;                "discounts.starts_at": {&#xA;                  "lte": "now"&#xA;                }&#xA;              }&#xA;            },&#xA;            {&#xA;              "range": {&#xA;                "discounts.ends_at": {&#xA;                  "gte": "now"&#xA;                }&#xA;              }&#xA;            }&#xA;          ]&#xA;        }&#xA;      }&#xA;    }&#xA;  },&#xA;  "aggs": {&#xA;    "discounts": {&#xA;      "nested": {&#xA;        "path": "discounts"&#xA;      },&#xA;      "aggs": {&#xA;        "max_discounts": {&#xA;          "max": {&#xA;            "field": "discounts.percent_value"&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;