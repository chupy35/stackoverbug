33945796
Understanding Analyzers, Filters and Queries in Elasticsearch
<p>I'm trying to get my head around when I should be using analyzers, filters and queries. I've read through the Search in Depth article on the elastic.co site, and have a better understanding, but the examples are naive to my use case, and still slightly confusing.</p>&#xA;&#xA;<p>Given I have documents with an array of ingredients, containing any mix of <code>digestive biscuits</code>, <code>biscuits</code>, <code>cheese</code>, and <code>chocolate</code>, I am trying to figure out what is the best way to analyze that data, and perform a search on it.</p>&#xA;&#xA;<p>Here's a simple set of documents:</p>&#xA;&#xA;<pre><code>[{&#xA;    "ingredients": ["cheese", "chocolate"]&#xA;}, {&#xA;    "ingredients": ["chocolate", "biscuits"]&#xA;}, {&#xA;    "ingredients": ["cheese", "biscuits"]&#xA;}, {&#xA;    "ingredients": ["chocolate", "digestive biscuits"]&#xA;}, {&#xA;    "ingredients": ["cheese", "digestive biscuits"]&#xA;}, {&#xA;    "ingredients": ["cheese", "chocolate", "biscuits"]&#xA;}, {&#xA;    "ingredients": ["cheese", "chocolate", "digestive biscuits"]&#xA;}]&#xA;</code></pre>&#xA;&#xA;<p>(I've intentionally not mixed <code>biscuits</code> and <code>digestive biscuits</code> here, I'll explain in a mo.)</p>&#xA;&#xA;<p>I have one search field that will allow people to free type whatever ingredients they choose, and I currently split this out on whitespace to give me an array of terms to use.</p>&#xA;&#xA;<p>I have the mapping as such:</p>&#xA;&#xA;<pre><code>{&#xA;    "properties": {&#xA;        "ingredients": {&#xA;            "type": "string",&#xA;            "analyzer": "keyword"&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The problems I am facing here are that <code>biscuits</code> does not match <code>digestive biscuits</code>, and <code>biscuit</code> does not match anything.</p>&#xA;&#xA;<p>I know I have to analyze the field with a <code>snowball</code> analyzer, but I am very unsure on how to do this.</p>&#xA;&#xA;<p>Do I need a multi-field approach? Do I need to query with filters too? The results I would like to see are:</p>&#xA;&#xA;<ul>&#xA;<li><code>biscuit</code> matching both <code>biscuits</code> and <code>digestive biscuits</code> (the latter being scored lower)</li>&#xA;<li><code>biscuits</code> matching both <code>biscuits</code> and <code>digestive biscuits</code> (the latter being scored lower)</li>&#xA;<li><code>digestive</code> matching <code>digestive biscuits</code></li>&#xA;<li><code>digestive biscuits</code> matching itself and <code>biscuits</code> (the latter being scored lower)</li>&#xA;</ul>&#xA;&#xA;<p>Also, throwing any other term in randomly, how do I handle that? Use a filter or a query?</p>&#xA;&#xA;<p>Very puzzled by how to structure this right from index through mapping and search, so if anyone has any example advice, I'd greatly appreciate it.</p>&#xA;
<p>First of all, I'd suggest reading this: <a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/stemming.html" rel="nofollow">https://www.elastic.co/guide/en/elasticsearch/guide/current/stemming.html</a></p>&#xA;&#xA;<p>It discusses exact problem you're facing.</p>&#xA;&#xA;<p>So to fix this, you have to use custom analyzer (it's built using character filters, tokenizer and filters). Analyzer emits tokens from text blob.</p>&#xA;&#xA;<p>So in your specific case, I'll show you how to create a simple custom analyzer to achieve what you want:</p>&#xA;&#xA;<pre><code>PUT /test&#xA;{&#xA;  "settings": {&#xA;    "analysis": {&#xA;      "analyzer": {&#xA;        "my_analyzer_custom": {&#xA;          "type": "custom",&#xA;          "tokenizer": "standard",&#xA;          "filter": [&#xA;            "asciifolding",&#xA;            "lowercase",&#xA;            "kstem"&#xA;          ]&#xA;        }&#xA;      }&#xA;    }&#xA;  },&#xA;  "mappings": {&#xA;    "data": {&#xA;      "properties": {&#xA;        "ingredients": {&#xA;          "type": "string",&#xA;          "analyzer": "my_analyzer_custom"&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This analyzer will split your text using standard tokenizer and apply these filters:</p>&#xA;&#xA;<ul>&#xA;<li><code>asciifolding</code> - normalizes letters with accent characters (Ã© => e)</li>&#xA;<li><code>lowercase</code> - lowercases tokens, so that searches are case insensitive</li>&#xA;<li><code>kstem</code> - filter, that normalizes tokens to their root forms (not ideal, but does a good job). In this case it's going to normalize biscuits into biscuit</li>&#xA;</ul>&#xA;&#xA;<p>So there's your sample data:</p>&#xA;&#xA;<pre><code>PUT /test/data/1&#xA;{&#xA;  "ingredients": ["cheese", "chocolate"]&#xA;}&#xA;PUT /test/data/2&#xA;{&#xA;  "ingredients": ["chocolate", "biscuits"]&#xA;}&#xA;PUT /test/data/3&#xA;{&#xA;  "ingredients": ["cheese", "biscuits"]&#xA;}&#xA;PUT /test/data/4&#xA;{&#xA;  "ingredients": ["chocolate", "digestive biscuits"]&#xA;}&#xA;PUT /test/data/5&#xA;{&#xA;  "ingredients": ["cheese", "digestive biscuits"]&#xA;}&#xA;PUT /test/data/6&#xA;{&#xA;  "ingredients": ["cheese", "chocolate", "biscuits"]&#xA;}&#xA;PUT /test/data/7&#xA;{&#xA;  "ingredients": ["cheese", "chocolate", "digestive biscuits"]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And this query:</p>&#xA;&#xA;<pre><code>GET /test/_search&#xA;{&#xA;  "query": {&#xA;    "dis_max": {&#xA;      "tie_breaker": 0.7,&#xA;      "boost": 1.5,&#xA;      "queries": [&#xA;        {&#xA;          "match": {&#xA;            "ingredients": {&#xA;              "query": "digestive biscuits",&#xA;              "type": "phrase",&#xA;              "boost": 5&#xA;            }&#xA;          }&#xA;        },&#xA;        {&#xA;          "match": {&#xA;            "ingredients": {&#xA;              "query": "digestive biscuits",&#xA;              "operator": "and",&#xA;              "boost": 3&#xA;            }&#xA;          }&#xA;        },&#xA;        {&#xA;          "match": {&#xA;            "ingredients": {&#xA;              "query": "digestive biscuits"&#xA;            }&#xA;          }&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I've used <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.1/query-dsl-dis-max-query.html" rel="nofollow">Dis Max Query</a> in this case. You see that there's an array of queries? We're specifying multiple queries there and it brings back document with highest score. From documentation:</p>&#xA;&#xA;<blockquote>&#xA;  <p>A query that generates the union of documents produced by its&#xA;  subqueries, and that scores each document with the maximum score for&#xA;  that document as produced by any subquery, plus a tie breaking&#xA;  increment for any additional matching subqueries.</p>&#xA;</blockquote>&#xA;&#xA;<p>So in this case I've specified three queries:</p>&#xA;&#xA;<ul>&#xA;<li><a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/phrase-matching.html" rel="nofollow">Phrase Match</a>. A query should match on terms and positions.</li>&#xA;<li>Match with <code>"operator": "and"</code>, it means that all terms must match regardless of their order</li>&#xA;<li>A simple Match query. It means that any of tokens must match</li>&#xA;</ul>&#xA;&#xA;<p>You can see that for each of them I'm specifying different boost values - that's how you prioritize their importance.</p>&#xA;&#xA;<p>I hope this helps.</p>&#xA;
<p>This is how I would approach this problem. I created the index with following settings</p>&#xA;&#xA;<pre><code>POST food_index&#xA;{&#xA;  "settings": {&#xA;    "analysis": {&#xA;      "analyzer": {&#xA;        "my_custom_analyzer": {&#xA;          "tokenizer": "standard",&#xA;          "filter": [&#xA;            "lowercase",&#xA;            "english_possessive_stemmer",&#xA;            "light_english_stemmer",&#xA;            "asciifolding"&#xA;          ]&#xA;        }&#xA;      },&#xA;      "filter": {&#xA;        "light_english_stemmer": {&#xA;          "type": "stemmer",&#xA;          "language": "light_english"&#xA;        },&#xA;        "english_possessive_stemmer": {&#xA;          "type": "stemmer",&#xA;          "language": "possessive_english"&#xA;        }&#xA;      }&#xA;    }&#xA;  },&#xA;  "mappings": {&#xA;    "your_type": {&#xA;      "properties": {&#xA;        "ingredients": {&#xA;          "type": "string",&#xA;          "analyzer": "my_custom_analyzer"&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<ul>&#xA;<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.0/analysis-lowercase-tokenfilter.html" rel="nofollow">lowercase</a> filter will lowercase all the words as the name suggests,this will help match <em>Biscuits</em> to <em>biscuits</em></li>&#xA;<li><a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/algorithmic-stemmers.html" rel="nofollow">possessive_english</a> removes <code>'s</code> from words so that we can match <em>biscuit's</em> to <em>biscuit</em></li>&#xA;<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-stemmer-tokenfilter.html" rel="nofollow">light_english</a> to stem the words. This is less aggressive and uses <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-kstem-tokenfilter.html" rel="nofollow">kstem</a> token filter</li>&#xA;<li><a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/asciifolding-token-filter.html" rel="nofollow">asciifolding</a> to handle diacritics(I dont think it is useful but it is up to you)</li>&#xA;</ul>&#xA;&#xA;<p>After that I inserted documents you provided in the questions. I think you need simple <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html" rel="nofollow">query string query</a>. This will satisfy all your requirements as far as <code>scoring</code> of documents is concerned.</p>&#xA;&#xA;<pre><code>{&#xA;  "query": {&#xA;    "query_string": {&#xA;      "default_field": "ingredients",&#xA;      "query": "digestive biscuits"&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This gave me exactly what you asked for. Please try these settings and query with your dataset and let me know if you face any issues.</p>&#xA;&#xA;<p>I hope this helps!</p>&#xA;