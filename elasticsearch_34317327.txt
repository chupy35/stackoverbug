34317327
Tokenize QueryStringQuery string using ElasticSearch?
<p>I'm using Elastic 1.7 (and java api).  Is there a good way to use Elastic to tokenize the querystringquery-style string:</p>&#xA;&#xA;<pre><code>automobile or car and (telsa or "name is missing" or "aston martin")&#xA;</code></pre>&#xA;&#xA;<p>into the tokens:</p>&#xA;&#xA;<pre><code>"automobile", "car", "tesla", "name is missing", "aston martin" &#xA;</code></pre>&#xA;&#xA;<p>It seems like I could use a pattern tokenizer but that pattern gets tricky in a hurry.  Is a better way?</p>&#xA;
<p>I used bunch of <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.1/analysis-pattern-replace-charfilter.html" rel="nofollow">pattern replace character filters</a> for this,</p>&#xA;&#xA;<p>This is my setup</p>&#xA;&#xA;<pre><code>"analysis": {&#xA;    "char_filter": {&#xA;        "space_pattern": {&#xA;            "type": "pattern_replace",&#xA;            "pattern": "\\s+",&#xA;            "replacement": " "&#xA;        },&#xA;        "replace_space_comma": {&#xA;            "type": "pattern_replace",&#xA;            "pattern": " ",&#xA;            "replacement": "-"&#xA;        },&#xA;        "replace_and_or_with_hyphen": {&#xA;            "type": "pattern_replace",&#xA;            "pattern": "(?i)-or-|-and-",&#xA;            "replacement": " "&#xA;        },&#xA;        "remove_brackets": {&#xA;            "type": "pattern_replace",&#xA;            "pattern": "[()]",&#xA;            "replacement": ""&#xA;        }&#xA;    },&#xA;    "analyzer": {&#xA;        "token_analyzer": {&#xA;            "char_filter": ["html_strip",&#xA;                "remove_brackets",&#xA;                "space_pattern",&#xA;                "replace_space_comma",&#xA;                "replace_and_or_with_hyphen"&#xA;            ],&#xA;            "tokenizer": "whitespace",&#xA;            "filter": ["lowercase"]&#xA;        }&#xA;    }&#xA;&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>1)<code>html_strip</code> is optional (only if you want)</p>&#xA;&#xA;<p>2) Then I am removing brackets <code>(</code> and <code>)</code> with <code>remove_brackets</code></p>&#xA;&#xA;<p>3) Then I am reducing continuous multiple spaces into one with <code>space_pattern</code></p>&#xA;&#xA;<p>4) After that I am replacing every space with comma with <code>replace_space_comma</code>, this is important because then I can use comma to remove <code>and</code> AND <code>or</code>, you could use any other symbol if you like</p>&#xA;&#xA;<p>5) Final step is removing <code>and</code> AND <code>or</code>, <code>(?i)</code> is case insensitive flag</p>&#xA;&#xA;<p>I am using <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-whitespace-tokenizer.html" rel="nofollow">whitespace tokenizer</a> to divide the text into tokens, I am also using lowercase filter (you could remove this if you want)</p>&#xA;&#xA;<p>so string <code>automobile or car and (telsa or name is missing or aston martin)</code> is getting tokenized into </p>&#xA;&#xA;<pre><code>{&#xA;   "tokens": [&#xA;      {&#xA;         "token": "automobile",&#xA;         "start_offset": 0,&#xA;         "end_offset": 10,&#xA;         "type": "word",&#xA;         "position": 1&#xA;      },&#xA;      {&#xA;         "token": "car",&#xA;         "start_offset": 14,&#xA;         "end_offset": 17,&#xA;         "type": "word",&#xA;         "position": 2&#xA;      },&#xA;      {&#xA;         "token": "telsa",&#xA;         "start_offset": 23,&#xA;         "end_offset": 28,&#xA;         "type": "word",&#xA;         "position": 3&#xA;      },&#xA;      {&#xA;         "token": "name-is-missing",&#xA;         "start_offset": 32,&#xA;         "end_offset": 47,&#xA;         "type": "word",&#xA;         "position": 4&#xA;      },&#xA;      {&#xA;         "token": "aston-martin",&#xA;         "start_offset": 51,&#xA;         "end_offset": 64,&#xA;         "type": "word",&#xA;         "position": 5&#xA;      }&#xA;   ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This is not perfect, you would have to replace hyphen with space after getting tokens to get desired output</p>&#xA;&#xA;<p>I hope this helps!</p>&#xA;