29702976
How do I get Elasticsearch to ignore terms emptied by a char_filter?
<p>I have a set of US street addresses that I've indexed. The source data is imperfect and sometimes fields contain junk. Specifically, I have <code>zip5</code> and <code>zip4</code> fields and a <code>pattern_replace</code> <code>char_filter</code> that strips any non-numeric characters. When that <code>char_filter</code> ends up replacing everything (yielding an empty string), matching still seems to look at that field. The same happens if the original field is just an empty string (as opposed to null). How could I set this up such that it'll just disregard fields that are empty strings (either by source or by the result of a char_filter)?</p>&#xA;&#xA;<h3>Example</h3>&#xA;&#xA;<p>First, let's create an index with a <code>digits_only</code> pattern replacer and an analyzer that uses it:</p>&#xA;&#xA;<pre><code>curl -XPUT "http://localhost:9200/address_bug" -d'&#xA;{&#xA;  "settings": {&#xA;    "index": {&#xA;      "number_of_shards": "4",&#xA;      "number_of_replicas": "1"&#xA;    },&#xA;    "analysis": {&#xA;      "char_filter" : {&#xA;        "digits_only" : {&#xA;          "type" : "pattern_replace",&#xA;          "pattern" : "([^0-9])",&#xA;          "replacement" : ""&#xA;        }&#xA;      },&#xA;      "analyzer" : {&#xA;        "zip" : {&#xA;          "type" : "custom",&#xA;          "tokenizer" : "keyword",&#xA;          "char_filter" : [&#xA;            "digits_only"&#xA;          ]&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}'&#xA;</code></pre>&#xA;&#xA;<p>Now, let's create a mapping that uses the analyzer (<em>NB: I'm using <code>with_positions_offsets</code> for highlighting</em>):</p>&#xA;&#xA;<pre><code>curl -XPUT "http://localhost:9200/address_bug/_mapping/address" -d'&#xA;{&#xA;  "address": {&#xA;    "properties": {&#xA;      "zip5": {&#xA;        "type" : "string",&#xA;        "analyzer" : "zip",&#xA;        "term_vector" : "with_positions_offsets"&#xA;      },&#xA;      "zip4": {&#xA;        "type" : "string",&#xA;        "analyzer" : "zip",&#xA;        "term_vector" : "with_positions_offsets"&#xA;      }&#xA;    }&#xA;  }&#xA;}'&#xA;</code></pre>&#xA;&#xA;<p>Now that our index and type is set up, let's index some imperfect data:</p>&#xA;&#xA;<pre><code>curl -XPUT "http://localhost:9200/address_bug/address/1234" -d'&#xA;{&#xA;  "zip5" : "02144",&#xA;  "zip4" : "ABCD"&#xA;}'&#xA;</code></pre>&#xA;&#xA;<p>Alright, let's search for it and ask it to <code>explain</code> itself. In this case the search term is <em>Street</em> because in my actual application I have a single field for full address searching.</p>&#xA;&#xA;<pre><code>curl -XGET "http://localhost:9200/address_bug/address/_search?explain" -d'&#xA;{&#xA;  "query": {&#xA;    "match": {&#xA;      "zip4": "Street"&#xA;    }&#xA;  }&#xA;}'&#xA;</code></pre>&#xA;&#xA;<p>And, here is the interesting part of the <strong>results</strong>:</p>&#xA;&#xA;<pre><code>"_explanation": {&#xA;   "value": 0.30685282,&#xA;   "description": "weight(zip4: in 0) [PerFieldSimilarity], result of:",&#xA;   "details": [&#xA;      {&#xA;         "value": 0.30685282,&#xA;         "description": "fieldWeight in 0, product of:",&#xA;         "details": [&#xA;            {&#xA;               "value": 1,&#xA;               "description": "tf(freq=1.0), with freq of:",&#xA;               "details": [&#xA;                  {&#xA;                     "value": 1,&#xA;                     "description": "termFreq=1.0"&#xA;                  }&#xA;               ]&#xA;            },&#xA;            {&#xA;               "value": 0.30685282,&#xA;               "description": "idf(docFreq=1, maxDocs=1)"&#xA;            },&#xA;            {&#xA;               "value": 1,&#xA;               "description": "fieldNorm(doc=0)"&#xA;            }&#xA;         ]&#xA;      }&#xA;   ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>(Full response is <a href="https://gist.github.com/mklaber/cf294781e16910cd5fc4" rel="nofollow">in this gist</a>.)</p>&#xA;&#xA;<h3>Expected Result</h3>&#xA;&#xA;<p>I wouldn't have expected any hits. If I instead index a document with <code>"zip4" : null</code>, it yields the expect results: no hits.</p>&#xA;&#xA;<p>Help? Am I even taking the right approach here? In my full application, I'm using the same technique for a <code>phone</code> field and suspect I'd have the same issues with the results.</p>&#xA;
<p>As @plmaheu mentioned, you can use the stop token filter to completely remove&#xA;empty strings, so for instance, this is a configuration that I tested that&#xA;works:</p>&#xA;&#xA;<pre><code>POST /myindex&#xA;{&#xA;  "settings": {&#xA;    "analysis": {&#xA;      "char_filter" : {&#xA;        "digits_only" : {&#xA;          "type" : "pattern_replace",&#xA;          "pattern" : "[^0-9]+",&#xA;          "replacement" : ""&#xA;        }&#xA;      },&#xA;      "filter": {&#xA;        "remove_empty": {&#xA;          "type": "stop",&#xA;          "stopwords": [""]&#xA;        }&#xA;      },&#xA;      "analyzer" : {&#xA;        "zip" : {&#xA;          "type" : "custom",&#xA;          "tokenizer" : "keyword",&#xA;          "char_filter" : [&#xA;            "digits_only"&#xA;          ],&#xA;          "filter": ["remove_empty"]&#xA;        }&#xA;      }&#xA;    }&#xA;  },&#xA;  "mappings": {&#xA;    "doc": {&#xA;      "properties": {&#xA;        "zip": {&#xA;          "type": "string",&#xA;          "analyzer": "zip"&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Here the <code>remove_empty</code> filter removes the stopword "", if you use the analyze&#xA;API on the string "abcd", you get back the response <code>{"tokens":[]}</code>, so no&#xA;tokens will be indexed if the zip code is entirely invalid.</p>&#xA;&#xA;<p>I also tested this works when searching for "foo", no results are found.</p>&#xA;
<p>You can use a <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-length-tokenfilter.html" rel="nofollow noreferrer">length token filter</a> like this:</p>&#xA;&#xA;<pre><code>"filter": {&#xA;  "remove_empty": {&#xA;    "type": "length",&#xA;    "min": 1&#xA;  }&#xA;}&#xA;</code></pre>&#xA;