29423761
Elasticsearch array only gives uniques to aggregation script
<p>I would like to do some simple linear algebra in Elasticsearch with a scripted metric in an aggregation. I am trying to use an array type to store a vector. My issue is that in my script, I am receiving only a set of unique values from the array, rather than the full array with its original sorting. Is there a way to get the original array in the script?</p>&#xA;&#xA;<p>Consider this example document:</p>&#xA;&#xA;<pre><code>curl -XPUT 'http://localhost:9200/arraytest/aoeu/1' -d '{&#xA;    "items": [1, 2, 2, 3]&#xA;}'&#xA;</code></pre>&#xA;&#xA;<p>It looks right in the <code>_source</code>:</p>&#xA;&#xA;<pre><code>curl -XGET 'http://localhost:9200/arraytest/aoeu/1'&#xA;</code></pre>&#xA;&#xA;<p>result:</p>&#xA;&#xA;<pre><code>{"_index":"arraytest","_type":"aoeu","_id":"1","_version":1,"found":true,"_source":{&#xA;    "items": [1, 2, 2, 3]&#xA;}}&#xA;</code></pre>&#xA;&#xA;<p>However, it does not look right when I get the value in a script:</p>&#xA;&#xA;<pre><code>curl -XGET 'http://localhost:9200/arraytest/aoeu/_search?pretty&amp;search_type=count' -d '{&#xA;    "query": {&#xA;        "match_all" : {}&#xA;    },&#xA;    "aggs": {&#xA;        "tails": {&#xA;            "scripted_metric": {&#xA;                "init_script": "_agg.items = []",&#xA;                "map_script": "_agg.items.add(doc.items)",&#xA;                "reduce_script": "items = []; for (a in _aggs) { items.add(a.items) }; return items"&#xA;            }&#xA;        }&#xA;    }&#xA;}'&#xA;</code></pre>&#xA;&#xA;<p>result:</p>&#xA;&#xA;<pre><code>{&#xA;  "took" : 103,&#xA;  "timed_out" : false,&#xA;  "_shards" : {&#xA;    "total" : 5,&#xA;    "successful" : 5,&#xA;    "failed" : 0&#xA;  },&#xA;  "hits" : {&#xA;    "total" : 1,&#xA;    "max_score" : 0.0,&#xA;    "hits" : [ ]&#xA;  },&#xA;  "aggregations" : {&#xA;    "tails" : {&#xA;      "value" : [ [ ], [ ], [ [ 1, 2, 3 ] ], [ ], [ ] ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I was expecting the result to include <code>[1, 2, 2, 3]</code>, but instead it includes <code>[1, 2, 3]</code>. I tried accessing <code>_source</code> in the map script but it said there is no such field.</p>&#xA;
<p>I found the issue in the docs, in <a href="http://www.elastic.co/guide/en/elasticsearch/guide/master/complex-core-fields.html#object-arrays" rel="nofollow">a discussion about a different but related problem</a>. Arrays of inner objects are flattened for indexing. This means that the set of all values of an inner object (or one of its fields) becomes an array on the root document.</p>&#xA;&#xA;<p>Rather than relying on dynamic mapping, which indexes arrays of inner documents with the above effect, one can specify a nested object mapping. Elasticsearch will then not flatten the array of inner documents, but rather store them separately and index them in a way that makes joins "almost as fast" as having them embedded in the same document. Having played with it a little, I found that it makes my use case, which doesn't involve joins, fast as well (in comparison with creating a separate root document for every sub document).</p>&#xA;&#xA;<p>I don't think this solves for preserving the order of the vector, so I will include the index on each nested document.</p>&#xA;&#xA;<p>Example mapping:</p>&#xA;&#xA;<pre><code>curl -XPUT 'http://localhost:9200/arraytestnested' '{&#xA;    "mappings" : {&#xA;        "document" : {&#xA;            "properties" : {&#xA;                "some_property" : {&#xA;                    "type" : "string"&#xA;                },&#xA;                "items": {&#xA;                    "type": "nested",&#xA;                    "properties": {&#xA;                        "index" : {&#xA;                            "type" : "long"&#xA;                        },&#xA;                        "itemvalue" : {&#xA;                            "type" : "long"&#xA;                        }&#xA;                    }&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}'&#xA;</code></pre>&#xA;