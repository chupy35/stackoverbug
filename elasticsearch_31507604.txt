31507604
How to make an elasticsearch query that filters on the maximum value of a field?
<p>I would like to be able to query for text but also retrieve only the results with the maximum value of a certain integer field in my data.  I have read the docs about aggregations and filters and I don't quite see what I am looking for.</p>&#xA;&#xA;<p>For instance, I have some repeating data that gets indexed that is the same except for an integer field - let's call this field <code>lastseen</code>.</p>&#xA;&#xA;<p>So, as an example, given this data put into elasticsearch:</p>&#xA;&#xA;<pre><code>  //  these two the same except "lastseen" field&#xA;  curl -XPOST localhost:9200/myindex/myobject -d '{&#xA;    "field1": "dinner carrot potato broccoli",&#xA;    "field2": "something here",&#xA;    "lastseen": 1000&#xA;  }'&#xA;&#xA;  curl -XPOST localhost:9200/myindex/myobject -d '{&#xA;    "field1": "dinner carrot potato broccoli",&#xA;    "field2": "something here",&#xA;    "somevalue": 100&#xA;  }'&#xA;&#xA;  # and these two the same except "lastseen" field&#xA;  curl -XPOST localhost:9200/myindex/myobject -d '{&#xA;    "field1": "fish chicken something",&#xA;    "field2": "dinner",&#xA;    "lastseen": 2000&#xA;  }'&#xA;&#xA;  curl -XPOST localhost:9200/myindex/myobject -d '{&#xA;    "field1": "fish chicken something",&#xA;    "field2": "dinner",&#xA;    "lastseen": 200&#xA;  }'&#xA;</code></pre>&#xA;&#xA;<p>If I query for <code>"dinner"</code></p>&#xA;&#xA;<pre><code>  curl -XPOST localhost:9200/myindex -d '{  &#xA;   "query": {&#xA;        "query_string": {&#xA;            "query": "dinner"&#xA;        }&#xA;    }&#xA;    }'&#xA;</code></pre>&#xA;&#xA;<p>I'll get 4 results back.   I'd like to have a filter such that I only get two results back - only the items with the maximum <code>lastseen</code> field.</p>&#xA;&#xA;<p>This is <strong><em>obviously not right</em></strong>, but hopefully it gives you an idea of what I am after:</p>&#xA;&#xA;<pre><code>{&#xA;    "query": {&#xA;        "query_string": {&#xA;            "query": "dinner"&#xA;        }&#xA;    },&#xA;    "filter": {&#xA;          "max": "lastseen"&#xA;        }&#xA;&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The results would look something like:</p>&#xA;&#xA;<pre><code>"hits": [&#xA;      {&#xA;        ...&#xA;        "_source": {&#xA;          "field1": "dinner carrot potato broccoli",&#xA;          "field2": "something here",&#xA;          "lastseen": 1000&#xA;        }&#xA;      },&#xA;      {&#xA;        ...&#xA;        "_source": {&#xA;          "field1": "fish chicken something",&#xA;          "field2": "dinner",&#xA;          "lastseen": 2000&#xA;        }&#xA;      } &#xA;   ]&#xA;</code></pre>&#xA;&#xA;<p><strong>update 1:</strong>   I tried creating a mapping that excluded <code>lastseen</code> from being indexed.   This did not work.  Still getting all 4 results back.</p>&#xA;&#xA;<pre><code>curl -XPOST localhost:9200/myindex -d '{  &#xA;    "mappings": {&#xA;      "myobject": {&#xA;        "properties": {&#xA;          "lastseen": {&#xA;            "type": "long",&#xA;            "store": "yes",&#xA;            "include_in_all": false&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;}'&#xA;</code></pre>&#xA;&#xA;<p><strong>update 2:</strong>&#xA;I tried a deduplication with the agg scheme <a href="https://stackoverflow.com/questions/25448186/remove-duplicate-documents-from-a-search-in-elasticsearch">listed here,</a> and it did not work, but more importantly, I don't see a way to combine that with a keyword search.</p>&#xA;
<p>Not ideal, but I think it gets you what you need.</p>&#xA;&#xA;<p>Change the mapping of your <code>field1</code> field, assuming this is the one that you use to define "duplicate" documents, like this:</p>&#xA;&#xA;<pre><code>PUT /lastseen&#xA;{&#xA;  "mappings": {&#xA;    "test": {&#xA;      "properties": {&#xA;        "field1": {&#xA;          "type": "string",&#xA;          "fields": {&#xA;            "raw": {&#xA;              "type": "string",&#xA;              "index": "not_analyzed"&#xA;            }&#xA;          }&#xA;        },&#xA;        "field2": {&#xA;          "type": "string"&#xA;        },&#xA;        "lastseen": {&#xA;          "type": "long"&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>meaning, you add a <code>.raw</code> subfield that is <code>not_analyzed</code> which means it will be indexed just the way it is, no analysis and split into terms. This is to make possible the somewhat "duplicate documents spotting".</p>&#xA;&#xA;<p>Then, you need to use a <code>terms</code> aggregation on <code>field1.raw</code> (for duplicates) and a <code>top_hits</code> sub-aggregation to get a single document for each <code>field1</code> value:</p>&#xA;&#xA;<pre><code>GET /lastseen/test/_search&#xA;{&#xA;  "size": 0,&#xA;  "query": {&#xA;    "query_string": {&#xA;      "query": "dinner"&#xA;    }&#xA;  },&#xA;  "aggs": {&#xA;    "field1_unique": {&#xA;      "terms": {&#xA;        "field": "field1.raw",&#xA;        "size": 2&#xA;      },&#xA;      "aggs": {&#xA;        "first_one": {&#xA;          "top_hits": {&#xA;            "size": 1,&#xA;            "sort": [{"lastseen": {"order":"desc"}}]&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Also, that single document returned by <code>top_hits</code> is the one with the highest <code>lastseen</code> (thing made possible by <code>"sort": [{"lastseen": {"order":"desc"}}]</code>).</p>&#xA;&#xA;<p>The results you will get back are these (under <code>aggregations</code> not <code>hits</code>):</p>&#xA;&#xA;<pre><code>   ...&#xA;   "aggregations": {&#xA;      "field1_unique": {&#xA;         "doc_count_error_upper_bound": 0,&#xA;         "sum_other_doc_count": 0,&#xA;         "buckets": [&#xA;            {&#xA;               "key": "dinner carrot potato broccoli",&#xA;               "doc_count": 2,&#xA;               "first_one": {&#xA;                  "hits": {&#xA;                     "total": 2,&#xA;                     "max_score": null,&#xA;                     "hits": [&#xA;                        {&#xA;                           "_index": "lastseen",&#xA;                           "_type": "test",&#xA;                           "_id": "AU60ZObtjKWeJgeyudI-",&#xA;                           "_score": null,&#xA;                           "_source": {&#xA;                              "field1": "dinner carrot potato broccoli",&#xA;                              "field2": "something here",&#xA;                              "lastseen": 1000&#xA;                           },&#xA;                           "sort": [&#xA;                              1000&#xA;                           ]&#xA;                        }&#xA;                     ]&#xA;                  }&#xA;               }&#xA;            },&#xA;            {&#xA;               "key": "fish chicken something",&#xA;               "doc_count": 2,&#xA;               "first_one": {&#xA;                  "hits": {&#xA;                     "total": 2,&#xA;                     "max_score": null,&#xA;                     "hits": [&#xA;                        {&#xA;                           "_index": "lastseen",&#xA;                           "_type": "test",&#xA;                           "_id": "AU60ZObtjKWeJgeyudJA",&#xA;                           "_score": null,&#xA;                           "_source": {&#xA;                              "field1": "fish chicken something",&#xA;                              "field2": "dinner",&#xA;                              "lastseen": 2000&#xA;                           },&#xA;                           "sort": [&#xA;                              2000&#xA;                           ]&#xA;                        }&#xA;                     ]&#xA;                  }&#xA;               }&#xA;            }&#xA;         ]&#xA;      }&#xA;   }&#xA;</code></pre>&#xA;