31553928
elasticsearch copy_to field not behaving as expected with aggregations
<p>I have an index mapping with two string fields, <code>field1</code> and <code>field2</code>, both being declared as copy_to to another field called <code>all_fields</code>.  <code>all_fields</code> is indexed as "not_analyzed".</p>&#xA;&#xA;<p>When I create a bucket aggregation on <code>all_fields</code>, I was expecting distinct buckets with keys of field1 and field2 concatenated together.  Instead, I get separate buckets with keys of field1 and field2 unconcatenated.</p>&#xA;&#xA;<p>Example:&#xA;mapping:</p>&#xA;&#xA;<pre><code>  {&#xA;    "mappings": {&#xA;      "myobject": {&#xA;        "properties": {&#xA;          "field1": {&#xA;            "type": "string",&#xA;            "index": "analyzed",&#xA;            "copy_to": "all_fields"&#xA;          },&#xA;          "field2": {&#xA;            "type": "string",&#xA;            "index": "analyzed",&#xA;            "copy_to": "all_fields"&#xA;          },&#xA;          "all_fields": {&#xA;            "type": "string",&#xA;            "index": "not_analyzed"&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>data in:</p>&#xA;&#xA;<pre><code>  {&#xA;    "field1": "dinner carrot potato broccoli",&#xA;    "field2": "something here",&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>and</p>&#xA;&#xA;<pre><code>  {&#xA;    "field1": "fish chicken something",&#xA;    "field2": "dinner",&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>aggregation:</p>&#xA;&#xA;<pre><code>{&#xA;  "aggs": {&#xA;    "t": {&#xA;      "terms": {&#xA;        "field": "all_fields"&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>results:</p>&#xA;&#xA;<pre><code>...&#xA;"aggregations": {&#xA;    "t": {&#xA;        "doc_count_error_upper_bound": 0,&#xA;        "sum_other_doc_count": 0,&#xA;        "buckets": [&#xA;            {&#xA;                "key": "dinner",&#xA;                "doc_count": 1&#xA;            },&#xA;            {&#xA;                "key": "dinner carrot potato broccoli",&#xA;                "doc_count": 1&#xA;            },&#xA;            {&#xA;                "key": "fish chicken something",&#xA;                "doc_count": 1&#xA;            },&#xA;            {&#xA;                "key": "something here",&#xA;                "doc_count": 1&#xA;            }&#xA;        ]&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I was expecting only 2 buckets, <code>fish chicken somethingdinner</code> and <code>dinner carrot potato broccolisomethinghere</code></p>&#xA;&#xA;<p>What am I doing wrong?</p>&#xA;
<p>What you are looking for is concatenation of two strings. <code>copy_to</code> even if it seems is doing this, it is not. With <code>copy_to</code> you are, conceptually, creating a set of values from both <code>field1</code> and <code>field2</code>, not concatenating them.</p>&#xA;&#xA;<p>For your use case, you have two options:</p>&#xA;&#xA;<ol>&#xA;<li>use <a href="https://www.elastic.co/guide/en/elasticsearch/reference/1.6/mapping-transform.html#mapping-transform" rel="nofollow"><code>_source</code> transformation</a></li>&#xA;<li>perform a script aggregation</li>&#xA;</ol>&#xA;&#xA;<p>I would recommend <code>_source</code> transformation as I think it's more efficient than doing the scripting. Meaning, you pay a little price at indexing time than doing a heavy scripting aggregation.</p>&#xA;&#xA;<p>For <strong><code>_source</code> transformation</strong>:</p>&#xA;&#xA;<pre><code>PUT /lastseen&#xA;{&#xA;  "mappings": {&#xA;    "test": {&#xA;      "transform": {&#xA;        "script": "ctx._source['all_fields'] = ctx._source['field1'] + ' ' + ctx._source['field2']"&#xA;      }, &#xA;      "properties": {&#xA;        "field1": {&#xA;          "type": "string"&#xA;        },&#xA;        "field2": {&#xA;          "type": "string"&#xA;        },&#xA;        "lastseen": {&#xA;          "type": "long"&#xA;        },&#xA;        "all_fields": {&#xA;          "type": "string",&#xA;          "index": "not_analyzed"&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And the query:</p>&#xA;&#xA;<pre><code>GET /lastseen/test/_search&#xA;{&#xA;  "aggs": {&#xA;    "NAME": {&#xA;      "terms": {&#xA;        "field": "all_fields",&#xA;        "size": 10&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>For <strong>script aggregation</strong>, to be easier to do (meaning, using <code>doc['field'].value</code> rather than the more expensive <code>_source.field</code>) add <code>.raw</code> sub-fields to <code>field1</code> and <code>field2</code>:</p>&#xA;&#xA;<pre><code>PUT /lastseen&#xA;{&#xA;  "mappings": {&#xA;    "test": { &#xA;      "properties": {&#xA;        "field1": {&#xA;          "type": "string",&#xA;          "fields": {&#xA;            "raw": {&#xA;              "type": "string",&#xA;              "index": "not_analyzed"&#xA;            }&#xA;          }&#xA;        },&#xA;        "field2": {&#xA;          "type": "string",&#xA;          "fields": {&#xA;            "raw": {&#xA;              "type": "string",&#xA;              "index": "not_analyzed"&#xA;            }&#xA;          }&#xA;        },&#xA;        "lastseen": {&#xA;          "type": "long"&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And the script will use these <code>.raw</code> subfields:</p>&#xA;&#xA;<pre><code>{&#xA;  "aggs": {&#xA;    "NAME": {&#xA;      "terms": {&#xA;        "script": "doc['field1.raw'].value + ' ' + doc['field2.raw'].value", &#xA;        "size": 10,&#xA;        "lang": "groovy"&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Without the <code>.raw</code> sub-fields (which are made on purpose as <code>not_analyzed</code>) you would have needed to do something like this, which is more expensive:</p>&#xA;&#xA;<pre><code>{&#xA;  "aggs": {&#xA;    "NAME": {&#xA;      "terms": {&#xA;        "script": "_source.field1 + ' ' + _source.field2", &#xA;        "size": 10,&#xA;        "lang": "groovy"&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;