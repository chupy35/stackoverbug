33658619
Confused about elasticsearch query
<pre><code>        POST http://localhost:9200/test2/drug?pretty&#xA;        {&#xA;          "title": "I can do this"&#xA;        }&#xA;&#xA;&#xA;        get test2/drug/_search&#xA;        {&#xA;          "query" : {&#xA;            "match": {&#xA;              "title": "cancer"&#xA;            }&#xA;          }&#xA;        }&#xA;</code></pre>&#xA;&#xA;<p>The mappings are:</p>&#xA;&#xA;<pre><code>        {&#xA;           "test2": {&#xA;              "mappings": {&#xA;                 "drug": {&#xA;                    "properties": {&#xA;                       "title": {&#xA;                          "type": "string"&#xA;                       }&#xA;                    }&#xA;                 }&#xA;              }&#xA;           }&#xA;        }&#xA;</code></pre>&#xA;&#xA;<p>Running the above query returns the document. I want to understand what elastic is doing behind the scenes? From looking at the output of the default analyzer it does not tokenize cancer such that it returns "can" so why is a document with the word "can" being returned and what is causing this to be returned? In other words, what other processing is happening to the search query "cancer".</p>&#xA;&#xA;<h2>Updated</h2>&#xA;&#xA;<p>Is there a command I can run on my box that will clear all indexes and everything so I have a clean slate? I ran delete /* which succeeded but still getting a match.</p>&#xA;
<p>I guess that you configured in your index mappings an NGram filter or tokenizer. Let's suppose (I hope you'll confirm my hypothesis) an Edge NGram is configured. You can check it with:</p>&#xA;&#xA;<pre><code>GET test2/_mapping&#xA;</code></pre>&#xA;&#xA;<p>Then the document is tokenized: i,c,ca,can,d,do,t,th,thi,this. As a result, in the index, the token <em>can</em> points to the document <em>I can do this</em></p>&#xA;&#xA;<p>When you're searching <em>cancer</em>, the tokens c,ca,can,canc,cance,cancer are produced by the same analysis chain, and then looked for in the index. As a result your document is found.</p>&#xA;&#xA;<p>With the NGram filter, you often need to configure a different analyzer for search than for indexing, for instance:</p>&#xA;&#xA;<ul>&#xA;<li><code>index_analyzer</code>/<code>analyzer</code>: standard + edge ngram</li>&#xA;<li><code>search_analyzer</code>: stardand along</li>&#xA;</ul>&#xA;&#xA;<p>Then if you search <em>can</em> you'll find documents containing <em>can</em>,<em>cancer</em>,<em>candy</em>... But if you search <em>cancer</em>, you'll only find documents containing <em>cancer</em>,<em>cancerology</em>... and so on.</p>&#xA;
<p>The problem with your test is, if you are using Sense, the <code>get</code> request. In Sense it should be <code>GET</code> (capital letters).</p>&#xA;&#xA;<p>The explanation is related to <code>GET</code> vs. <code>POST</code> http methods.&#xA;Behind the scene Sense actually converts a <code>GET</code> request to a <code>HTTP POST</code> (given that <a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/_empty_search.html#get_vs_post" rel="nofollow">many browsers do not support HTTP GET requests with a request body</a>). This means that, even if you write <code>GET</code>, the actual http request is a <code>POST</code>.</p>&#xA;&#xA;<p>Because Sense has the autocomplete that forces upper case letters for request methods, it uses the same upper case letters when deciding if it's a <code>GET</code> (and not a lowercase <code>get</code>) request together with a request body. If it is, then that request is transformed to a <code>POST</code> one. If it compares the request method and decides is not a GET it sends the request as is, meaning with a <code>get</code> method and with a body. Since the body is ignored, what reaches Elasticsearch will be a <code>test2/drug/_search</code> which is basically a <code>match_all</code>.</p>&#xA;