32880918
How to ignore trailing white-spaces while making an aggregation query in ElasticSearch
<p>I have an aggregate query to make which buckets the city name of a country. The query (which I make in sense) is as below:</p>&#xA;&#xA;<pre><code>GET test/_search&#xA;{&#xA;&#xA;  "query" : {&#xA;"bool" : {&#xA;  "must" : {&#xA;    "match" : {&#xA;      "name.autocomplete" : {&#xA;        "query" : "new yo",&#xA;        "type" : "boolean"&#xA;      }&#xA;    }&#xA;  },&#xA;  "must_not" : {&#xA;    "term" : {&#xA;      "source" : "old"&#xA;    }&#xA;  }&#xA;}&#xA;  },&#xA;  "aggregations" : {&#xA;"city_name" : {&#xA;  "terms" : {&#xA;    "field" : "cityname.raw",&#xA;    "min_doc_count" : 1&#xA;  },&#xA;     "aggregations" : {&#xA;      "country_name" : {&#xA;        "terms" : {&#xA;          "field" : "countryname.raw"&#xA;         }&#xA;       }&#xA;     }&#xA;   }&#xA; }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Now in the documents <code>New York</code>occurs two time one with an extra trailing space. The aggregation result which I get is as below:</p>&#xA;&#xA;<pre><code>{&#xA;     "key": "New York",&#xA;     "doc_count": 1,&#xA;     "city_name": {&#xA;        "doc_count_error_upper_bound": 0,&#xA;        "sum_other_doc_count": 0,&#xA;        "buckets": [&#xA;           {&#xA;              "key": "United States of America",&#xA;              "doc_count": 1&#xA;           }&#xA;        ]&#xA;     }&#xA;  },&#xA;  {&#xA;     "key": "New York ",&#xA;     "doc_count": 1,&#xA;     "city_name": {&#xA;        "doc_count_error_upper_bound": 0,&#xA;        "sum_other_doc_count": 0,&#xA;        "buckets": [&#xA;           {&#xA;              "key": "United States of America",&#xA;              "doc_count": 1&#xA;           }&#xA;        ]&#xA;     }&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>I need the both <code>New York</code> to be treated the same. Is there any way I can query that I get both of them in the same group. Any things which trims the trailing spaces will do I guess. Could not find anything though. Thanks</p>&#xA;
<p>The ideal case is to clean up your fields before indexing your documents. If that's not an option, you can still clean them after the fact using (e.g.) the <a href="https://github.com/yakaz/elasticsearch-action-updatebyquery" rel="nofollow">update-by-query plugin</a>...</p>&#xA;&#xA;<p>Or, but that's a <strong>bit worse performance-wise</strong>, use a <code>terms</code> aggregation with a <code>script</code> instead of a <code>field</code>, like this:</p>&#xA;&#xA;<pre><code>...&#xA;"aggregations" : {&#xA;"city_name" : {&#xA;  "terms" : {&#xA;    "script" : "doc['cityname.raw'].value.trim()",&#xA;    "min_doc_count" : 1&#xA;  },&#xA;     "aggregations" : {&#xA;      "country_name" : {&#xA;        "terms" : {&#xA;          "script" : "doc['countryname.raw'].value.trim()",&#xA;         }&#xA;       }&#xA;     }&#xA;   }&#xA; }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Yet another solution would be to change from <code>not_analyzed</code> to an <code>analyzed</code> string but create a custom analyzer that preserves the token (as <code>not_analyzed</code> does) using the <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-keyword-analyzer.html" rel="nofollow"><code>keyword</code></a> analyzer with a <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-trim-tokenfilter.html" rel="nofollow"><code>trim</code> token filter</a>.</p>&#xA;&#xA;<pre><code>{&#xA;  "settings": {&#xA;    "analysis": {&#xA;      "analyzer": {&#xA;        "trimmer": {&#xA;          "type": "custom",&#xA;          "filter": [ "trim" ],&#xA;          "tokenizer": "keyword"&#xA;        }&#xA;      }&#xA;    }&#xA;  },&#xA;  "mappings": {&#xA;    "test": {&#xA;      "properties": {&#xA;        "cityname": {&#xA;          "type": "string",&#xA;          "analyzer": "trimmer"&#xA;        },&#xA;        "countryname": {&#xA;          "type": "string",&#xA;          "analyzer": "trimmer"&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>If you index <code>cityname: "New York City "</code> the token that is going to be stored will be trimmed to <code>"New York City"</code></p>&#xA;