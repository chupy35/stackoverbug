32679649
Elasticsearch: Search over most frequent matches / terms without TF or IDF adjustment
<p>we are working on a text-based search (via the famous "Type your search here" input box) that computes the score over multiple fields and shows the best results. It's basically a bool query with a mixture of "term" and "match" over many different fields (using fuzzyness, ngram, edge-ngrams and others).</p>&#xA;&#xA;<p>We want the best results (being most "popular") to show up first (thus get the highest score). However the default TF-IDF algorithm of lucene gives us the exact opposite. Image you look for a vendor that exists in 30% of all index entries. It will have a very high IDF and be ranked very low. We just want the exact opposite of that - give us the most frequent first(!).</p>&#xA;&#xA;<p>Trying our best luck with the the "cross-field" query did not work out since we want to combine different query types with "bool".</p>&#xA;&#xA;<p>Now, what we "found out" is that using Okapi BM25 with k1=0 and b=0 almost(?) behaves like a similarity that ignores TF (term frequency) and IDF (inverse document frequency). However we feel unsure if this really is the way to go.</p>&#xA;&#xA;<p>Can you give us some feedback on that, please?</p>&#xA;&#xA;<p>Is this the way to go or for our "problem" is there better waiting to be discovered?</p>&#xA;&#xA;<hr>&#xA;&#xA;<h2>update</h2>&#xA;&#xA;<p>I try to make my question more clear (sorry for any confusion):</p>&#xA;&#xA;<p>Let's say we have an index of cars...</p>&#xA;&#xA;<pre><code>{id: 1, vendor: Opel, model: Astra, engine: 90hp gasoline}&#xA;{id: 2, vendor: Opel, model: Astra, engine: 100hp diesel}&#xA;{id: 3, vendor: Opel, model: Astra, engine: 120hp gasoline}&#xA;{id: 4, vendor: Chevrolet, model: Astro, engine: 120hp gasoline}&#xA;</code></pre>&#xA;&#xA;<p>We do a "full text search" over the current user input <strong>"astr"</strong></p>&#xA;&#xA;<p>All fields (vendor, model + engine) are analyzed using the "edge ngram" analyzer {min:2, max:10} to support prefix search.</p>&#xA;&#xA;<p>the input "astr" would match all entries #1 - #4 (it's the beginning of "Astra" and "Astro", so all entries would contain an edge ngram match)</p>&#xA;&#xA;<p>the IDF of "Astr<strong>a</strong>" is log(4/3) ~= 0,287</p>&#xA;&#xA;<p>the IDF of "Astr<strong>o</strong>" is log(4/1) ~= 1,386</p>&#xA;&#xA;<p>so #4 would be ranked better due to the IDF</p>&#xA;&#xA;<p>However, we want the exact opposite: The "more frequent" (= "more popular") car should be ranked higher.</p>&#xA;&#xA;<p>note: the "cross fields" query will not be sufficient since we combine several <strong>different</strong> queries (fuzzy, edge ngram, raw) into <strong>one large bool query</strong></p>&#xA;
<p>If you want to use document frequency to <em>boost</em> your results, try rolling your own <a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/script-score.html" rel="nofollow">script_score</a> function inside a <code>function_score</code> clause.  You can access document frequency of a term inside your scoring function via <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-advanced-scripting.html#_term_statistics_2" rel="nofollow">term statistics</a>.</p>&#xA;&#xA;<p>You may discover that an unintended consequence of this approach is that common/generic terms like <code>Corp</code>, <code>Solutions</code>, <code>Computer</code>, <code>Inc</code>, etc will have an outsize influence on your score if you don't explicitly scrub them out as stopwords.</p>&#xA;
<p>It sounds like you want to follow this general process:</p>&#xA;&#xA;<ol>&#xA;<li>Run a complex, custom search query.</li>&#xA;<li>Examine the results to determine how much each vendor dominates within the result set</li>&#xA;<li>Reorder the results, boosting cars with more dominant vendors.</li>&#xA;</ol>&#xA;&#xA;<hr>&#xA;&#xA;<p><strong>Solution 1</strong> (most flexible, least performant)</p>&#xA;&#xA;<p>You can get the information for #2 using a <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.0/search-aggregations-bucket-terms-aggregation.html" rel="nofollow">terms aggregation</a> on the vendor field.</p>&#xA;&#xA;<p>Then you can re-query with the necessary derived boosts (costing a second round-trip)</p>&#xA;&#xA;<p><strong>OR</strong></p>&#xA;&#xA;<p><strong>Solution 2</strong> (least flexible, most performant)</p>&#xA;&#xA;<p>If you're content to let <code>vendor popularity</code> trump <code>_score</code>, you can do the following:</p>&#xA;&#xA;<ul>&#xA;<li>Run a zero-result query (your current fuzzy match query)</li>&#xA;<li>... with a <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.0/search-aggregations-bucket-terms-aggregation.html" rel="nofollow">Terms</a> aggregation on <code>vendor</code></li>&#xA;<li>... ... with a <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.0/search-aggregations-metrics-top-hits-aggregation.html" rel="nofollow">Top Hits</a> sub-aggregation sorted by <code>_score</code> descending.</li>&#xA;</ul>&#xA;&#xA;<p>Then your <code>[astr]</code> query results within the aggregation result will look like this:</p>&#xA;&#xA;<pre><code>[Opel bucket]&#xA;Astra 90hp&#xA;Astra 100hp diesel&#xA;Astra 120hp&#xA;Ascona 144hp (if you had fuzziness 2)&#xA;Ascona 230hp (if you had fuzziness 2)&#xA;&#xA;[Chevrolet bucket]&#xA;Astro 120hp&#xA;Alero 140hp (if you had fuzziness 2)&#xA;</code></pre>&#xA;