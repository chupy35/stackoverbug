31392952
Get every Nth result in Elasticsearch
<p>I have this large set of data and I want a sample that I can use in a graph. For this I don't need all of the data, I need every Nth item.</p>&#xA;&#xA;<p>For instance if I have 4000 results, and I only need 800 results, I want to be able to get every 5th result.</p>&#xA;&#xA;<p>So some like: get, skip, skip, skip, skip, get, skip, skip, skip,..</p>&#xA;&#xA;<p>I was wondering if such a thing is possible in Elasticsearch?</p>&#xA;
<p>One way you could do it is with <a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/random-scoring.html" rel="nofollow">random scoring</a>. It won't give you precisely every nth item according to a rigid ordering, but if you can relax that requirement this trick should do nicely.</p>&#xA;&#xA;<p>To test it I set up a simple index (I mapped <code>"doc_id"</code> to <code>"_id"</code> just so the documents would have some contents, so that part isn't required, in case that's not obvious):</p>&#xA;&#xA;<pre><code>PUT /test_index&#xA;{&#xA;   "mappings": {&#xA;      "doc": {&#xA;         "_id": {&#xA;            "path": "doc_id"&#xA;         }&#xA;      }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Then I indexed ten simple documents:</p>&#xA;&#xA;<pre><code>POST /test_index/doc/_bulk&#xA;{"index":{}}&#xA;{"doc_id":1}&#xA;{"index":{}}&#xA;{"doc_id":2}&#xA;{"index":{}}&#xA;{"doc_id":3}&#xA;{"index":{}}&#xA;{"doc_id":4}&#xA;{"index":{}}&#xA;{"doc_id":5}&#xA;{"index":{}}&#xA;{"doc_id":6}&#xA;{"index":{}}&#xA;{"doc_id":7}&#xA;{"index":{}}&#xA;{"doc_id":8}&#xA;{"index":{}}&#xA;{"doc_id":9}&#xA;{"index":{}}&#xA;{"doc_id":10}&#xA;</code></pre>&#xA;&#xA;<p>Now I can pull back three random documents like this:</p>&#xA;&#xA;<pre><code>POST /test_index/_search&#xA;{&#xA;   "size": 3,&#xA;   "query": {&#xA;      "function_score": {&#xA;         "functions": [&#xA;            {&#xA;               "random_score": {&#xA;                  "seed": "some seed"&#xA;               }&#xA;            }&#xA;         ]&#xA;      }&#xA;   }&#xA;}&#xA;...&#xA;{&#xA;   "took": 1,&#xA;   "timed_out": false,&#xA;   "_shards": {&#xA;      "total": 1,&#xA;      "successful": 1,&#xA;      "failed": 0&#xA;   },&#xA;   "hits": {&#xA;      "total": 10,&#xA;      "max_score": 0.93746644,&#xA;      "hits": [&#xA;         {&#xA;            "_index": "test_index",&#xA;            "_type": "doc",&#xA;            "_id": "1",&#xA;            "_score": 0.93746644,&#xA;            "_source": {&#xA;               "doc_id": 1&#xA;            }&#xA;         },&#xA;         {&#xA;            "_index": "test_index",&#xA;            "_type": "doc",&#xA;            "_id": "10",&#xA;            "_score": 0.926947,&#xA;            "_source": {&#xA;               "doc_id": 10&#xA;            }&#xA;         },&#xA;         {&#xA;            "_index": "test_index",&#xA;            "_type": "doc",&#xA;            "_id": "5",&#xA;            "_score": 0.79400194,&#xA;            "_source": {&#xA;               "doc_id": 5&#xA;            }&#xA;         }&#xA;      ]&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Or a different random three like this:</p>&#xA;&#xA;<pre><code>POST /test_index/_search&#xA;{&#xA;   "size": 3,&#xA;   "query": {&#xA;      "function_score": {&#xA;         "functions": [&#xA;            {&#xA;               "random_score": {&#xA;                  "seed": "some other seed"&#xA;               }&#xA;            }&#xA;         ]&#xA;      }&#xA;   }&#xA;}&#xA;...&#xA;{&#xA;   "took": 1,&#xA;   "timed_out": false,&#xA;   "_shards": {&#xA;      "total": 1,&#xA;      "successful": 1,&#xA;      "failed": 0&#xA;   },&#xA;   "hits": {&#xA;      "total": 10,&#xA;      "max_score": 0.817295,&#xA;      "hits": [&#xA;         {&#xA;            "_index": "test_index",&#xA;            "_type": "doc",&#xA;            "_id": "4",&#xA;            "_score": 0.817295,&#xA;            "_source": {&#xA;               "doc_id": 4&#xA;            }&#xA;         },&#xA;         {&#xA;            "_index": "test_index",&#xA;            "_type": "doc",&#xA;            "_id": "8",&#xA;            "_score": 0.469319,&#xA;            "_source": {&#xA;               "doc_id": 8&#xA;            }&#xA;         },&#xA;         {&#xA;            "_index": "test_index",&#xA;            "_type": "doc",&#xA;            "_id": "3",&#xA;            "_score": 0.4374538,&#xA;            "_source": {&#xA;               "doc_id": 3&#xA;            }&#xA;         }&#xA;      ]&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Hopefully it's clear how to generalize this method to what you need. Just take out however many documents you want, in however many chunks make it performant.</p>&#xA;&#xA;<p>Here is all the code I used to test:</p>&#xA;&#xA;<p><a href="http://sense.qbox.io/gist/a02d4da458365915f5e9cf6ea80546d2dfabc75d" rel="nofollow">http://sense.qbox.io/gist/a02d4da458365915f5e9cf6ea80546d2dfabc75d</a></p>&#xA;&#xA;<p><strong>EDIT:</strong> Actually now that I think about it, you could also use <a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/script-score.html" rel="nofollow">scripted scoring</a> to get precisely every nth item, if you set it up right. Maybe something like, </p>&#xA;&#xA;<pre><code>POST /test_index/_search&#xA;{&#xA;   "size": 3,&#xA;   "query": {&#xA;      "function_score": {&#xA;         "functions": [&#xA;            {&#xA;               "script_score": {&#xA;                  "script": "if(doc['doc_id'].value % 3 == 0){ return 1 }; return 0;"&#xA;               }&#xA;            }&#xA;         ]&#xA;      }&#xA;   }&#xA;}&#xA;...&#xA;{&#xA;   "took": 13,&#xA;   "timed_out": false,&#xA;   "_shards": {&#xA;      "total": 1,&#xA;      "successful": 1,&#xA;      "failed": 0&#xA;   },&#xA;   "hits": {&#xA;      "total": 10,&#xA;      "max_score": 1,&#xA;      "hits": [&#xA;         {&#xA;            "_index": "test_index",&#xA;            "_type": "doc",&#xA;            "_id": "3",&#xA;            "_score": 1,&#xA;            "_source": {&#xA;               "doc_id": 3&#xA;            }&#xA;         },&#xA;         {&#xA;            "_index": "test_index",&#xA;            "_type": "doc",&#xA;            "_id": "6",&#xA;            "_score": 1,&#xA;            "_source": {&#xA;               "doc_id": 6&#xA;            }&#xA;         },&#xA;         {&#xA;            "_index": "test_index",&#xA;            "_type": "doc",&#xA;            "_id": "9",&#xA;            "_score": 1,&#xA;            "_source": {&#xA;               "doc_id": 9&#xA;            }&#xA;         }&#xA;      ]&#xA;   }&#xA;}&#xA;</code></pre>&#xA;
<p>You're better off using a scripted <code>filter</code>. Otherwise you're needlessly using the score. Filters are just like queries, but they don't use scoring.</p>&#xA;&#xA;<pre><code>POST /test_index/_search&#xA;{&#xA;  "query": {&#xA;    "filtered": {&#xA;      "filter": {&#xA;        "script": {&#xA;          "script": "doc['unique_counter'].value % n == 0",&#xA;          "params" : {&#xA;            "n" : 5&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>You're also better off not using dynamic scripting in real world usage.</p>&#xA;&#xA;<p>That said, you probably want to take a look at aggregations for graphing analytical information about your data rather than taking an arbitrary sample.</p>&#xA;