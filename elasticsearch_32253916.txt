32253916
How to properly initialize Elasticsearch for queries?
<p>I wrote a program that inserts an element, then it searches all elements in the store. Thus, it finds one more element every time the program runs. I’d expect to be able to comment out the insert and still run the program, just finding the stuff that was already inserted. Whenever I do though, I get an exception “Failed to execute phase [query_fetch], all shards failed”. Any ideas?</p>&#xA;&#xA;<p>Hypothesis: inserting the element does some sort of implicit initialization on my node. However, I’m looking through the ES source, and I can’t figure out what that would be.</p>&#xA;&#xA;<pre><code>try (Node node = NodeBuilder.nodeBuilder().clusterName("tesssst").build().start()) {&#xA;    try (Client client = node.client()) {&#xA;&#xA;        //insert an entry; if this part is removed, the program crashes&#xA;        client.prepareIndex("movies", "movie", UUID.randomUUID().toString()).setSource(&#xA;            "{\"title\": \"Lawrence of Arabia\",\"director\": \"David Lean\",\"year\": 1962,\"genres\":"&#xA;            + " [\"Adventure\", \"Biography\", \"Drama\"]}").execute().actionGet();&#xA;&#xA;        //search all entries&#xA;        System.out.println("***************");&#xA;        SearchResponse response = client.prepareSearch("movies")&#xA;            .setTypes("movie")&#xA;            .setSearchType(SearchType.QUERY_AND_FETCH)&#xA;            .setFrom(0).setSize(60).setExplain(true)&#xA;            .execute()&#xA;            .actionGet();&#xA;        SearchHit[] results = response.getHits().getHits();&#xA;        System.out.println("Current results: " + results.length);&#xA;        for (SearchHit hit : results) {&#xA;            System.out.println("------------------------------");&#xA;            Map&lt;String, Object&gt; result = hit.getSource();&#xA;            System.out.println(result);&#xA;        }&#xA;        System.out.println("***************");&#xA;&#xA;        client.close();&#xA;    }&#xA;    node.close();&#xA;}&#xA;</code></pre>&#xA;
<p>The problem was that Elasticsearch didn't have enough time to startup, but the initial insert gave it enough time. Simply adding an appropriate wait fixes it:</p>&#xA;&#xA;<pre><code>final ClusterHealthRequest clusterHealthRequest = new ClusterHealthRequest("movies")&#xA;        .timeout(TimeValue.timeValueSeconds(60)).waitForGreenStatus();&#xA;final ClusterHealthResponse clusterHealth = client.admin().cluster()&#xA;        .health(clusterHealthRequest).actionGet();&#xA;if (clusterHealth.isTimedOut()) {&#xA;    System.out.println("ElasticSearch cluster health timed out");&#xA;} else {&#xA;    System.out.println("ElasticSearch cluster health: Status "&#xA;           + clusterHealth.getStatus().name() + "; " + clusterHealth.getNumberOfNodes()&#xA;           + " nodes; " + clusterHealth.getActiveShards() + " active shards.");&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>(if your standards are lower, you can save time with <code>waitForYellowStatus</code>)</p>&#xA;