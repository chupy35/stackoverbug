33315690
How to store attributes for real-estate properties
<p>I am very new to Elasticsearch. I have some documents which can have such attributes:</p>&#xA;&#xA;<ol>&#xA;<li>No of bathroom</li>&#xA;<li>Bedroom</li>&#xA;<li>Zip</li>&#xA;<li>Address</li>&#xA;</ol>&#xA;&#xA;<p>I want to store those attributes in a single field so that user can search with "3 beds at 97778(zip)".</p>&#xA;&#xA;<p>I have tried with a single array field such that [3 beds,2 baths, 97778],[7 beds,3 baths, 97778] with stopword analyzer so that I can restrict "at", "in" this kind of words, but it seems that this is not the right way to do because for the second doc score is higher than the first doc.</p>&#xA;&#xA;<p>Also, I have a synonym analyzer because if a user search with "3 bd"  it should return "3 beds". </p>&#xA;&#xA;<p>Now my question is what is the best way to store attributes? Here is my some dummy documents.</p>&#xA;&#xA;<pre><code>{&#xA;    "Beds" : 3,&#xA;    "Bath" : 2,&#xA;    "Zip" : 97778,&#xA;    "Attributes" : ["3 beds","2 baths", "97778"]&#xA;},&#xA;{&#xA;    "Beds" : 7,&#xA;    "Bath" : 3,&#xA;    "Zip" : 97778,&#xA;    "Attributes" : [7 beds,3 baths, 97778]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>should I change this schema to </p>&#xA;&#xA;<pre><code>{&#xA;    "Beds" : 7,&#xA;    "Bath" : 3,&#xA;    "Zip" : 97778,&#xA;    "Attributes" : [bed : "7", bath : "3", zip : "97778"]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>If so, then how can I put synonym analyzer?</p>&#xA;
<p>First structure seems to look better for me. I've made a simple index with these properties on my local machine using Marvel:</p>&#xA;&#xA;<pre><code>PUT /test&#xA;{&#xA;  "settings": {&#xA;    "analysis": {&#xA;      "filter": {&#xA;        "my_stop": {&#xA;          "type":       "stop",&#xA;          "stopwords":  "_english_" &#xA;        },&#xA;        "my_possessive_stemmer": {&#xA;          "type":       "stemmer",&#xA;          "language":   "possessive_english"&#xA;        },&#xA;        "my_synonym": {&#xA;          "type": "synonym",&#xA;          "synonyms": [&#xA;            "bd =&gt; bed",&#xA;            "bt, baths, bth =&gt; bath"]&#xA;        },&#xA;        "my_shingle": {&#xA;          "type" : "shingle",&#xA;          "min_shingle_size": 2,&#xA;          "max_shingle_size": 3,&#xA;          "output_unigrams": false,&#xA;          "output_unigrams_if_no_shingles": true&#xA;        }&#xA;      },&#xA;      "analyzer": {&#xA;        "my_english": {&#xA;          "tokenizer":  "standard",&#xA;          "filter": [&#xA;            "my_possessive_stemmer",&#xA;            "lowercase",&#xA;            "my_stop",&#xA;            "my_synonym",&#xA;            "kstem",&#xA;            "my_shingle"&#xA;          ]&#xA;        }&#xA;      }&#xA;    }&#xA;  },&#xA;  "mappings": {&#xA;    "documents": {&#xA;      "properties": {&#xA;        "Beds": {&#xA;          "type": "integer"&#xA;        },&#xA;        "Baths": {&#xA;          "type": "integer"&#xA;        },&#xA;        "Zip": {&#xA;          "type": "integer"&#xA;        },&#xA;        "Attributes": {&#xA;          "type": "string",&#xA;          "analyzer": "my_english"&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This is pretty much standard english analyzer (I only excluded stemmer filter, which in my opinion is too aggressive and replaced it with kstem) and of course, your synonyms. I also added shingle filter, which produces token combinations, which is what we're looking for!</p>&#xA;&#xA;<p>I've added your test data. Please note that I've doubled keyword <code>zip</code> in case users would like to look for zip 97778 or 97778 zip, which is likely possible.</p>&#xA;&#xA;<pre><code>PUT /test/documents/1&#xA;{&#xA;  "Beds": 3,&#xA;  "Bath": 2,&#xA;  "Zip": 97778,&#xA;  "Attributes": ["3 beds", "2 baths", "zip 97778 zip"]&#xA;}&#xA;&#xA;PUT /test/documents/2&#xA;{&#xA;  "Beds": 7,&#xA;  "Bath": 3,&#xA;  "Zip": 97778,&#xA;  "Attributes": ["7 beds", "3 baths", "zip 97778 zip"]&#xA;}&#xA;&#xA;POST /test/documents/3&#xA;{&#xA;  "Attributes" : ["8310 prairie rose place", "md", "baltimore", "21208", "us", "3 bd", "3 bth", "1 pbh", "1 hbh", "cooktop", "dishwasher", "dryer", "garbage disposer", "ice maker", "microwave", "oven", "oven - double", "refrigerator", "washer", "appliances", "contemporary architecture", "ceiling fan(s)", "colling system", "brick", "basement", "forced air", "heating system", "3 floors", "2 parkings", "garage", "asphalt roof"]&#xA;}&#xA;&#xA;POST /test/documents/4&#xA;{&#xA;  "Attributes" : ["8 winners circle", "md", "owings mills", "21117", "us", "2 bd", "1 bth", "dishwasher", "dryer", "garbage disposer", "microwave", "range", "refrigerator", "washer", "appliances", "traditional architecture", "new traditional architecture", "central a/c", "colling system", "vinyl siding", "heat pump", "heating system", "1 floors", "assigned", "unassigned", "unknown roof"]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>So that's the a simple match query:</p>&#xA;&#xA;<pre><code>POST /test/documents/_search&#xA;{&#xA;  "query": {&#xA;    "match": {&#xA;      "Attributes": {&#xA;        "query": "3 beds at 97778(zip)"&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And it brings desired data as per request:</p>&#xA;&#xA;<pre><code>{&#xA;  "_index" : "test",&#xA;  "_type" : "documents",&#xA;  "_id" : "1",&#xA;  "_score" : 0.020668881,&#xA;  "_source" : {&#xA;    "Beds" : 3,&#xA;    "Bath" : 2,&#xA;    "Zip" : 97778,&#xA;    "Attributes" : [&#xA;      "3 beds",&#xA;      "2 baths",&#xA;      "zip 97778 zip"&#xA;    ]&#xA;  }&#xA;},&#xA;{&#xA;  "_index" : "test",&#xA;  "_type" : "documents",&#xA;  "_id" : "2",&#xA;  "_score" : 0.004767749,&#xA;  "_source" : {&#xA;    "Beds" : 7,&#xA;    "Bath" : 3,&#xA;    "Zip" : 97778,&#xA;    "Attributes" : [&#xA;      "7 beds",&#xA;      "3 baths",&#xA;      "zip 97778 zip"&#xA;    ]&#xA;  }&#xA;},&#xA;{&#xA;  "_index" : "test",&#xA;  "_type" : "documents",&#xA;  "_id" : "3",&#xA;  "_score" : 0.0014899216,&#xA;  "_source" : {&#xA;    "Attributes" : [&#xA;      "8310 prairie rose place",&#xA;      "md",&#xA;      "baltimore",&#xA;      "21208",&#xA;      "us",&#xA;      "3 bd",&#xA;      "3 bth",&#xA;      "1 pbh",&#xA;      "1 hbh",&#xA;      "cooktop",&#xA;      "dishwasher",&#xA;      "dryer",&#xA;      "garbage disposer",&#xA;      "ice maker",&#xA;      "microwave",&#xA;      "oven",&#xA;      "oven - double",&#xA;      "refrigerator",&#xA;      "washer",&#xA;      "appliances",&#xA;      "contemporary architecture",&#xA;      "ceiling fan(s)",&#xA;      "colling system",&#xA;      "brick",&#xA;      "basement",&#xA;      "forced air",&#xA;      "heating system",&#xA;      "3 floors",&#xA;      "2 parkings",&#xA;      "garage",&#xA;      "asphalt roof"&#xA;    ]&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Now when I'm querying this:</p>&#xA;&#xA;<pre><code>POST /test/documents/_search&#xA;{&#xA;  "query": {&#xA;    "match": {&#xA;      "Attributes": {&#xA;        "query": "2 bd and 1 bth at md"&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>It returns this result, which is correct:</p>&#xA;&#xA;<pre><code>{&#xA;  "_index" : "test",&#xA;  "_type" : "documents",&#xA;  "_id" : "4",&#xA;  "_score" : 0.0032357208,&#xA;  "_source" : {&#xA;    "Attributes" : [&#xA;      "8 winners circle",&#xA;      "md",&#xA;      "owings mills",&#xA;      "21117",&#xA;      "us",&#xA;      "2 bd",&#xA;      "1 bth",&#xA;      "dishwasher",&#xA;      "dryer",&#xA;      "garbage disposer",&#xA;      "microwave",&#xA;      "range",&#xA;      "refrigerator",&#xA;      "washer",&#xA;      "appliances",&#xA;      "traditional architecture",&#xA;      "new traditional architecture",&#xA;      "central a/c",&#xA;      "colling system",&#xA;      "vinyl siding",&#xA;      "heat pump",&#xA;      "heating system",&#xA;      "1 floors",&#xA;      "assigned",&#xA;      "unassigned",&#xA;      "unknown roof"&#xA;    ]&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>You said that your results always score with 1. This indicates that your query doesn't run correct. I can guess that issue is that you're running against <code>attributes</code> field instead of <code>Attributes</code>, Elasticsearch is very case sensitive, unfortunately.</p>&#xA;&#xA;<p>And from the comments, you said you're using <a href="https://www.elastic.co/guide/en/elasticsearch/reference/1.7/query-dsl-term-query.html" rel="nofollow">term query</a> - it's not right to use it against text data as it's always looking for EXACT term matches. <strong>Always</strong> use <a href="https://www.elastic.co/guide/en/elasticsearch/reference/1.7/query-dsl-match-query.html" rel="nofollow">match query</a> when you're doing search on text data.</p>&#xA;&#xA;<p>Let me know if this helps.</p>&#xA;