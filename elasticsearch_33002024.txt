33002024
ElasticSearch: Aggregations of URLs keeps splitting field
<p>I'm trying to write an elasticsearch query that groups all blogs with the same blog domain (wordpress.com, blog.com, etc). This is how my query looks like:</p>&#xA;&#xA;<pre><code>{&#xA;    "engagements": [&#xA;        "blogs"&#xA;    ],&#xA;    "query": {&#xA;        "query": {&#xA;            "filtered": {&#xA;                "query": {&#xA;                    "match_all": {}&#xA;                },&#xA;                "filter": {&#xA;                    "bool": {&#xA;                        "must": [&#xA;                            {&#xA;                                "range": {&#xA;                                    "weight": {&#xA;                                        "gte": 120,&#xA;                                        "lte": 150&#xA;                                    }&#xA;                                }&#xA;                            }&#xA;                        ]&#xA;                    }&#xA;                }&#xA;            }&#xA;        },&#xA;        "facets": {&#xA;            "my_facet": {&#xA;                "terms": {&#xA;                    "field": "blog_domain" &lt;-------------------------------------&#xA;                }&#xA;            }&#xA;        }&#xA;    },&#xA;    "api": "_search"&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>However, it's returning this:</p>&#xA;&#xA;<pre><code>{&#xA;    "took": 5,&#xA;    "timed_out": false,&#xA;    "_shards": {&#xA;        "total": 5,&#xA;        "successful": 5,&#xA;        "failed": 0&#xA;    },&#xA;    "hits": {&#xA;        "total": 3,&#xA;        "max_score": 1,&#xA;        "hits": [&#xA;            ...&#xA;        ]&#xA;    },&#xA;    "facets": {&#xA;        "my_facet": {&#xA;            "_type": "terms",&#xA;            "missing": 0,&#xA;            "total": 21,&#xA;            "other": 3,&#xA;            "terms": [&#xA;                {&#xA;                    "term": "http",&#xA;                    "count": 3&#xA;                },&#xA;                {&#xA;                    "term": "noblepig.com",&#xA;                    "count": 2&#xA;                },&#xA;                {&#xA;                    "term": "hawaiian",&#xA;                    "count": 2&#xA;                },&#xA;                {&#xA;                    "term": "dream",&#xA;                    "count": 2&#xA;                },&#xA;                {&#xA;                    "term": "dessert",&#xA;                    "count": 2&#xA;                },&#xA;                {&#xA;                    "term": "2015",&#xA;                    "count": 2&#xA;                },&#xA;                {&#xA;                    "term": "05",&#xA;                    "count": 2&#xA;                },&#xA;                {&#xA;                    "term": "www.bt",&#xA;                    "count": 1&#xA;                },&#xA;                {&#xA;                    "term": "photos",&#xA;                    "count": 1&#xA;                },&#xA;                {&#xA;                    "term": "images.net",&#xA;                    "count": 1&#xA;                }&#xA;            ]&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This isn't what I want.&#xA;Right now my database has three records: </p>&#xA;&#xA;<pre><code>"http://www.bt-images.net/8-cute-photos-cats/", &#xA;&#xA;"http://noblepig.com/2015/05/hawaiian-dream-dessert/", &#xA;&#xA;"http://noblepig.com/2015/05/hawaiian-dream-dessert/"&#xA;</code></pre>&#xA;&#xA;<p>I want it to return something like:</p>&#xA;&#xA;<pre><code>    "facets": {&#xA;        "my_facet": {&#xA;            "_type": "terms",&#xA;            "missing": 0,&#xA;            "total": 21,&#xA;            "other": 3,&#xA;            "terms": [&#xA;                {&#xA;                    "term": "http://noblepig.com/2015/05/hawaiian-dream-dessert/",&#xA;                    "count": 2&#xA;                },&#xA;                {&#xA;                    "term": "http://www.bt-images.net/8-cute-photos-cats/",&#xA;                    "count": 1&#xA;                },&#xA;</code></pre>&#xA;&#xA;<p>How would I do this? I looked it up and saw people recommending <code>mappings</code> but I don't know where to put that in this query and my table has 100 million records so it's too late to do that. If you have suggestions, could you please paste the whole query?</p>&#xA;&#xA;<p>The same happens when I use <code>aggs</code>:</p>&#xA;&#xA;<pre><code>{&#xA;    "engagements": [&#xA;        "blogs"&#xA;    ],&#xA;    "query": {&#xA;        "query": {&#xA;            "filtered": {&#xA;                "query": {&#xA;                    "match_all": {}&#xA;                },&#xA;                "filter": {&#xA;                    "bool": {&#xA;                        "must": [&#xA;                            {&#xA;                                "range": {&#xA;                                    "weight": {&#xA;                                        "gte": 13,&#xA;                                        "lte": 75&#xA;                                    }&#xA;                                }&#xA;                            }&#xA;                        ]&#xA;                    }&#xA;                }&#xA;            }&#xA;        },&#xA;        "aggs": {&#xA;            "blah": {&#xA;                "terms": {&#xA;                    "field": "blog_domain"&#xA;                }&#xA;            }&#xA;        }&#xA;    },&#xA;    "api": "_search"&#xA;}&#xA;</code></pre>&#xA;
<p>The <strong>right</strong> way to do this is to have a different mapping for that field. You can change the mapping on the way by adding a sub-field to <code>blog_domain</code> but you <strong>cannot change the documents that were already indexed</strong>. The mapping change will take effect for the new documents.</p>&#xA;&#xA;<p>Just for the sake of mentioning this, your <code>blog_domain</code> should look like this:</p>&#xA;&#xA;<pre><code>    "blog_domain": {&#xA;      "type": "string",&#xA;      "fields": {&#xA;        "notAnalyzed": {&#xA;          "type": "string",&#xA;          "index": "not_analyzed"&#xA;        }&#xA;      }&#xA;    }&#xA;</code></pre>&#xA;&#xA;<p>meaning it should have a sub-field (in my sample is called <code>notAnalyzed</code>) and in your aggregation you should use <code>blog_domain.notAnalyzed</code>.</p>&#xA;&#xA;<p>But, if you don't want to or can't make this change, there is a way but I believe it's slower: using scripted aggregation. Something like this:</p>&#xA;&#xA;<pre><code>{&#xA;  "aggs": {&#xA;    "blah": {&#xA;      "terms": {&#xA;        "script": "_source.blog_domain", &#xA;        "size": 10&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And you need to <a href="https://www.elastic.co/guide/en/elasticsearch/reference/1.7/modules-scripting.html#enable-dynamic-scripting" rel="nofollow">enable dynamic scripting</a>, if you don't have it enabled.</p>&#xA;
<p>If you use Elasticsearch 5.x, you could the mapping below</p>&#xA;&#xA;<pre><code>PUT your_index&#xA;{&#xA;   "mappings": {&#xA;     "your_type": { &#xA;       "properties": {&#xA;         "blog_domain": {&#xA;           "type": "keyword",&#xA;           "index": "not_analyzed"&#xA;         }        &#xA;       }&#xA;     }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;