33129310
Elasticsearch Store 'searchable' list
<p>I have access to a Neo4J Graph Database that stores a list of people and the relationships between them (friend). I am looking to implement a "search friends list" function that performs a search within a given users friends list. I am concerned about performance so I am looking to implement this search using Elasticsearch; however i am not sure how to index the user data from Neo4j in Elasticsearch to facilitate the above-mentioned query. A typical use-case is "for user x find his friends whose name starts with "Mik". The SearchAPI is build on SpringWeb using Elasticsearch JavaAPI.</p>&#xA;&#xA;<p><strong>EDIT 1:</strong></p>&#xA;&#xA;<p>What I am asking is different to <a href="https://stackoverflow.com/questions/28323323/examples-about-integration-of-elasticsearch-with-neo4j">this</a> in that I know how to use Elasticsearch rivers and other tools to index data. My question seeks to establish the best approach to implement functionality such as "search_friends_list". For example, do I use the unique user identifier of each user as a type (something like <code>..:9200/users/[username]</code>) and index each one of a given users friends to that index and type? This way if I want to search through a list of user JackSparrow's friends I'd perform something akin to <code>..:9200/users/JackSparrow/_search?q=search_term</code>. This example smells though and would probably lead to serious performance degradation when the number of user's in my system grows. Thats where I need assistance and advice. What approaches exist to implement a solution for such?</p>&#xA;&#xA;<p><strong>EDIT 2: removed Neo4J tags, provided more info</strong></p>&#xA;&#xA;<p><strong>Mapping</strong></p>&#xA;&#xA;<pre><code>{&#xA;    "people": {&#xA;        "mappings": {&#xA;            "friends": {&#xA;                "properties": {&#xA;                    "firstname": {&#xA;                        "type": "string"&#xA;                    },&#xA;                    "friends": {&#xA;                        "type": "string"&#xA;                    },&#xA;                    "fullname": {&#xA;                        "type": "string"&#xA;                    },&#xA;                    "id": {&#xA;                        "type": "long"&#xA;                    },&#xA;                    "lastname": {&#xA;                        "type": "string"&#xA;                    },&#xA;                    "username": {&#xA;                        "type": "string"&#xA;                    },&#xA;                    "userid": {&#xA;                        "type": "string"&#xA;                    }&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>Data</strong></p>&#xA;&#xA;<pre><code>{&#xA;    "_index": "people",&#xA;    "_type": "friends",&#xA;    "_id": "24482ba5-06fa-2f58-2560-4b8fa5e3d1a7",&#xA;    "_score": 11.5473,&#xA;    "_source": {&#xA;        "firstname": "Carl",&#xA;        "id": 4735,&#xA;        "fullname": "Carl Platt",&#xA;        "userid": "24482ba5-06fa-2f58-2560-4b8fa5e3d1a7",&#xA;        "friends": [&#xA;            "8248f90b-3c30-b60a-d64f-ced55304fcb0",&#xA;            "8b4a0960-f792-87d5-be4d-17a53963c29e",&#xA;            "904a4d6f-c7ce-8ae3-edf2-e0ac6bc69885",&#xA;            "934e0e4b-2b20-b7b1-c092-1eb22e3e92bd",&#xA;            "954e1500-7f74-468e-b611-cd35382d9aa6",&#xA;            "994cacfc-3a76-c77a-adec-b50804933490",&#xA;            "a942b4b7-cdcc-8653-ef73-a6000dbd418c",&#xA;            ...&#xA;</code></pre>&#xA;&#xA;<p><strong>Query</strong></p>&#xA;&#xA;<pre><code>{&#xA;  "query": {&#xA;    "filtered": {&#xA;      "query": {&#xA;        "query_string": {&#xA;          "default_field": "firstname",&#xA;          "query": "Amu*"          &#xA;        }&#xA;      },&#xA;      "filter": {&#xA;        "terms": {&#xA;          "friends": {&#xA;            "index": "people",&#xA;            "type": "friends",&#xA;            "id": "24482ba5-06fa-2f58-2560-4b8fa5e3d1a7",            &#xA;            "path": "userid"&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;
<p>In the official documentation, there's a similar example around Twitter users and their tweets in order to illustrate the <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-filter.html#_terms_lookup_twitter_example" rel="nofollow"><code>terms</code> lookup mechanism</a>, which could well do what you're looking for.</p>&#xA;&#xA;<p>The idea would be to have one <code>users</code> index containing <code>user</code> documents. Each document representing a user would have an array property containing the ids of his friends. Let's create a simple version of the <code>users</code> index:</p>&#xA;&#xA;<pre><code>curl -XPUT localhost:9200/users -d '{&#xA;  "mappings": {&#xA;    "user": {&#xA;      "properties": {&#xA;        "id": {&#xA;          "type": "integer"&#xA;        },&#xA;        "name": {&#xA;          "type": "string"&#xA;        },&#xA;        "friends": {&#xA;          "type": "integer"&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}'&#xA;</code></pre>&#xA;&#xA;<p>Now let's index some sample data, where user 1 is friend with all other users but 4 (Mike):</p>&#xA;&#xA;<pre><code>curl -XPOST localhost:9200/users/user/_bulk -d '&#xA;{"index":{"_id":1}}&#xA;{"id": 1, "name": "John", "friends": [2,3,5]}&#xA;{"index":{"_id":2}}&#xA;{"id": 2, "name": "Mikil", "friends": [1,3]}&#xA;{"index":{"_id":3}}&#xA;{"id": 3, "name": "Maxim", "friends": [1,2]}&#xA;{"index":{"_id":4}}&#xA;{"id": 4, "name": "Mike", "friends": [5]}&#xA;{"index":{"_id":5}}&#xA;{"id": 5, "name": "Philip", "friends": [1,4]}&#xA;'&#xA;</code></pre>&#xA;&#xA;<p>So I'm restating one of your typical use-cases, i.e. <strong>"for user x find his friends whose name starts with "Mik"</strong>. With such a set-up this can be accomplished with the following query:</p>&#xA;&#xA;<pre><code>curl -XPOST localhost:9200/users/user/_search -d '{&#xA;  "query": {&#xA;    "filtered": {&#xA;      "query": {&#xA;        "query_string": {&#xA;          "default_field": "name",&#xA;          "query": "mik*"         &lt;--- only friends whose name starts with "mik" &#xA;        }&#xA;      },&#xA;      "filter": {&#xA;        "terms": {&#xA;          "friends": {&#xA;            "index": "users",&#xA;            "type": "user",&#xA;            "id": "1",            &lt;--- only friends of user 1&#xA;            "path": "id"&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}'&#xA;</code></pre>&#xA;&#xA;<p>The results will only contain user 2 (Mikil) and not 4 (Mike). QED.</p>&#xA;