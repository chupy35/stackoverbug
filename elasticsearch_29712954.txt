29712954
Should I include spaces in fuzzy query fields?
<p>I have this data:</p>&#xA;&#xA;<pre><code>name:&#xA;  first: 'John'&#xA;  last: 'Smith'&#xA;</code></pre>&#xA;&#xA;<p>When I store it in ES, AFAICT it's better to make it one field. However, should this one field be:</p>&#xA;&#xA;<pre><code>name: 'John Smith'&#xA;</code></pre>&#xA;&#xA;<p>or</p>&#xA;&#xA;<pre><code>name: 'JohnSmith'&#xA;</code></pre>&#xA;&#xA;<p>?</p>&#xA;&#xA;<p>I'm thinking that the query should be:</p>&#xA;&#xA;<pre><code>query: &#xA;  match: &#xA;    name: &#xA;      query: searchTerm&#xA;      fuzziness: 'AUTO'&#xA;      operator: 'and'&#xA;</code></pre>&#xA;&#xA;<p>Example search terms are what people might type in a search box, like </p>&#xA;&#xA;<pre><code>John&#xA;Jhon Smi&#xA;J Smith&#xA;Smith&#xA;</code></pre>&#xA;&#xA;<p>etc.</p>&#xA;
<p>You will probably want a combination of <a href="http://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-ngram-tokenizer.html" rel="noreferrer">ngrams</a> and a fuzzy match query. I wrote a blog post about ngrams for Qbox if you need a primer: <a href="http://blog.qbox.io/an-introduction-to-ngrams-in-elasticsearch" rel="noreferrer">http://blog.qbox.io/an-introduction-to-ngrams-in-elasticsearch</a>. I'll swipe the starter code at the end of the post to illustrate what I mean here.</p>&#xA;&#xA;<p>Also, I don't think it matters much whether you use two fields for <code>name</code>, or just one. If you have some other reason you want two fields, you may want to use the <a href="http://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-all-field.html" rel="noreferrer"><code>_all</code> field</a> in your query. For simplicity I'll just use a single field here.</p>&#xA;&#xA;<p>Here is a mapping that will get you the partial-word matching you want, assuming you only care about tokens that start at the beginning of words (otherwise use <a href="http://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-ngram-tokenizer.html" rel="noreferrer">ngrams</a> instead of <a href="http://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-edgengram-tokenizer.html" rel="noreferrer">edge ngrams</a>). There are lots of nuances to using ngrams, so I'll refer to you the documentation and my primer if you want more info.</p>&#xA;&#xA;<pre><code>PUT /test_index&#xA;{&#xA;   "settings": {&#xA;      "number_of_shards": 1,&#xA;      "analysis": {&#xA;         "filter": {&#xA;            "edge_ngram_filter": {&#xA;               "type": "edge_ngram",&#xA;               "min_gram": 1,&#xA;               "max_gram": 10&#xA;            }&#xA;         },&#xA;         "analyzer": {&#xA;            "edge_ngram_analyzer": {&#xA;               "type": "custom",&#xA;               "tokenizer": "standard",&#xA;               "filter": [&#xA;                  "lowercase",&#xA;                  "edge_ngram_filter"&#xA;               ]&#xA;            }&#xA;         }&#xA;      }&#xA;   },&#xA;   "mappings": {&#xA;      "doc": {&#xA;         "properties": {&#xA;            "name": {&#xA;               "type": "string",&#xA;               "index_analyzer": "edge_ngram_analyzer",&#xA;               "search_analyzer": "standard"&#xA;            }&#xA;         }&#xA;      }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>One thing to note here, in particular: <code>"min_gram": 1</code>. This means that single-character tokens will be generated from indexed values. This will cast a pretty wide net when you query (lots of words begin with "j", for example), so you may get some unexpected results, especially when combined with fuzziness. But this is needed to get your "J Smith" query to work right. So there are some trade-offs to consider.</p>&#xA;&#xA;<p>For illustration, I indexed four documents:</p>&#xA;&#xA;<pre><code>PUT /test_index/doc/_bulk&#xA;{"index":{"_id":1}}&#xA;{"name":"John Hancock"}&#xA;{"index":{"_id":2}}&#xA;{"name":"John Smith"}&#xA;{"index":{"_id":3}}&#xA;{"name":"Bob Smith"}&#xA;{"index":{"_id":4}}&#xA;{"name":"Bob Jones"}&#xA;</code></pre>&#xA;&#xA;<p>Your query mostly works, with a couple of caveats.</p>&#xA;&#xA;<pre><code>POST /test_index/_search&#xA;{&#xA;    "query": {&#xA;        "match": {&#xA;           "name": {&#xA;               "query": "John",&#xA;               "fuzziness": "AUTO",&#xA;               "operator": "and"&#xA;           }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>this query returns three documents, because of ngrams plus fuzziness:</p>&#xA;&#xA;<pre><code>{&#xA;   "took": 3,&#xA;   "timed_out": false,&#xA;   "_shards": {&#xA;      "total": 1,&#xA;      "successful": 1,&#xA;      "failed": 0&#xA;   },&#xA;   "hits": {&#xA;      "total": 3,&#xA;      "max_score": 0.90169895,&#xA;      "hits": [&#xA;         {&#xA;            "_index": "test_index",&#xA;            "_type": "doc",&#xA;            "_id": "1",&#xA;            "_score": 0.90169895,&#xA;            "_source": {&#xA;               "name": "John Hancock"&#xA;            }&#xA;         },&#xA;         {&#xA;            "_index": "test_index",&#xA;            "_type": "doc",&#xA;            "_id": "2",&#xA;            "_score": 0.90169895,&#xA;            "_source": {&#xA;               "name": "John Smith"&#xA;            }&#xA;         },&#xA;         {&#xA;            "_index": "test_index",&#xA;            "_type": "doc",&#xA;            "_id": "4",&#xA;            "_score": 0.6235822,&#xA;            "_source": {&#xA;               "name": "Bob Jones"&#xA;            }&#xA;         }&#xA;      ]&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>That may not be what you want. Also, <code>"AUTO"</code> doesn't work with the "Jhon Smi" query, because "Jhon" is an edit distance of 2 from "John", and "AUTO" uses an edit distance of 1 for strings of 3-5 characters (see the <a href="http://www.elastic.co/guide/en/elasticsearch/guide/current/fuzziness.html" rel="noreferrer">docs</a> for more info). So I have to use this query instead:</p>&#xA;&#xA;<pre><code>POST /test_index/_search&#xA;{&#xA;    "query": {&#xA;        "match": {&#xA;           "name": {&#xA;               "query": "Jhon Smi",&#xA;               "fuzziness": 2,&#xA;               "operator": "and"&#xA;           }&#xA;        }&#xA;    }&#xA;}&#xA;...&#xA;{&#xA;   "took": 17,&#xA;   "timed_out": false,&#xA;   "_shards": {&#xA;      "total": 1,&#xA;      "successful": 1,&#xA;      "failed": 0&#xA;   },&#xA;   "hits": {&#xA;      "total": 1,&#xA;      "max_score": 1.4219328,&#xA;      "hits": [&#xA;         {&#xA;            "_index": "test_index",&#xA;            "_type": "doc",&#xA;            "_id": "2",&#xA;            "_score": 1.4219328,&#xA;            "_source": {&#xA;               "name": "John Smith"&#xA;            }&#xA;         }&#xA;      ]&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The other queries work as expected. So this solution isn't perfect, but it will get you close.</p>&#xA;&#xA;<p>Here's all the code I used:</p>&#xA;&#xA;<p><a href="http://sense.qbox.io/gist/ba5a6741090fd40c1bb20f5d36f3513b4b55ac77" rel="noreferrer">http://sense.qbox.io/gist/ba5a6741090fd40c1bb20f5d36f3513b4b55ac77</a></p>&#xA;