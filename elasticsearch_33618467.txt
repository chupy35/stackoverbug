33618467
How to add properties from a root object in a nested object for sorting?
<p>A simplified example of the kind of document in our index:</p>&#xA;&#xA;<pre><code>{ &#xA;  "organisation" : { &#xA;    "code" : "01310"&#xA;  },&#xA;  "publications" : [ &#xA;    { &#xA;      "dateEnd" : 1393801200000,&#xA;      "dateStart" : 1391986800000,&#xA;      "code" : "PUB.02"&#xA;    },&#xA;    { &#xA;      "dateEnd" : 1401055200000,&#xA;      "dateStart" : 1397512800000,&#xA;      "code" : "PUB.06"&#xA;    }&#xA;  ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Note that <code>publications</code> are mapped as <code>nested</code> objects because we need to filter based on a combination of the <code>dateEnd</code>, <code>dateStart</code> and <code>publicationStatus</code> properties.</p>&#xA;&#xA;<p>The <code>PUB.02</code> status code is special. It states: 'this publication period is valid if the current user is a member of the organisation'.</p>&#xA;&#xA;<p>I have a problem when I want to sort on 'most recent':</p>&#xA;&#xA;<pre><code>{&#xA;  "sort": {&#xA;    "publications.dateStart" : {&#xA;      "mode" :  "min",&#xA;      "order" : "desc",&#xA;      "nested_filter" : {&#xA;        "or" : [&#xA;          {&#xA;            "and" : [&#xA;              { "term" : { "organisation.code" : "01310" } },&#xA;              { "term" : { "publications.code" : "PUB.02" } }&#xA;            ]&#xA;          },&#xA;          { "term" : { "publications.code" : "PUB.06" } }&#xA;        ]&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>No error is given, but the <code>PUB.02</code> entry is ignored. I tried to use <code>copy_to</code> in my mapping to copy the value of <code>organisation.code</code> to the <code>nested</code> object, but that did not help.</p>&#xA;&#xA;<ul>&#xA;<li>Is there a way to reach for the parent document inside a nested sort?</li>&#xA;<li>Alternatively, is there a way to copy data from parent to the nested document?</li>&#xA;</ul>&#xA;&#xA;<p>I am currently using version 1.7 of Elasticsearch without the ability to use scripts. Upgrading to a newer version could be done if that would help the situation.</p>&#xA;&#xA;<p>This gist shows that the sort is performed on the <code>PUB.06</code> publications: <a href="https://gist.github.com/EECOLOR/2db9a1ec9d6d5c791ea6" rel="nofollow">https://gist.github.com/EECOLOR/2db9a1ec9d6d5c791ea6</a></p>&#xA;
<p>Although the documentation does not explictly mention it does look like we cannot access the parent field in a nested filter context.</p>&#xA;&#xA;<p>Also I wasn't able to use <code>copy_to</code> to add data from root/parent field to nested document. I would suggest asking in <a href="https://discuss.elastic.co/" rel="nofollow">elasticsearch discuss thread</a> you would have more luck about the reasons for this.</p>&#xA;&#xA;<p>Before some trigger happy bloke downvotes this answer I would like to add that the query and intended results that was  desired in the OP using <code>sort</code> could be achieved using <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html" rel="nofollow">function_score</a> work-around.</p>&#xA;&#xA;<p>One implementation to achieve this is as follows </p>&#xA;&#xA;<p>1) start of with a should query </p>&#xA;&#xA;<p>2) In the first should clause </p>&#xA;&#xA;<pre><code> a) use filtered query  to filter documents with the `organisation.code : 01310`&#xA;&#xA;  b) then score these documents  based on max value of reciprocal of nested document **dateStart** with terms **PUB2.0 PUB6.0**&#xA;</code></pre>&#xA;&#xA;<p>3) In the second should clause </p>&#xA;&#xA;<pre><code> a) use filtered query  to filter documents with those with `organisation.code not equal to  01310`&#xA;&#xA;  b) like before score these documents  based on max value of reciprocal of  nested document **dateStart** with term **PUB6.0** only&#xA;</code></pre>&#xA;&#xA;<p>Example Query:</p>&#xA;&#xA;<pre><code>POST /testindex/testtype/_search &#xA;{&#xA;   "query": {&#xA;      "bool": {&#xA;         "should": [&#xA;            {&#xA;               "filtered": {&#xA;                  "filter": {&#xA;                     "term": {&#xA;                        "organisation.code": "01310"&#xA;                     }&#xA;                  },&#xA;                  "query": {&#xA;                     "nested": {&#xA;                        "path": "publications",&#xA;                        "query": {&#xA;                           "filtered": {&#xA;                              "query": {&#xA;                                 "function_score": {&#xA;                                    "functions": [&#xA;                                       {&#xA;                                          "field_value_factor": {&#xA;                                             "field": "publications.dateStart",&#xA;                                             "modifier": "reciprocal"&#xA;                                          }&#xA;                                       }&#xA;                                    ],&#xA;                                    "boost_mode": "replace",&#xA;                                    "score_mode": "max"&#xA;                                 }&#xA;                              },&#xA;                              "filter": {&#xA;                                 "terms": {&#xA;                                    "publications.code": [&#xA;                                       "PUB.02",&#xA;                                       "PUB.06"&#xA;                                    ]&#xA;                                 }&#xA;                              }&#xA;                           }&#xA;                        },&#xA;                        "score_mode": "max"&#xA;                     }&#xA;                  }&#xA;               }&#xA;            },&#xA;            {&#xA;               "filtered": {&#xA;                  "filter": {&#xA;                     "not": {&#xA;                        "term": {&#xA;                           "organisation.code": "01310"&#xA;                        }&#xA;                     }&#xA;                  },&#xA;                  "query": {&#xA;                     "nested": {&#xA;                        "path": "publications",&#xA;                        "query": {&#xA;                           "filtered": {&#xA;                              "query": {&#xA;                                 "function_score": {&#xA;                                    "functions": [&#xA;                                       {&#xA;                                          "field_value_factor": {&#xA;                                             "field": "publications.dateStart",&#xA;                                             "modifier": "reciprocal"&#xA;                                          }&#xA;                                       }&#xA;                                    ],&#xA;                                    "boost_mode": "replace",&#xA;                                    "score_mode": "max"&#xA;                                 }&#xA;                              },&#xA;                              "filter": {&#xA;                                 "terms": {&#xA;                                    "publications.code": [&#xA;                                       "PUB.06"&#xA;                                    ]&#xA;                                 }&#xA;                              }&#xA;                           }&#xA;                        },&#xA;                        "score_mode": "max"&#xA;                     }&#xA;                  }&#xA;               }&#xA;            }&#xA;         ]&#xA;      }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I'm first to admit it is not the most readable and if there is a way to 'copy_to' nested it would be much more ideal  </p>&#xA;&#xA;<p>If not simulating <code>copy_to</code> by injecting data in the source by client before indexing would be more simpler and flexible. </p>&#xA;&#xA;<p>But the above is an example of how it could be done using function scores.</p>&#xA;