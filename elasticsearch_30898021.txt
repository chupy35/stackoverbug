30898021
Filtered search in complex structure
<p>I have a list of people with this kind of schema : </p>&#xA;&#xA;<pre class="lang-js prettyprint-override"><code>{&#xA;    "id": 125018,&#xA;    "nom": "GALLA",&#xA;    "prenom": "patrick",&#xA;    "departement": 91,&#xA;    "comptes": [&#xA;        {"id": 83557, "type": "facebook", "login": "patrick"},&#xA;        {"id": 83558, "type": "google", "login": "patrick"},&#xA;        {"id": 83558, "type": "twitter", "login": "patrick"}&#xA;    ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I would search people who have <code>departement</code> equals to <em>91</em> and boost the scoring of those who have a <em>google</em> account.</p>&#xA;&#xA;<p>I tried this kind of request : </p>&#xA;&#xA;<pre class="lang-js prettyprint-override"><code>{&#xA;"query": {&#xA;    "bool": {&#xA;        "must": [&#xA;            { "term": { "departement": "91" } }&#xA;        ],&#xA;        "should" : [&#xA;            { "match" : { "comptes.1.type" : "google" } }&#xA;        ],&#xA;        "minimum_should_match" : 1,&#xA;        "boost" : 1.0&#xA;    }&#xA;}&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>But <code>comptes.1.type</code> or <code>comptes.*.type</code> is not doing a good match.</p>&#xA;&#xA;<p>Do you have a better query syntax that find people who have a <em>google</em> account?</p>&#xA;&#xA;<p>EDIT : </p>&#xA;&#xA;<p>Yes, thank you niko : your search query works well ! </p>&#xA;&#xA;<p>The mistake was in my input query. We need to be careful about the PHP <strong>json_encode</strong> function that do not gave me the right input syntax. So search doesn't work as well...</p>&#xA;&#xA;<p>PHP json_encode input syntax :</p>&#xA;&#xA;<pre class="lang-js prettyprint-override"><code>{&#xA;    "id": 125018,&#xA;    "nom": "GALLA",&#xA;    "prenom": "patrick",&#xA;    "departement": 91,&#xA;    "comptes": {&#xA;        83557 : {"id": 83557, "type": "facebook", "login": "patrick"},&#xA;        83558 : {"id": 83558, "type": "google", "login": "patrick"},&#xA;        83559 : {"id": 83559, "type": "twitter", "login": "patrick"}&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>good inpout syntax : </p>&#xA;&#xA;<pre class="lang-js prettyprint-override"><code>{&#xA;    "id": 125018,&#xA;    "nom": "GALLA",&#xA;    "prenom": "patrick",&#xA;    "departement": 91,&#xA;    "comptes": [&#xA;        {"id": 83557, "type": "facebook", "login": "patrick"},&#xA;        {"id": 83558, "type": "google", "login": "patrick"},&#xA;        {"id": 83559, "type": "twitter", "login": "patrick"}&#xA;    ]&#xA;}&#xA;</code></pre>&#xA;
<p>Even in a mutivalued field, you specify a relationship by a <code>parent.child</code>  notation e.g <code>comptes.type</code> in your case. </p>&#xA;&#xA;<p>To test this, you can try to find the users with a Google account:</p>&#xA;&#xA;<pre class="lang-js prettyprint-override"><code>"query": {&#xA;    "bool": {&#xA;        "must": [&#xA;            { "term": { "departement": 91 } },&#xA;            { "term": { "comptes.type": "google" } }&#xA;        ]&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>A demo to play with <a href="https://www.found.no/play/gist/90a9290e806226e2d41f" rel="nofollow">https://www.found.no/play/gist/90a9290e806226e2d41f</a></p>&#xA;&#xA;<p>and so your boosted query could look like</p>&#xA;&#xA;<pre class="lang-js prettyprint-override"><code>"query": {&#xA;    "bool": {&#xA;        "must": [&#xA;            { "term": { "departement": 91 } }&#xA;        ],&#xA;        "should" : [&#xA;            { "term" : { // you're looking for an exact term &#xA;                "comptes.type" : {&#xA;                    "value": "google",&#xA;                    "boost": 2.0 &#xA;                }&#xA;            }}&#xA;        ]&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><a href="https://www.found.no/play/gist/ac979072963875ba79f9" rel="nofollow">https://www.found.no/play/gist/ac979072963875ba79f9</a></p>&#xA;&#xA;<p>The <code>boost</code> attribute is not necessary as Elastic will automatically boost the matching items but that can come in handy.</p>&#xA;