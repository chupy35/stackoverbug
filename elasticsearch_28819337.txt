28819337
Elasticsearch return unique values for a field
<p>I am trying to build an Elasticsearch query that will return only unique values for a particular field.</p>&#xA;&#xA;<p><strong>I do not want to return all the values for that field nor count them.</strong></p>&#xA;&#xA;<p>For example, if there are 50 different values currently contained by the field, and I do a search to return only 20 hits (size=20). I want each of the 20 results to have a unique result for that field, but I don't care about the 30 other values not represented in the result.</p>&#xA;&#xA;<p>For example with the following search (pseudo code - not checked):</p>&#xA;&#xA;<pre><code>{&#xA;from:0,&#xA;size:20,&#xA;query: {&#xA;    bool: {&#xA;        must: {&#xA;            range: { field1: {gte: 50}},&#xA;            term: {field2: 'salt'},&#xA;            unique?: {field3},&#xA;        },&#xA;        mustnot: {&#xA;            match: { field4: 'pepper'},&#xA;        },&#xA;    }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Third line in <em>must</em>, I want to return only unique values for <em>field3</em> but I don't want to return all of them or count them.</p>&#xA;
<p>You should be able to do this pretty easily with a <a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html" rel="nofollow">terms aggregation</a>.</p>&#xA;&#xA;<p>Here's an example. I defined a simple index, containing a field that has <code>"index": "not_analyzed"</code> so we can get the full text of each field as a unique value, rather than terms generated from tokenizing it, etc. </p>&#xA;&#xA;<pre><code>DELETE /test_index&#xA;&#xA;PUT /test_index&#xA;{&#xA;   "settings": {&#xA;      "number_of_shards": 1&#xA;   },&#xA;   "mappings": {&#xA;      "doc": {&#xA;         "properties": {&#xA;            "title": {&#xA;               "type": "string",&#xA;               "index": "not_analyzed"&#xA;            }&#xA;         }&#xA;      }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Then I add a few docs with the <a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/docs-bulk.html" rel="nofollow"><code>bulk</code> API</a>. </p>&#xA;&#xA;<pre><code>POST /test_index/_bulk&#xA;{"index":{"_index":"test_index","_type":"doc","_id":1}}&#xA;{"title":"first doc"}&#xA;{"index":{"_index":"test_index","_type":"doc","_id":2}}&#xA;{"title":"second doc"}&#xA;{"index":{"_index":"test_index","_type":"doc","_id":3}}&#xA;{"title":"third doc"}&#xA;{"index":{"_index":"test_index","_type":"doc","_id":4}}&#xA;{"title":"third doc"}&#xA;</code></pre>&#xA;&#xA;<p>Now we can run our terms aggregation:</p>&#xA;&#xA;<pre><code>POST /test_index/_search?search_type=count&#xA;{&#xA;   "aggs": {&#xA;      "unique_vals": {&#xA;         "terms": {&#xA;            "field": "title"&#xA;         }&#xA;      }&#xA;   }&#xA;}&#xA;...&#xA;{&#xA;   "took": 1,&#xA;   "timed_out": false,&#xA;   "_shards": {&#xA;      "total": 1,&#xA;      "successful": 1,&#xA;      "failed": 0&#xA;   },&#xA;   "hits": {&#xA;      "total": 4,&#xA;      "max_score": 0,&#xA;      "hits": []&#xA;   },&#xA;   "aggregations": {&#xA;      "unique_vals": {&#xA;         "buckets": [&#xA;            {&#xA;               "key": "third doc",&#xA;               "doc_count": 2&#xA;            },&#xA;            {&#xA;               "key": "first doc",&#xA;               "doc_count": 1&#xA;            },&#xA;            {&#xA;               "key": "second doc",&#xA;               "doc_count": 1&#xA;            }&#xA;         ]&#xA;      }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;
<p>I'm very surprised a <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-filter-aggregation.html" rel="nofollow noreferrer">filter aggregation</a> hasn't been suggested. It goes back all the way to ES version 1.3. </p>&#xA;&#xA;<p>The filter aggregation is similar to a regular filter query but can instead be nested into an aggregation chain to filter out counts of documents that don't meet a particular criteria and give you sub-aggregation results based only on the documents that meet the criteria of the query.</p>&#xA;&#xA;<p>First, we'll put our mapping.</p>&#xA;&#xA;<pre><code>curl --request PUT \&#xA;  --url http://localhost:9200/items \&#xA;  --header 'content-type: application/json' \&#xA;  --data '{&#xA;  "mappings": {&#xA;    "item": { &#xA;      "properties": { &#xA;        "field1" :    { "type": "integer"  },&#xA;        "field2" :    { "type": "keyword"  },&#xA;        "field3" :    { "type": "keyword"  },&#xA;        "field4" :    { "type": "keyword"  }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;'&#xA;</code></pre>&#xA;&#xA;<p>Then let's load some data.</p>&#xA;&#xA;<pre><code>curl --request PUT \&#xA;  --url http://localhost:9200/items/_bulk \&#xA;  --header 'content-type: application/json' \&#xA;  --data '{"index":{"_index":"items","_type":"item","_id":1}}&#xA;{"field1":50, "field2":["salt", "vinegar"], "field3":["garlic", "onion"], "field4":"paprika"}&#xA;{"index":{"_index":"items","_type":"item","_id":2}}&#xA;{"field1":40, "field2":["salt", "pepper"], "field3":["onion"]}&#xA;{"index":{"_index":"items","_type":"item","_id":3}}&#xA;{"field1":100, "field2":["salt", "vinegar"], "field3":["garlic", "chives"], "field4":"pepper"}&#xA;{"index":{"_index":"items","_type":"item","_id":4}}&#xA;{"field1":90, "field2":["vinegar"], "field3":["chives", "garlic"]}&#xA;{"index":{"_index":"items","_type":"item","_id":5}}&#xA;{"field1":900, "field2":["salt", "vinegar"], "field3":["garlic", "chives"], "field4":"paprika"}&#xA;'&#xA;</code></pre>&#xA;&#xA;<p>Notice, that only the documents with id's 1 and 5 will pass the criteria and so we will be left to aggregate on these two field3 arrays and four values total. <code>["garlic", "chives"], ["garlic", "onion"]</code>. Also notice that field3 can be an array or single value in the data but I'm making them arrays to illustrate how the counts will work.</p>&#xA;&#xA;<pre><code>curl --request POST \&#xA;  --url http://localhost:9200/items/item/_search \&#xA;  --header 'content-type: application/json' \&#xA;  --data '{&#xA;    "size": 0,&#xA;    "aggregations": {&#xA;        "top_filter_agg" : {&#xA;            "filter" : { &#xA;                "bool": { &#xA;                    "must":[&#xA;                        {&#xA;                            "range" : { "field1" : { "gte":50} }&#xA;                        },&#xA;                        {&#xA;                            "term" : { "field2" : "salt" }&#xA;                        }&#xA;                    ],&#xA;                    "must_not":[&#xA;                        {&#xA;                            "term" : { "field4" : "pepper" }&#xA;                        }&#xA;                    ]&#xA;                } &#xA;&#xA;            },&#xA;            "aggs" : {&#xA;                "field3_terms_agg" : { "terms" : { "field" : "field3" } }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;'&#xA;</code></pre>&#xA;&#xA;<p>After running the conjuncted filter/terms aggregation. We only have a count of 4 terms on field3 and three unique terms altogether.</p>&#xA;&#xA;<pre><code>{&#xA;    "took": 46,&#xA;    "timed_out": false,&#xA;    "_shards": {&#xA;        "total": 5,&#xA;        "successful": 5,&#xA;        "skipped": 0,&#xA;        "failed": 0&#xA;    },&#xA;    "hits": {&#xA;        "total": 5,&#xA;        "max_score": 0.0,&#xA;        "hits": []&#xA;    },&#xA;    "aggregations": {&#xA;        "top_filter_agg": {&#xA;            "doc_count": 2,&#xA;            "field3_terms_agg": {&#xA;                "doc_count_error_upper_bound": 0,&#xA;                "sum_other_doc_count": 0,&#xA;                "buckets": [&#xA;                    {&#xA;                        "key": "garlic",&#xA;                        "doc_count": 2&#xA;                    },&#xA;                    {&#xA;                        "key": "chives",&#xA;                        "doc_count": 1&#xA;                    },&#xA;                    {&#xA;                        "key": "onion",&#xA;                        "doc_count": 1&#xA;                    }&#xA;                ]&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;