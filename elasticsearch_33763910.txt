33763910
Elastic Search Querying/filtering nested arrays
<p>I have stored below type of nested data on my index test_agg in ES. </p>&#xA;&#xA;<pre><code>{&#xA;  "Date": "2015-10-21",&#xA;  "Domain": "abc.com",&#xA;  "Processed_at": "10/23/2015 9:47",&#xA;  "Events": [&#xA;    {&#xA;      "Name": "visit",&#xA;      "Count": "188",&#xA;      "Value_Aggregations": [&#xA;        {&#xA;          "Value": "red",&#xA;          "Count": "100"&#xA;        }&#xA;      ]&#xA;    },&#xA;    {&#xA;      "Name": "order_created",&#xA;      "Count": "159",&#xA;      "Value_Aggregations": [&#xA;        {&#xA;          "Value": "$125",&#xA;          "Count": "50"&#xA;        }&#xA;      ]&#xA;   },&#xA; ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>mapping of the nested item is</p>&#xA;&#xA;<pre><code>curl -XPOST localhost:9200/test_agg/nested_evt/_mapping -d '{&#xA;"nested_evt":{&#xA;"properties":{&#xA;   "Events": {&#xA;       "type": "nested"&#xA;    }&#xA;   }&#xA;  }&#xA;}'&#xA;</code></pre>&#xA;&#xA;<p>I am trying to get "Events.Count" and "Events.Value_Aggregations.Count" where Events.Name='Visit' using the below query</p>&#xA;&#xA;<pre><code>{&#xA; "fields" : ["Events.Count","Events.Value_Aggregations.Count"]&#xA;  "query": {&#xA;     "filtered": {&#xA;        "query": {&#xA;            "match": { "Domain": "abc.com" }&#xA;        },&#xA;        "filter": {&#xA;            "nested": {&#xA;                "path": "Events",&#xA;                "query": {&#xA;                     "match": { "Events.Name": "visit" }&#xA;                },&#xA;              }&#xA;          }&#xA;      }&#xA;   }&#xA; }&#xA;</code></pre>&#xA;&#xA;<p>instead of resulting single value </p>&#xA;&#xA;<blockquote>&#xA;  <p>Events.Count=[188]  Events.Value_Aggregations.Count=[100]</p>&#xA;</blockquote>&#xA;&#xA;<p>it gives</p>&#xA;&#xA;<blockquote>&#xA;  <p>Events.Count=[188,159]  Events.Value_Aggregations.Count=[100,50]</p>&#xA;</blockquote>&#xA;&#xA;<p>what is the exact query structure to get my desired output?</p>&#xA;
<p>So the problem here is that the <code>nested</code> filter you are applying selects <em>parent</em> documents based on attributes of the <em>nested child</em> documents. So ES finds the parent document that matches your query (based on the document's nested children). Then, instead of returning the entire document, since you have specified <code>"fields"</code> it picks out only those fields that you have asked for. Those fields happen to be nested fields, and since the parent document has two nested children, it finds two values each for the fields you specified and returns them. To my knowledge there is no way to return the child documents instead, at least with a <code>nested</code> architecture.</p>&#xA;&#xA;<p>One solution to this problem would be to use the <a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/parent-child.html" rel="nofollow">parent/child relationship</a> instead, then you could use a <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-has-parent-query.html" rel="nofollow"><code>has_parent</code></a> query in combination with the other filters, against the child type to get what you want. That would probably be a cleaner way to do this, as long as the schema architecture doesn't conflict with your other needs.</p>&#xA;&#xA;<p>However, there is a way to do sort of what you are asking, with your current schema, with a <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-nested-aggregation.html" rel="nofollow">nested aggregation</a> combined with a <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-filter-aggregation.html" rel="nofollow">filter aggregation</a>. It's kind of involved (and slightly ambiguous in this case; see explanation below), but here's the query:</p>&#xA;&#xA;<pre><code>POST /test_index/_search&#xA;{&#xA;   "size": 0,&#xA;   "query": {&#xA;      "filtered": {&#xA;         "query": {&#xA;            "match": {&#xA;               "Domain": "abc.com"&#xA;            }&#xA;         },&#xA;         "filter": {&#xA;            "nested": {&#xA;               "path": "Events",&#xA;               "query": {&#xA;                  "match": {&#xA;                     "Events.Name": "visit"&#xA;                  }&#xA;               }&#xA;            }&#xA;         }&#xA;      }&#xA;   },&#xA;   "aggs": {&#xA;      "nested_events": {&#xA;         "nested": {&#xA;            "path": "Events"&#xA;         },&#xA;         "aggs": {&#xA;            "filtered_events": {&#xA;               "filter": {&#xA;                  "term": {&#xA;                     "Events.Name": "visit"&#xA;                  }&#xA;               },&#xA;               "aggs": {&#xA;                  "events_count_terms": {&#xA;                     "terms": {&#xA;                        "field": "Events.Count"&#xA;                     }&#xA;                  },&#xA;                  "value_aggregations_count_terms": {&#xA;                     "terms": {&#xA;                        "field": "Events.Value_Aggregations.Count"&#xA;                     }&#xA;                  }&#xA;               }&#xA;            }&#xA;         }&#xA;      }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>which returns:</p>&#xA;&#xA;<pre><code>{&#xA;   "took": 3,&#xA;   "timed_out": false,&#xA;   "_shards": {&#xA;      "total": 1,&#xA;      "successful": 1,&#xA;      "failed": 0&#xA;   },&#xA;   "hits": {&#xA;      "total": 1,&#xA;      "max_score": 0,&#xA;      "hits": []&#xA;   },&#xA;   "aggregations": {&#xA;      "nested_events": {&#xA;         "doc_count": 2,&#xA;         "filtered_events": {&#xA;            "doc_count": 1,&#xA;            "value_aggregations_count_terms": {&#xA;               "doc_count_error_upper_bound": 0,&#xA;               "sum_other_doc_count": 0,&#xA;               "buckets": [&#xA;                  {&#xA;                     "key": "100",&#xA;                     "doc_count": 1&#xA;                  }&#xA;               ]&#xA;            },&#xA;            "events_count_terms": {&#xA;               "doc_count_error_upper_bound": 0,&#xA;               "sum_other_doc_count": 0,&#xA;               "buckets": [&#xA;                  {&#xA;                     "key": "188",&#xA;                     "doc_count": 1&#xA;                  }&#xA;               ]&#xA;            }&#xA;         }&#xA;      }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><em>Caveat</em>: it's not clear to me whether you actually need the <code>"filter": { "nested": { ... } }</code> clause of the <code>"query"</code> in what I've shown here. If this part filters out parent documents in a useful way, then you need it. If your only intention was to select which nested child documents from which to return fields, then it's redundant here since the <code>filter</code> aggregation is taking care of that part.</p>&#xA;&#xA;<p>Here is the code I used to test it:</p>&#xA;&#xA;<p><a href="http://sense.qbox.io/gist/dcc46e50117031de300b6f91c647fe9b729a5283" rel="nofollow">http://sense.qbox.io/gist/dcc46e50117031de300b6f91c647fe9b729a5283</a></p>&#xA;
<p>here is the parent/child relationship query which resulted my desired output</p>&#xA;&#xA;<pre><code>{&#xA;  "query": {&#xA;  "filtered": {&#xA;    "query": {&#xA;          "bool": {"must": [&#xA;          {"term": {"Name": "visit"}}&#xA;         ]}&#xA;    },&#xA;    "filter":{&#xA;    "has_parent": {&#xA;      "type": "domain_info",&#xA;      "query" : {&#xA;        "filtered": {&#xA;          "query": { "match_all": {}},&#xA;          "filter" : {&#xA;            "and": [&#xA;              {"term": {"Domain": 'abc.com'}}&#xA;&#xA;            ]&#xA;          }&#xA;        }&#xA;      }&#xA;     }&#xA;    }&#xA;  }&#xA; }&#xA;}&#xA;</code></pre>&#xA;