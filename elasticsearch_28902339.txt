28902339
ElasticSearch only query nested if it exists
<p>I have this search query to find the query search term "red dog" in the root Title and Description and also match the nested comments document.</p>&#xA;&#xA;<pre><code>GET /_all/video/_search&#xA;{&#xA;   "query":{&#xA;      "bool":{&#xA;         "should":[&#xA;            {&#xA;               "multi_match":{&#xA;                  "query":"red dog",&#xA;                  "fields":[&#xA;                     "Title",&#xA;                     "Description"&#xA;                  ],&#xA;                  "type": "cross_fields",&#xA;                  "operator":"and"&#xA;               }&#xA;            },&#xA;        {&#xA;         "nested":{&#xA;                  "path":"Comments",&#xA;                  "query":{&#xA;                     "multi_match":{&#xA;                        "query":"red dog",&#xA;                        "fields":[&#xA;                            "Comments.Description",&#xA;                            "Comments.Description.folded"&#xA;                        ],&#xA;                        "type": "cross_fields",&#xA;                        "operator":"and"&#xA;                     }&#xA;                  }&#xA;               }&#xA;            }&#xA;         ]&#xA;      }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Unfortunately for me, comments are sometimes null when I persist them to ElasticSearch, is it possible to do some sort of "include if document exists" condition?</p>&#xA;&#xA;<p><strong>Update</strong></p>&#xA;&#xA;<p>I still get the same error </p>&#xA;&#xA;<pre><code>[nested] failed to find nested object under path [Comments]&#xA;</code></pre>&#xA;&#xA;<p>When I try to query using exists</p>&#xA;&#xA;<pre><code>    GET /_all/video/_search&#xA;    {&#xA;       "query":{&#xA;          "bool":{&#xA;             "should":[&#xA;                {&#xA;                   "multi_match":{&#xA;                      "query":"lisa",&#xA;                      "fields":[&#xA;                         "Title",&#xA;                         "Description"&#xA;                      ],&#xA;                      "type":"cross_fields",&#xA;                      "operator":"and"&#xA;                   }&#xA;                },&#xA;                {&#xA;                   "nested":{&#xA;                      "path":"Comments",&#xA;                      "query":{&#xA;                         "filtered":{&#xA;                            "query":{&#xA;                               "match_all":{}&#xA;                            },&#xA;                            "filter":{&#xA;                               "exists":{&#xA;                                  "field":"Comments.Description"&#xA;                               }&#xA;                            }&#xA;                         }&#xA;                      }&#xA;                   }&#xA;                }&#xA;             ]&#xA;          }&#xA;       }&#xA;    }&#xA;</code></pre>&#xA;&#xA;<p>My mapping for everything</p>&#xA;&#xA;<pre><code>{&#xA;   "en":{&#xA;      "mappings":{&#xA;         "video":{&#xA;            "properties":{&#xA;               "Comments":{&#xA;                  "type":"nested",&#xA;                  "properties":{&#xA;                     "Description":{&#xA;                        "type":"string",&#xA;                        "analyzer":"english",&#xA;                        "fields":{&#xA;                           "folded":{&#xA;                              "type":"string",&#xA;                              "analyzer":"folding"&#xA;                           }&#xA;                        }&#xA;                     }&#xA;                  }&#xA;               },&#xA;               "Description":{&#xA;                  "type":"string",&#xA;                  "analyzer":"english",&#xA;                  "fields":{&#xA;                     "folded":{&#xA;                        "type":"string",&#xA;                        "analyzer":"folding"&#xA;                     }&#xA;                  }&#xA;               },&#xA;               "Title":{&#xA;                  "type":"string",&#xA;                  "analyzer":"english",&#xA;                  "fields":{&#xA;                     "folded":{&#xA;                        "type":"string",&#xA;                        "analyzer":"folding"&#xA;                     }&#xA;                  }&#xA;               }&#xA;            }&#xA;         }&#xA;      }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And my settings</p>&#xA;&#xA;<pre><code>{&#xA;    "settings": {&#xA;        "analysis": {&#xA;            "analyzer": {&#xA;                "folding": {&#xA;                    "tokenizer": "standard",&#xA;                    "filter": [&#xA;                        "lowercase",&#xA;                        "asciifolding"&#xA;                    ]&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;
<p>It turns out I had a marvel index which didn't have the mapping for my type in.  I deleted the plugin and it was fine searching across all indexes.</p>&#xA;
<p>Easiest way to do this is to "denormalize" your data so that you have a property that contains the count and a boolean if it exists or not. Then you can just search on those properties.</p>&#xA;&#xA;<p>For example:</p>&#xA;&#xA;<pre><code>{&#xA;   "id": 31939,&#xA;   "hasAttachments": true,&#xA;   "attachmentCount": 2,&#xA;   "attachments": [&#xA;      {&#xA;         "type": "Attachment",&#xA;         "name": "txt.txt",&#xA;         "mimeType": "text/plain"&#xA;      },&#xA;      {&#xA;         "type": "Inline",&#xA;         "name": "jpg.jpg",&#xA;         "mimeType": "image/jpeg"&#xA;      }&#xA;   ]  &#xA;}&#xA;</code></pre>&#xA;