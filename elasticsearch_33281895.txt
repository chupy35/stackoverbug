33281895
Generating matches for URL strings in elasticsearch
<p>I've been trying to come up with the right combination of tokenizers/token filters and analyzers to leverage elasticsearch to match URLs.</p>&#xA;&#xA;<p>Unfortunately, it seems like every approach I've taken so far misses one or two edge cases.  I'm hoping someone out there can perhaps shed some light on the following:</p>&#xA;&#xA;<p>If I have the following values stored in elasticsearch:</p>&#xA;&#xA;<ol>&#xA;<li><a href="http://www.example111.com" rel="nofollow">http://www.example111.com</a></li>&#xA;<li><a href="http://www.example111.com/cats" rel="nofollow">http://www.example111.com/cats</a></li>&#xA;<li><a href="http://www.example111.com/cats?type=tabby" rel="nofollow">http://www.example111.com/cats?type=tabby</a></li>&#xA;<li><a href="http://www.example111.com/cats/dogs" rel="nofollow">http://www.example111.com/cats/dogs</a></li>&#xA;<li><a href="http://www.example111.com/dogs/cats" rel="nofollow">http://www.example111.com/dogs/cats</a></li>&#xA;<li><a href="http://www.example222.com/cats" rel="nofollow">http://www.example222.com/cats</a></li>&#xA;<li><a href="http://www.example222.com" rel="nofollow">http://www.example222.com</a></li>&#xA;<li><a href="http://www.example222.com/cats/dogs" rel="nofollow">http://www.example222.com/cats/dogs</a></li>&#xA;<li><a href="http://www.example333.com/fish" rel="nofollow">http://www.example333.com/fish</a></li>&#xA;</ol>&#xA;&#xA;<p>I'm wondering what query I could use to generate the following search string and result set combinations (ordered by relevance score):</p>&#xA;&#xA;<ul>&#xA;<li><p><a href="http://www.example111.com/cats/dogs" rel="nofollow">http://www.example111.com/cats/dogs</a>&#xA;<code>[4,2,3,1]</code></p></li>&#xA;<li><p><a href="http://www.example111.com/cats?type=birman" rel="nofollow">http://www.example111.com/cats?type=birman</a>&#xA;<code>[2,1]</code></p></li>&#xA;<li><p><a href="http://www.example111.com/dogs" rel="nofollow">http://www.example111.com/dogs</a>&#xA;<code>[1]</code></p></li>&#xA;<li><p><a href="http://www.example222.com/cats" rel="nofollow">http://www.example222.com/cats</a>&#xA;<code>[6,7]</code></p></li>&#xA;<li><p><a href="http://www.example333.com" rel="nofollow">http://www.example333.com</a>&#xA;<code>[]</code></p></li>&#xA;</ul>&#xA;&#xA;<p>The general idea being expressed here is that the results are ranked by how similar they are to the input, all the way down to the tld and scheme.  Results are discarded when an <em>entire</em> query string doesn't match, or a segment doesn't match.</p>&#xA;
<p>How about this:</p>&#xA;&#xA;<p>1). When you store the urls, the url data is an object that looks like:</p>&#xA;&#xA;<pre><code>{&#xA;    "tld" : "http://www.example111.com",&#xA;    "path" : "/cats",&#xA;    "qs" : "?type=birman"&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I don't think you want these to be analyzed... but that might require a bit more thought.</p>&#xA;&#xA;<p>2). When you have to query these records, you will similarly parse the url query.</p>&#xA;&#xA;<p>3). Concoct a query that fits your requirements - so:</p>&#xA;&#xA;<ul>&#xA;<li>tld must match completely</li>&#xA;<li>paths in the results must be a substring of the path in query url - you can use a query time analyzer that will give you all possible prefix substrings of the path in the query url (so for example: given "/cats/dogs", you want "/", "/c", "/ca",..., "/cats/dogs") although that seems inefficient... perhaps you can just get the pieces like "/", "/cats", "/cats/dogs" beforehand when creating your query and these will just represent additional clauses in the query</li>&#xA;<li>match the query string exactly?  I am not sure what the full requirements are here.</li>&#xA;</ul>&#xA;&#xA;<p>Query might look something like (where query url <a href="http://www.example111.com/cats/dogs?type=birman" rel="nofollow">http://www.example111.com/cats/dogs?type=birman</a>):</p>&#xA;&#xA;<pre><code>{&#xA;    "query" : {&#xA;        "bool" : {&#xA;            "must" : [&#xA;                {&#xA;                    "match" : {&#xA;                        "url.tld" : "http://www.example111.com"&#xA;                    }&#xA;                },&#xA;                {&#xA;                    "match" : {&#xA;                        "url.qs" : "?type=birman"&#xA;                    }&#xA;                }&#xA;            ]&#xA;            "should" : [&#xA;                {&#xA;                    "match" : {&#xA;                        "url.path" : {&#xA;                            "query" : "/",&#xA;                            "boost" : 1&#xA;                        }&#xA;                    }&#xA;                },&#xA;                {&#xA;                    "match" : {&#xA;                        "url.path" : {&#xA;                            "query" : "/cats",&#xA;                            "boost" : 2&#xA;                        }&#xA;                    }&#xA;                },&#xA;                {&#xA;                    "match" : {&#xA;                        "url.path" : {&#xA;                            "query" : "/cats/dogs",&#xA;                            "boost" : 3&#xA;                        }&#xA;                    }&#xA;                }&#xA;            ]&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>If you have multiple urls per record, look into nested objects and nested queries.  </p>&#xA;&#xA;<p>Anyway, all this is just one possible idea... that's not a single convenient quick query you might have been hoping for.</p>&#xA;