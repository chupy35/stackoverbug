30909927
How to define a bucket aggregation where buckets are defined by arbitrary filters on a field (GROUP BY CASE equivalent)
<p>ElasticSearch enables us to filter a set of documents by regex on any given field, and also to group the resulting documents by the terms in a given (same or different field, using "bucket aggregations". For example, on an index that contains a "Url" field and a "UserAgent" field (some kind of web server log), the following will return the top document counts for terms found in the UserAgent field.</p>&#xA;&#xA;<pre><code>{&#xA;    query: { filtered: { filter: { regexp: { Url : ".*interestingpage.*" } } } },&#xA;    size: 0,                            &#xA;    aggs: { myaggregation: { terms: { field: "UserAgent" } } }                          &#xA;}&#xA;</code></pre>&#xA;&#xA;<p>What I'd like to do is use the power of the regexp filter (which operates on the whole field, not just terms within a field) to manually define my aggregation buckets, so that I can relatively reliably split my documents/counts/hits by "user agent type" data, rather than the arbitrary terms parsed by elastic search in the field.</p>&#xA;&#xA;<p>Basically, I am looking for the equivalent of a CASE statement in a GROUP BY, in SQL terms. The SQL query that would express my intent would be something like:</p>&#xA;&#xA;<pre><code>SELECT Bucket, Count(*)&#xA;FROM (&#xA;    SELECT CASE &#xA;        WHEN UserAgent LIKE '%android%' OR UserAgent LIKE '%ipad%' OR UserAgent LIKE '%iphone%' OR UserAgent LIKE '%mobile%' THEN 'Mobile'&#xA;        WHEN UserAgent LIKE '%msie 7.0%' then 'IE7'&#xA;        WHEN UserAgent LIKE '%msie 8.0%' then 'IE8'&#xA;        WHEN UserAgent LIKE '%firefox%' then 'FireFox'&#xA;        ELSE 'OTHER'&#xA;        END Bucket&#xA;    FROM pagedata&#xA;    WHERE Url LIKE '%interestingpage%'&#xA;) Buckets&#xA;GROUP BY Bucket&#xA;</code></pre>&#xA;&#xA;<p><strong>Can this be done in an ElasticSearch query?</strong></p>&#xA;
<p>You could use a terms aggregation with a scripted field:</p>&#xA;&#xA;<pre><code>{&#xA;  query: { filtered: { filter: { regexp: { Url : ".*interestingpage.*" } } } },&#xA;  size: 0,&#xA;  aggs: {&#xA;    myaggregation: {&#xA;      terms: {&#xA;        script: "doc['UserAgent'] =~ /.*android.*/ || doc['UserAgent'] =~ /.*ipad.*/ || doc['UserAgent'] =~ /.*iphone.*/ || doc['UserAgent'] =~ /.*mobile.*/ ? 'Mobile' : doc['UserAgent'] =~ /.*msie 7.0.*/ ? 'IE7' : '...you got the idea by now...'"&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>But beware of the performance hit!</p>&#xA;
<p>This is an interesting use-case.</p>&#xA;&#xA;<p>Here's a more Elasticsearch-way solution.&#xA;The idea is to do all this regex matching at indexing time and the search time to be fast (scripts during search time, if there are many documents, are not performing well and will take time). Let me explain:</p>&#xA;&#xA;<ol>&#xA;<li><p>define a sub-field for your main field, in which the manipulation of terms is customized</p></li>&#xA;<li><p>this manipulation will be performed so that the only terms that will be kept in the index will be the ones you defined: <code>FireFox</code>, <code>IE8</code>, <code>IE7</code>, <code>Mobile</code>. Each document can have more than one of these fields. Meaning a text like <code>msie 7.0 sucks and ipad rules</code> will generate only two terms: <code>IE7</code> and <code>Mobile</code>.</p></li>&#xA;</ol>&#xA;&#xA;<p>All this is made possible by the <code>keep</code> <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-keep-words-tokenfilter.html" rel="nofollow">token filter</a>.</p>&#xA;&#xA;<ol start="3">&#xA;<li><p>there should be another list of token filters that will actually perform the replacement. This will be possible by using the <code>pattern_replace</code> <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pattern_replace-tokenfilter.html" rel="nofollow">token filter</a>.</p></li>&#xA;<li><p>because you have two words that should be replaced (<code>msie 7.0</code> for example), you need a way to capture these two words (<code>msie</code> and <code>7.0</code>) one beside the other. This will be possible using the <code>shingle</code> <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-shingle-tokenfilter.html" rel="nofollow">token filter</a>.</p></li>&#xA;</ol>&#xA;&#xA;<p>Let me put all this together and provide the complete solution:</p>&#xA;&#xA;<pre><code>PUT /test&#xA;{&#xA;  "settings": {&#xA;    "analysis": {&#xA;      "analyzer": {&#xA;        "my_pattern_replace_analyzer": {&#xA;          "tokenizer": "whitespace",&#xA;          "filter": [&#xA;            "filter_shingle",&#xA;            "my_pattern_replace1",&#xA;            "my_pattern_replace2",&#xA;            "my_pattern_replace3",&#xA;            "my_pattern_replace4",&#xA;            "words_to_be_kept"&#xA;          ]&#xA;        }&#xA;      },&#xA;      "filter": {&#xA;        "filter_shingle": {&#xA;          "type": "shingle",&#xA;          "max_shingle_size": 10,&#xA;          "min_shingle_size": 2,&#xA;          "output_unigrams": true&#xA;        },&#xA;        "my_pattern_replace1": {&#xA;          "type": "pattern_replace",&#xA;          "pattern": "android|ipad|iphone|mobile",&#xA;          "replacement": "Mobile"&#xA;        },&#xA;        "my_pattern_replace2": {&#xA;          "type": "pattern_replace",&#xA;          "pattern": "msie 7.0",&#xA;          "replacement": "IE7"&#xA;        },&#xA;        "my_pattern_replace3": {&#xA;          "type": "pattern_replace",&#xA;          "pattern": "msie 8.0",&#xA;          "replacement": "IE8"&#xA;        },&#xA;        "my_pattern_replace4": {&#xA;          "type": "pattern_replace",&#xA;          "pattern": "firefox",&#xA;          "replacement": "FireFox"&#xA;        },&#xA;        "words_to_be_kept": {&#xA;          "type": "keep",&#xA;          "keep_words": [&#xA;            "FireFox", "IE8", "IE7", "Mobile"&#xA;          ]&#xA;        }&#xA;      }&#xA;    }&#xA;  },&#xA;  "mappings": {&#xA;    "test": {&#xA;      "properties": {&#xA;        "UserAgent": {&#xA;          "type": "string",&#xA;          "fields": {&#xA;            "custom": {&#xA;              "analyzer": "my_pattern_replace_analyzer",&#xA;              "type": "string"&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Test data:</p>&#xA;&#xA;<pre><code>POST /test/test/_bulk&#xA;{"index":{"_id":1}}&#xA;{"UserAgent": "android OS is the best firefox"}&#xA;{"index":{"_id":2}}&#xA;{"UserAgent": "firefox is my favourite browser"}&#xA;{"index":{"_id":3}}&#xA;{"UserAgent": "msie 7.0 sucks and ipad rules"}&#xA;</code></pre>&#xA;&#xA;<p>Query:</p>&#xA;&#xA;<pre><code>GET /test/test/_search?search_type=count&#xA;{&#xA;  "aggs": {&#xA;    "myaggregation": {&#xA;      "terms": {&#xA;        "field": "UserAgent.custom",&#xA;        "size": 10&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Results:</p>&#xA;&#xA;<pre><code>   "hits": {&#xA;      "total": 3,&#xA;      "max_score": 0,&#xA;      "hits": []&#xA;   },&#xA;   "aggregations": {&#xA;      "myaggregation": {&#xA;         "doc_count_error_upper_bound": 0,&#xA;         "sum_other_doc_count": 0,&#xA;         "buckets": [&#xA;            {&#xA;               "key": "FireFox",&#xA;               "doc_count": 2&#xA;            },&#xA;            {&#xA;               "key": "Mobile",&#xA;               "doc_count": 2&#xA;            },&#xA;            {&#xA;               "key": "IE7",&#xA;               "doc_count": 1&#xA;            }&#xA;         ]&#xA;      }&#xA;   }&#xA;</code></pre>&#xA;