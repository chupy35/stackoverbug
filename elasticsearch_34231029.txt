34231029
How many search analyzers can be used on a field?
<p>Am I right in thinking you can <strong>only</strong> use 1 <code>search analyzer</code> on a field? </p>&#xA;&#xA;<p>For example say I have a field <code>title</code> with a <code>multi-field</code> of <code>special_title</code>, is it possible for me to give <code>title</code> a specific <code>search_analyzer1</code> and <code>special_title</code> another specific <code>search_analyzer2</code>? Here is a mapping to illustrate what I mean:</p>&#xA;&#xA;<pre><code>{&#xA;    "title": {&#xA;        "analyzer": "standard",&#xA;        "search_analyzer": "search_analyzer1",&#xA;        "type": "string",&#xA;        "fields": {&#xA;            "special_title": {&#xA;                "type": "string",&#xA;                "index": "analyzed",&#xA;                "analyzer": "standard",&#xA;                "search_analyzer": "search_analyzer2"&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<h2>Update</h2>&#xA;&#xA;<p>It seems it isn't possible, here's a gist to prove it:</p>&#xA;&#xA;<pre><code>        PUT /my_index&#xA;        {&#xA;          "settings": {&#xA;            "analysis": {&#xA;                 "char_filter":{&#xA;                      "hyphen":{&#xA;                    "type": "pattern_replace",&#xA;                    "pattern": "[-]",&#xA;                        "replacement": ""&#xA;                 },&#xA;                      "space":{&#xA;                    "type": "pattern_replace",&#xA;                    "pattern": " ",&#xA;                        "replacement": ""&#xA;                 }      &#xA;                   },&#xA;              "analyzer": {&#xA;                 "merge":{&#xA;                    "type":"custom",&#xA;                    "tokenizer":"standard",&#xA;                    "filter": [&#xA;                      "lowercase"&#xA;                    ],&#xA;                    "char_filter": ["hyphen", "space", "html_strip"]&#xA;                  }&#xA;              }&#xA;            }&#xA;          },&#xA;          "mappings": {&#xA;            "my_type": {&#xA;              "properties": {&#xA;                "title": {&#xA;                  "type": "string",&#xA;                  "analyzer": "standard", &#xA;                  "search_analyzer": "standard",&#xA;                  "fields": {&#xA;                    "title_merge" : {&#xA;                      "type": "string",&#xA;                       "analyzer": "standard", &#xA;                      "search_analyzer": "merge"&#xA;                    }&#xA;                  }&#xA;                }&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;&#xA;        delete my_index&#xA;&#xA;        PUT my_index/my_type/1&#xA;        {&#xA;          "title": "antiemetics" &#xA;        }&#xA;&#xA;        GET my_index/_search&#xA;        {&#xA;            "query": { &#xA;                            "query_string" : {&#xA;                                "fields" : ["title", "title_merge"],&#xA;                                "default_operator": "AND", &#xA;                                "query" :"anti emetics",&#xA;                                "use_dis_max" : true&#xA;                            }&#xA;                        }&#xA;        }&#xA;</code></pre>&#xA;&#xA;<p>The query returns 0 results, I was hoping "anti emetics" would get passed to the <code>merge</code> search analyzer and that would then tokenize the query to <code>antiemetics</code> so that it could match on the token in the index. So looks like it's not possible which is quite odd and disappointing.</p>&#xA;&#xA;<h2>Update 2</h2>&#xA;&#xA;<p>I am able to get the merge analyzer to kick in as expected with a match query but not with a query_string and I can't expect uses to enter a term with quotes if it's a hyphenated term they are looking for.</p>&#xA;&#xA;<pre><code>    GET my_index/_search&#xA;    {&#xA;        "query": { &#xA;          "match": {&#xA;            "title.title_merge": "anti emetics"&#xA;          }&#xA;         }&#xA;    }&#xA;</code></pre>&#xA;
<p>Yes, It is possible to give each field its own <code>search_analyzer</code></p>&#xA;&#xA;<p>For query</p>&#xA;&#xA;<pre><code>{&#xA;  "query": {&#xA;    "match": {&#xA;      "title": "title one"&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>In this case <code>search_analyzer1</code> will be applied to "title one" and for</p>&#xA;&#xA;<pre><code>{&#xA;  "query": {&#xA;    "match": {&#xA;      "title.special_title": "title two"&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>this will be <code>analyzed</code> with <code>search_analyzer2</code></p>&#xA;&#xA;<p><strong>EDIT 1</strong></p>&#xA;&#xA;<p>There are couple of issues with your query.</p>&#xA;&#xA;<p>1) you should be accessing field <code>title_merge</code> with <code>title.title_merge</code></p>&#xA;&#xA;<p>2) I think what you are looking for is <strong>exact</strong> match considering your analyzer setup. Your current query is looking for two separate tokens <em>anti</em> <strong>AND</strong> <em>emetics</em></p>&#xA;&#xA;<p>You need to use <strong>double quotes</strong> to get expected results. From the <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html#query-string-syntax" rel="nofollow">Docs</a></p>&#xA;&#xA;<blockquote>&#xA;  <p>The query string is parsed into a series of terms and operators. A&#xA;  term can be a single word — quick or brown — or a phrase, surrounded&#xA;  by double quotes — "quick brown" — which searches for all the words in&#xA;  the phrase, in the same order.</p>&#xA;</blockquote>&#xA;&#xA;<p>I think this query will work</p>&#xA;&#xA;<pre><code>GET my_index/_search&#xA;{&#xA;  "query": {&#xA;    "query_string": {&#xA;      "fields": [&#xA;        "title*"&#xA;      ],&#xA;      "query": "\"anti emetics\"",&#xA;      "use_dis_max": true&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Now ES will consider <code>anti emetics</code> as phrase and it will merge into <code>antiemetics</code> because of <code>space</code> <code>char_filter</code> and you will get expected results.</p>&#xA;&#xA;<p>Does this help?</p>&#xA;