34207438
ElasticSearch aggregations - to lowercase or not to lowercase
<p>Please observe this secenario:</p>&#xA;&#xA;<p><strong>Define mappings</strong></p>&#xA;&#xA;<pre><code>PUT /my_index&#xA;{&#xA;  "mappings": {&#xA;    "my_type": {&#xA;      "properties": {&#xA;        "city": {&#xA;          "type": "string",&#xA;          "fields": {&#xA;            "raw": { &#xA;              "type":  "string",&#xA;              "index": "not_analyzed"&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>Add data</strong></p>&#xA;&#xA;<pre><code>PUT /my_index/my_type/1&#xA;{&#xA;  "city": "New York"&#xA;}&#xA;&#xA;PUT /my_index/my_type/2&#xA;{&#xA;  "city": "York"&#xA;}&#xA;&#xA;PUT /my_index/my_type/3&#xA;{&#xA;  "city": "york"&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>Query for facets</strong></p>&#xA;&#xA;<pre><code>GET /my_index/_search&#xA;{&#xA;  "size": 0, &#xA;  "aggs": {&#xA;    "Cities": {&#xA;      "terms": {&#xA;        "field": "city.raw" &#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>Result</strong></p>&#xA;&#xA;<pre><code>{&#xA;...&#xA;  "aggregations": {&#xA;    "Cities": {&#xA;      "doc_count_error_upper_bound": 0,&#xA;      "sum_other_doc_count": 0,&#xA;      "buckets": [&#xA;        {&#xA;          "key": "New York",&#xA;          "doc_count": 1&#xA;        },&#xA;        {&#xA;          "key": "York",&#xA;          "doc_count": 1&#xA;        },&#xA;        {&#xA;          "key": "york",&#xA;          "doc_count": 1&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>Dilemma</strong></p>&#xA;&#xA;<p>I would like to 2 thing:</p>&#xA;&#xA;<ol>&#xA;<li>"York" and "york" should be combined so instead of 3 buckets with each 1 hit I would 2 buckets, one for "New York (1)" and one for "York (2)"</li>&#xA;<li>The casing of the city must be preserved - I don't want facet values to be all lowercased</li>&#xA;</ol>&#xA;&#xA;<p><strong>Dream result</strong></p>&#xA;&#xA;<pre><code>{&#xA;    ...&#xA;      "aggregations": {&#xA;        "Cities": {&#xA;          "doc_count_error_upper_bound": 0,&#xA;          "sum_other_doc_count": 0,&#xA;          "buckets": [&#xA;            {&#xA;              "key": "New York",&#xA;              "doc_count": 1&#xA;            },&#xA;            {&#xA;              "key": "York",&#xA;              "doc_count": 2&#xA;            }&#xA;          ]&#xA;        }&#xA;      }&#xA;    }&#xA;</code></pre>&#xA;
<p>It's going to make your client-side code slightly more complicated, but you could always do something like this.</p>&#xA;&#xA;<p>Set up the index with an additional sub-field that is only lower-cased (not split on white space):</p>&#xA;&#xA;<pre><code>PUT /my_index&#xA;{&#xA;   "settings": {&#xA;      "analysis": {&#xA;         "analyzer": {&#xA;            "lowercase_analyzer": {&#xA;               "type": "custom",&#xA;               "tokenizer": "keyword",&#xA;               "filter": [&#xA;                  "lowercase"&#xA;               ]&#xA;            }&#xA;         }&#xA;      }&#xA;   },&#xA;   "mappings": {&#xA;      "my_type": {&#xA;         "properties": {&#xA;            "city": {&#xA;               "type": "string",&#xA;               "fields": {&#xA;                  "lowercase": {&#xA;                     "type": "string",&#xA;                     "analyzer": "lowercase_analyzer"&#xA;                  },&#xA;                  "raw": {&#xA;                     "type": "string",&#xA;                     "index": "not_analyzed"&#xA;                  }&#xA;               }&#xA;            }&#xA;         }&#xA;      }&#xA;   }&#xA;}&#xA;&#xA;PUT /my_index/my_type/_bulk&#xA;{"index":{"_id":1}}&#xA;{"city":"New York"}&#xA;{"index":{"_id":2}}&#xA;{"city":"York"}&#xA;{"index":{"_id":3}}&#xA;{"city":"york"}&#xA;</code></pre>&#xA;&#xA;<p>Then use a two-level aggregation like this, where the second orders alphabetically ascending (so that upper-case term will come first) and only returns the top raw term for each lower-case term:</p>&#xA;&#xA;<pre><code>GET /my_index/_search&#xA;{&#xA;   "size": 0,&#xA;   "aggs": {&#xA;      "city_lowercase": {&#xA;         "terms": {&#xA;            "field": "city.lowercase"&#xA;         },&#xA;         "aggs": {&#xA;            "city_terms": {&#xA;               "terms": {&#xA;                  "field": "city.raw",&#xA;                  "order" : { "_term" : "asc" },&#xA;                  "size": 1&#xA;               }&#xA;            }&#xA;         }&#xA;      }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>which returns:</p>&#xA;&#xA;<pre><code>{&#xA;   "took": 5,&#xA;   "timed_out": false,&#xA;   "_shards": {&#xA;      "total": 5,&#xA;      "successful": 5,&#xA;      "failed": 0&#xA;   },&#xA;   "hits": {&#xA;      "total": 3,&#xA;      "max_score": 0,&#xA;      "hits": []&#xA;   },&#xA;   "aggregations": {&#xA;      "city_lowercase": {&#xA;         "doc_count_error_upper_bound": 0,&#xA;         "sum_other_doc_count": 0,&#xA;         "buckets": [&#xA;            {&#xA;               "key": "york",&#xA;               "doc_count": 2,&#xA;               "city_terms": {&#xA;                  "doc_count_error_upper_bound": 0,&#xA;                  "sum_other_doc_count": 1,&#xA;                  "buckets": [&#xA;                     {&#xA;                        "key": "York",&#xA;                        "doc_count": 1&#xA;                     }&#xA;                  ]&#xA;               }&#xA;            },&#xA;            {&#xA;               "key": "new york",&#xA;               "doc_count": 1,&#xA;               "city_terms": {&#xA;                  "doc_count_error_upper_bound": 0,&#xA;                  "sum_other_doc_count": 0,&#xA;                  "buckets": [&#xA;                     {&#xA;                        "key": "New York",&#xA;                        "doc_count": 1&#xA;                     }&#xA;                  ]&#xA;               }&#xA;            }&#xA;         ]&#xA;      }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Here's the code I used (with a few more doc examples):</p>&#xA;&#xA;<p><a href="http://sense.qbox.io/gist/f3781d58fbaadcc1585c30ebb087108d2752dfff" rel="nofollow">http://sense.qbox.io/gist/f3781d58fbaadcc1585c30ebb087108d2752dfff</a></p>&#xA;