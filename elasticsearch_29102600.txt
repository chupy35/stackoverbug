29102600
How to filter a range in comparison to phrase using elasticsearch
<p>I need to search an index for a hits that are more or equal to some phrase. To be more clear I need to build query like the following SQL:</p>&#xA;&#xA;<pre><code>SELECT * FROM Table WHERE MyNVarCharField &gt;= 'some_string'&#xA;</code></pre>&#xA;&#xA;<p>Mapping:</p>&#xA;&#xA;<pre><code>{&#xA;    "tock": {&#xA;        "mappings": {&#xA;            "post": {&#xA;                "properties": {&#xA;                    "content": {&#xA;                        "type": "string",&#xA;                        "index_analyzer": "english"&#xA;                    },&#xA;                    "id": {&#xA;                        "type": "double"&#xA;                    },&#xA;                    "title": {&#xA;                        "type": "string",&#xA;                        "index_analyzer": "english"&#xA;                    }&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Index contains two objects:</p>&#xA;&#xA;<pre><code>[&#xA;    {&#xA;        "id": 1,&#xA;        "title": "Post1",&#xA;        "content": "Ash to ash item"&#xA;    },&#xA;    {&#xA;        "id": 2,&#xA;        "title": "Post2",&#xA;        "content": "Dust to dust item"&#xA;    }&#xA;]&#xA;</code></pre>&#xA;&#xA;<p>Now I want to search for an objects which content is greater or equal to "<em>Dust to dust item</em>". I tried many different approaches and ended up with something like that:</p>&#xA;&#xA;<pre><code>{&#xA;    "sort": [&#xA;        {&#xA;            "content": {&#xA;                "order": "asc"&#xA;            }&#xA;        }&#xA;    ],&#xA;    "filtered": {&#xA;        "query": {&#xA;            "match": {&#xA;                "content": {&#xA;                    "query": "item"&#xA;                }&#xA;            }&#xA;        },&#xA;        "filter": {&#xA;            "range": {&#xA;                "content": {&#xA;                    "from": "Dust to dust",&#xA;                    "include_lower": true,&#xA;                    "include_upper": true&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>But it doesn't work as I expect. Both objects are returned. So I need help :)</p>&#xA;&#xA;<p>Is it really possible to query elastic in such manner? What I need to do to split index in two parts by a phrase? </p>&#xA;&#xA;<p>By the way, you should mention that it is guaranteed that this phrase already exists in the index.</p>&#xA;
<p>Your range filter matches both documents because the text is compared to each of the terms generated for the <code>"content"</code> field, not against the raw source text. Since the <a href="http://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-lang-analyzer.html#english-analyzer" rel="nofollow"><code>english</code> analyzer</a> uses the <a href="http://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-standard-tokenizer.html" rel="nofollow">standard tokenizer</a>, one of these terms, for each document, is <code>"item"</code>. Since <code>"item"</code> is greater than <code>"dust"</code>, both documents match.</p>&#xA;&#xA;<p>If you have very many documents in your index, the approach you are using is probably not going to be workable because so many terms are going to be generated.</p>&#xA;&#xA;<p>One thing you can do is use the setting <code>"index":"not_analyzed"</code> on your <code>"content"</code> field. Or, if you need <code>"content"</code> to be analyzed for other reasons, then define a <a href="http://www.elastic.co/guide/en/elasticsearch/reference/current/_multi_fields.html" rel="nofollow">sub-field</a> that isn't analyzed, then do your range comparison against that field. Here is an example.</p>&#xA;&#xA;<p>So I defined an index as follows:</p>&#xA;&#xA;<pre><code>PUT /test_index&#xA;{&#xA;   "mappings": {&#xA;      "post": {&#xA;         "properties": {&#xA;            "content": {&#xA;               "type": "string",&#xA;               "index_analyzer": "english",&#xA;               "fields": {&#xA;                  "raw": {&#xA;                     "type": "string",&#xA;                     "index": "not_analyzed"&#xA;                  }&#xA;               }&#xA;            },&#xA;            "id": {&#xA;               "type": "double"&#xA;            },&#xA;            "title": {&#xA;               "type": "string",&#xA;               "index_analyzer": "english"&#xA;            }&#xA;         }&#xA;      }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Then added three docs (your two plus another for comparison):</p>&#xA;&#xA;<pre><code>POST /test_index/_bulk&#xA;{"index":{"_index":"test_index","_type":"post","_id":1}}&#xA;{"id": 1,"title": "Post1", "content": "Ash to ash item"}&#xA;{"index":{"_index":"test_index","_type":"post","_id":2}}&#xA;{"id": 2,"title": "Post2", "content": "Dust to dust item"}&#xA;{"index":{"_index":"test_index","_type":"post","_id":3}}&#xA;{"id": 3,"title": "Post3", "content": "Earth to earth item"}&#xA;</code></pre>&#xA;&#xA;<p>Then I can use a range query against <code>"content.raw"</code>:</p>&#xA;&#xA;<pre><code>POST /test_index/_search&#xA;{&#xA;    "query": {&#xA;        "range": {&#xA;           "content.raw": {&#xA;              "gte": "Dust to dust"&#xA;           }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>and it returns what I expect:</p>&#xA;&#xA;<pre><code>{&#xA;   "took": 2,&#xA;   "timed_out": false,&#xA;   "_shards": {&#xA;      "total": 1,&#xA;      "successful": 1,&#xA;      "failed": 0&#xA;   },&#xA;   "hits": {&#xA;      "total": 2,&#xA;      "max_score": 1,&#xA;      "hits": [&#xA;         {&#xA;            "_index": "test_index",&#xA;            "_type": "post",&#xA;            "_id": "2",&#xA;            "_score": 1,&#xA;            "_source": {&#xA;               "id": 2,&#xA;               "title": "Post2",&#xA;               "content": "Dust to dust item"&#xA;            }&#xA;         },&#xA;         {&#xA;            "_index": "test_index",&#xA;            "_type": "post",&#xA;            "_id": "3",&#xA;            "_score": 1,&#xA;            "_source": {&#xA;               "id": 3,&#xA;               "title": "Post3",&#xA;               "content": "Earth to earth item"&#xA;            }&#xA;         }&#xA;      ]&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>Edit:</strong> You can adapt the query you posted by changing <code>"content"</code> to <code>"content.raw"</code> (also your syntax was slightly wrong and gave me an error, so I wrapped the query and filter in a <code>"query"</code> block):</p>&#xA;&#xA;<pre><code>POST /test_index/_search&#xA;{&#xA;   "sort": [&#xA;      {&#xA;         "content": {&#xA;            "order": "asc"&#xA;         }&#xA;      }&#xA;   ],&#xA;   "query": {&#xA;      "filtered": {&#xA;         "query": {&#xA;            "match": {&#xA;               "content": {&#xA;                  "query": "item"&#xA;               }&#xA;            }&#xA;         },&#xA;         "filter": {&#xA;            "range": {&#xA;               "content.raw": {&#xA;                  "from": "Dust to dust",&#xA;                  "include_lower": true,&#xA;                  "include_upper": true&#xA;               }&#xA;            }&#xA;         }&#xA;      }&#xA;   }&#xA;}&#xA;...&#xA;{&#xA;   "took": 3,&#xA;   "timed_out": false,&#xA;   "_shards": {&#xA;      "total": 1,&#xA;      "successful": 1,&#xA;      "failed": 0&#xA;   },&#xA;   "hits": {&#xA;      "total": 2,&#xA;      "max_score": null,&#xA;      "hits": [&#xA;         {&#xA;            "_index": "test_index",&#xA;            "_type": "post",&#xA;            "_id": "2",&#xA;            "_score": null,&#xA;            "_source": {&#xA;               "id": 2,&#xA;               "title": "Post2",&#xA;               "content": "Dust to dust item"&#xA;            },&#xA;            "sort": [&#xA;               "dust"&#xA;            ]&#xA;         },&#xA;         {&#xA;            "_index": "test_index",&#xA;            "_type": "post",&#xA;            "_id": "3",&#xA;            "_score": null,&#xA;            "_source": {&#xA;               "id": 3,&#xA;               "title": "Post3",&#xA;               "content": "Earth to earth item"&#xA;            },&#xA;            "sort": [&#xA;               "earth"&#xA;            ]&#xA;         }&#xA;      ]&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Here is the code I used for testing:</p>&#xA;&#xA;<p><a href="http://sense.qbox.io/gist/57968fda91b9bcd5b2f1d8236ecb5fc1953800b7" rel="nofollow">http://sense.qbox.io/gist/57968fda91b9bcd5b2f1d8236ecb5fc1953800b7</a></p>&#xA;