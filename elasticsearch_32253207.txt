32253207
Elasticsearch EdgeNgram not returning shorter results first
<p>When I search on a field the scoring seems not to take into account the length of the field (i.e. documents with longer text are scored the same as shorter and for some reason are placed before). Not sure what I'm doing wrong.</p>&#xA;&#xA;<p>The indexing for the fields is as follows:</p>&#xA;&#xA;<pre><code>"name": {&#xA;        "type": "string",&#xA;        "analyzer": "autocomplete"&#xA;      },&#xA;"_alias": {&#xA;        "type": "string",&#xA;        "analyzer": "autocomplete"&#xA;      }&#xA;</code></pre>&#xA;&#xA;<p>Analyzer: </p>&#xA;&#xA;<pre><code>"autocomplete": {&#xA;        "char_filter": [&#xA;          "special_character_mapping"&#xA;        ],&#xA;        "filter": [&#xA;          "lowercase",&#xA;          "autocomplete_filter"&#xA;        ],&#xA;        "tokenizer": "whitespace"&#xA;      }&#xA;</code></pre>&#xA;&#xA;<p>Filter: </p>&#xA;&#xA;<pre><code>"autocomplete_filter": {&#xA;                "type": "edge_ngram",&#xA;                "min_gram": 1,&#xA;                "max_gram": 20&#xA;              }&#xA;</code></pre>&#xA;&#xA;<p>Query 1:</p>&#xA;&#xA;<pre><code>{&#xA;    "query": {&#xA;        "multi_match": {&#xA;            "query": "brown fo",&#xA;            "type": "most_fields",&#xA;            "fields": [&#xA;                "name",&#xA;                "_alias"&#xA;            ],&#xA;            "use_dis_max": true,&#xA;            "tie_breaker": 1,&#xA;            "minimum_should_match": "100%",&#xA;            "analyzer": "standard"&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This returns a lot of documents that are like:</p>&#xA;&#xA;<ul>&#xA;<li><strong>Browned fox</strong> </li>&#xA;<li><strong>Brownish foxes</strong> </li>&#xA;<li><strong>Browny for</strong></li>&#xA;</ul>&#xA;&#xA;<p>and on 10th place or so there is finally:</p>&#xA;&#xA;<ul>&#xA;<li><strong>Brown fox</strong></li>&#xA;</ul>&#xA;&#xA;<p>Not to mention that there is one document (<strong>Brown fox tree</strong>) on the 15th place or so that also has an alias "Brown" that is not taken into consideration.</p>&#xA;&#xA;<p>Query 2:</p>&#xA;&#xA;<pre><code>{&#xA;    "query": {&#xA;        "multi_match": {&#xA;            "query": "brown fo",&#xA;            "type": "cross_fields",&#xA;            "fields": [&#xA;                "name",&#xA;                "_alias"&#xA;            ],&#xA;            "use_dis_max": true,&#xA;            "tie_breaker": 1,&#xA;            "minimum_should_match": "100%",&#xA;            "analyzer": "standard"&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This returns somewhat better results:</p>&#xA;&#xA;<ul>&#xA;<li><strong>Brown fox tree</strong> </li>&#xA;<li><strong>Brownish foxes</strong> </li>&#xA;<li><strong>Brown fox</strong></li>&#xA;</ul>&#xA;&#xA;<p>Where the 2nd and 3d documents are always scored the same. First one has an alias "Brown" and is rightfully in front.</p>&#xA;&#xA;<p>I've tried all kinds of multi_match types and query_string but the results were the same.</p>&#xA;&#xA;<p>How to get the documents with shorter text (lucene should do it by itself?) in front of the rest?</p>&#xA;
<p>Since your fields <code>name</code> and <code>_alias</code> have been specified with the <code>autocomplete</code> analyzer (note that since you're only using that analyzer at indexing time, you should specify <code>index_analyzer</code> instead of <code>analyzer</code>), your input is going to be:</p>&#xA;&#xA;<ol>&#xA;<li>separated by white spaces</li>&#xA;<li>the tokens from step 1 are going to be lowercased</li>&#xA;<li>the lowercased tokens from step 2 are going to be split into prefixes</li>&#xA;</ol>&#xA;&#xA;<p>So for all the input text you've given above, it goes like this:</p>&#xA;&#xA;<p><strong>Browned fox</strong> => <code>b</code>, <code>br</code>, <code>bro</code>, <code>brow</code>, <code>brown</code>, <code>browne</code>, <code>browned</code>, <code>f</code>, <code>fo</code>, <code>fox</code></p>&#xA;&#xA;<p><strong>Brownish foxes</strong> => <code>b</code>, <code>br</code>, <code>bro</code>, <code>brow</code>, <code>brown</code>, <code>browni</code>, <code>brownis</code>, <code>brownish</code>, <code>f</code>, <code>fo</code>, <code>fox</code>, <code>foxe</code>, <code>foxes</code></p>&#xA;&#xA;<p><strong>Browny for</strong> => <code>b</code>, <code>br</code>, <code>bro</code>, <code>brow</code>, <code>brown</code>, <code>browny</code>, <code>f</code>, <code>fo</code>, <code>for</code></p>&#xA;&#xA;<p><strong>Brown fox</strong> => <code>b</code>, <code>br</code>, <code>bro</code>, <code>brow</code>, <code>brown</code>, <code>f</code>, <code>fo</code>, <code>fox</code></p>&#xA;&#xA;<p><strong>Brown fox tree</strong> => <code>b</code>, <code>br</code>, <code>bro</code>, <code>brow</code>, <code>brown</code>, <code>f</code>, <code>fo</code>, <code>fox</code>, <code>t</code>, <code>tr</code>, <code>tre</code>, <code>tree</code></p>&#xA;&#xA;<p>Now, when you search for <code>brown fo</code> using a <code>standard</code> analyzer, the search tokens will be: <code>brown</code> and <code>fo</code></p>&#xA;&#xA;<p>As you can see, the tokens <code>brown</code> and <code>fo</code> are present in <strong>all</strong> of the search terms above, so they are basically equivalent. The only thing that will influence the scoring (and thus the sort order) is whether the terms have been found in the <code>name</code> or <code>_alias</code> field (or both) and what <code>type</code> of field match you're using. Without seeing the concrete document it's hard to say, but you should definitely try to add <code>?explain=true</code> to your query to get more insights into how the scoring is being computed.</p>&#xA;