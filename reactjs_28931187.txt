28931187
Preserving state of removed components
<p>I see this patterns a lot when needing to add or remove a component when rendering based on some state (either in props or state).  Such as a tabbed UI, or an expand/collapse widget.</p>&#xA;&#xA;<pre><code>render: function() {&#xA;  if (this.state.show) {&#xA;    var showRender = &lt;Show /&gt;;&#xA;  } else {&#xA;    var showRender = &lt;Hidden /&gt;;&#xA;  }&#xA;&#xA;  return {showRender};&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>However, the problem is each time <code>this.state.show</code> changes, a new Show or Hidden is created.  The old state that might have existed in the previous instance of Show or some deep sub-component of Show is re-initialized.</p>&#xA;&#xA;<p>Moving state into the parent isn't practical when the state may exist in multiple components and sub-components.</p>&#xA;&#xA;<p>The other solution I can think of is to put the <code>"display: none"</code> style on the component I want to hide.  But if I apply this pattern everywhere, it feels expensive to create all of the UI even if it isn't seen.</p>&#xA;&#xA;<p>Adding the <code>key="someValue"</code> prop works as long as the component is just being moved and not completely removed.</p>&#xA;&#xA;<p>Are there any other patterns?</p>&#xA;
<p><a href="http://facebook.github.io/flux/docs/overview.html" rel="nofollow">Flux</a> architecture was recommended to deal with exactly this kind of dilemma. It frees up your components from the headache of passing around unmanageable amount of props by introducing the concepts of Stores and Dispatchers. Here's a list of tutorials on the subject: <a href="https://github.com/enaqx/awesome-react#flux-tutorials" rel="nofollow">https://github.com/enaqx/awesome-react#flux-tutorials</a></p>&#xA;&#xA;<p>Edit:</p>&#xA;&#xA;<p>I hadn't adopted Flux from the beginning for one of my rather complex apps, and now it's gonna be a big refactor to implement it (along with other improvements). As a stop gap, I started using an in-memory Message Bus pattern for new components. Mine is a custom implementation, but you could use a library like <a href="https://github.com/postaljs/postal.js" rel="nofollow">PostalJs</a>. In fact somebody is also attempting a <a href="https://github.com/postaljs/postal.react" rel="nofollow">PostalJs mixin for React</a>, which might be worth exploring. The idea is for components to publish messages to the Bus to announce actions, which can be consumed by interested components by subscribing via the same bus. The main difference from Flux is: there's no formal "Store", and the Message Bus is a glorified dispatcher. I avoided mentioning this earlier because it's a compromise for me in my current app, and Flux is a safer approach also because of the huge community involvement. Thanks to @FakeRainBrigand for encouraging me to share this other idea too.</p>&#xA;
<p>State is for ephemeral data.  If you need to persist this, manage it outside of the components, and use event emitters to allow the component to listen to changes and request changes be made.  The component binds it to state in getInitialState and the event listener.  This is okay, because it's just a local view of the data.  It's still kept safe externally.</p>&#xA;&#xA;<p>A more formal version of this is Flux, which Gaurav mentioned.  Sometimes simple event emitters are sufficient, and sometimes you really need the dispatcher, stores, and actions.</p>&#xA;