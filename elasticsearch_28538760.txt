28538760
elasticsearch bool query combine must with OR
<p>I am currently trying to migrate a solr-based application to elasticsearch.</p>&#xA;&#xA;<p>I have this lucene query</p>&#xA;&#xA;<pre><code>(( &#xA;    name:(+foo +bar) &#xA;    OR info:(+foo +bar) &#xA;)) AND state:(1) AND (has_image:(0) OR has_image:(1)^100)&#xA;</code></pre>&#xA;&#xA;<p>As far as I understand this is a combination of MUST clauses combined with boolean OR: </p>&#xA;&#xA;<p>"Get all documents containing (foo AND bar in name) OR (foo AND bar in info). After that filter results by condition state=1 and boost documents that have an image."</p>&#xA;&#xA;<p>I have been trying to use a bool query with MUST but I am failing to get boolean OR into must clauses. Here is what I have:</p>&#xA;&#xA;<pre><code>GET /test/object/_search&#xA;{&#xA;  "from": 0,&#xA;  "size": 20,&#xA;  "sort": {&#xA;    "_score": "desc"&#xA;  },&#xA;  "query": {&#xA;    "bool": {&#xA;      "must": [&#xA;        {&#xA;          "match": {&#xA;            "name": "foo"&#xA;          }&#xA;        },&#xA;        {&#xA;          "match": {&#xA;            "name": "bar"&#xA;          }&#xA;        }&#xA;      ],&#xA;      "must_not": [],&#xA;      "should": [&#xA;        {&#xA;          "match": {&#xA;            "has_image": {&#xA;              "query": 1,&#xA;              "boost": 100&#xA;            }&#xA;          }&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>As you can see, MUST conditions for "info" are missing.</p>&#xA;&#xA;<p>Does anyone have a solution?</p>&#xA;&#xA;<p>Thank you so much.</p>&#xA;&#xA;<p>** UPDATE **</p>&#xA;&#xA;<p>I have updated my elasticsearch query and got rid of that function score. My base problem still exists.</p>&#xA;
<p>I finally managed to create a query that does exactly what i wanted to have:</p>&#xA;&#xA;<p>A filtered nested boolean query.&#xA;I am not sure why this is not documented. Maybe someone here can tell me?</p>&#xA;&#xA;<p>Here is the query:</p>&#xA;&#xA;<pre><code>GET /test/object/_search&#xA;{&#xA;  "from": 0,&#xA;  "size": 20,&#xA;  "sort": {&#xA;    "_score": "desc"&#xA;  },&#xA;  "query": {&#xA;    "filtered": {&#xA;      "filter": {&#xA;        "bool": {&#xA;          "must": [&#xA;            {&#xA;              "term": {&#xA;                "state": 1&#xA;              }&#xA;            }&#xA;          ]&#xA;        }&#xA;      },&#xA;      "query": {&#xA;        "bool": {&#xA;          "should": [&#xA;            {&#xA;              "bool": {&#xA;                "must": [&#xA;                  {&#xA;                    "match": {&#xA;                      "name": "foo"&#xA;                    }&#xA;                  },&#xA;                  {&#xA;                    "match": {&#xA;                      "name": "bar"&#xA;                    }&#xA;                  }&#xA;                ],&#xA;                "should": [&#xA;                  {&#xA;                    "match": {&#xA;                      "has_image": {&#xA;                        "query": 1,&#xA;                        "boost": 100&#xA;                      }&#xA;                    }&#xA;                  }&#xA;                ]&#xA;              }&#xA;            },&#xA;            {&#xA;              "bool": {&#xA;                "must": [&#xA;                  {&#xA;                    "match": {&#xA;                      "info": "foo"&#xA;                    }&#xA;                  },&#xA;                  {&#xA;                    "match": {&#xA;                      "info": "bar"&#xA;                    }&#xA;                  }&#xA;                ],&#xA;                "should": [&#xA;                  {&#xA;                    "match": {&#xA;                      "has_image": {&#xA;                        "query": 1,&#xA;                        "boost": 100&#xA;                      }&#xA;                    }&#xA;                  }&#xA;                ]&#xA;              }&#xA;            }&#xA;          ],&#xA;          "minimum_should_match": 1&#xA;        }&#xA;      }    &#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>In pseudo-SQL:</p>&#xA;&#xA;<pre><code>SELECT * FROM /test/object&#xA;WHERE &#xA;    ((name=foo AND name=bar) OR (info=foo AND info=bar))&#xA;AND state=1&#xA;</code></pre>&#xA;&#xA;<p>Please keep in mind that it depends on your document field analysis and mappings how name=foo is internally handled. This can vary from a fuzzy to strict behavior.</p>&#xA;&#xA;<p>"minimum_should_match": 1 says, that at least one of the should statements must be true.</p>&#xA;&#xA;<p>This statements means that whenever there is a document in the resultset that contains has_image:1 it is boosted by factor 100. This changes result ordering.</p>&#xA;&#xA;<pre><code>"should": [&#xA;  {&#xA;    "match": {&#xA;      "has_image": {&#xA;        "query": 1,&#xA;        "boost": 100&#xA;      }&#xA;    }&#xA;   }&#xA; ]&#xA;</code></pre>&#xA;&#xA;<p>Have fun guys :)</p>&#xA;
<p>I recently had to solve this problem too, and after a LOT of trial and error I came up with this (in PHP, but maps directly to the DSL):</p>&#xA;&#xA;<pre><code>'query' =&gt; [&#xA;    'bool' =&gt; [&#xA;        'should' =&gt; [&#xA;            ['prefix' =&gt; ['name_first' =&gt; $query]],&#xA;            ['prefix' =&gt; ['name_last' =&gt; $query]],&#xA;            ['prefix' =&gt; ['phone' =&gt; $query]],&#xA;            ['prefix' =&gt; ['email' =&gt; $query]],&#xA;            [&#xA;                'multi_match' =&gt; [&#xA;                    'query' =&gt; $query,&#xA;                    'type' =&gt; 'cross_fields',&#xA;                    'operator' =&gt; 'and',&#xA;                    'fields' =&gt; ['name_first', 'name_last']&#xA;                ]&#xA;            ]&#xA;        ],&#xA;        'minimum_should_match' =&gt; 1,&#xA;        'filter' =&gt; [&#xA;            ['term' =&gt; ['state' =&gt; 'active']],&#xA;            ['term' =&gt; ['company_id' =&gt; $companyId]]&#xA;        ]&#xA;    ]&#xA;]&#xA;</code></pre>&#xA;&#xA;<p>Which maps to something like this in SQL:</p>&#xA;&#xA;<pre><code>SELECT * from &lt;index&gt; &#xA;WHERE (&#xA;    name_first LIKE '&lt;query&gt;%' OR&#xA;    name_last LIKE '&lt;query&gt;%' OR&#xA;    phone LIKE  '&lt;query&gt;%' OR&#xA;    email LIKE '&lt;query&gt;%'&#xA;)&#xA;AND state = 'active'&#xA;AND company_id = &lt;query&gt;&#xA;</code></pre>&#xA;&#xA;<p>The key in all this is the <code>minimum_should_match</code> setting. Without this the <code>filter</code> totally overrides the <code>should</code>. </p>&#xA;&#xA;<p>Hope this helps someone!</p>&#xA;
<ul>&#xA;<li>OR is spelled "should"</li>&#xA;<li>AND is spelled "must"</li>&#xA;<li>NOR is spelled "should_not"</li>&#xA;</ul>&#xA;&#xA;<p>Example:</p>&#xA;&#xA;<p>You want to see all the items that are (round AND (red OR blue)):</p>&#xA;&#xA;<pre><code>{&#xA;    "query": {&#xA;        "bool": {&#xA;            "must": [&#xA;                {&#xA;                    "term": {"shape": "round"},&#xA;                    "bool": {&#xA;                        "should": [&#xA;                            {"term": {"color": "red"}},&#xA;                            {"term": {"color": "blue"}}&#xA;                        ]&#xA;                    }&#xA;                }&#xA;            ]&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>You can also do more complex versions of OR, for example if you want to match at least 3 out of 5, you can specify 5 options under "should" and set a "minimum_should" of 3.</p>&#xA;
<p>Using the above I get </p>&#xA;&#xA;<p><code>[term] malformed query, expected [END_OBJECT] but found [FIELD_NAME]</code></p>&#xA;&#xA;<p>This worked for me</p>&#xA;&#xA;<p>Updated for Elasticsearch 5.6.4 +</p>&#xA;&#xA;<pre><code>{&#xA;    "query": {&#xA;        "bool": {&#xA;            "must": [&#xA;                {"term": {"shape": "round"}},&#xA;                {"bool": {&#xA;                    "should": [&#xA;                        {"term": {"color": "red"}},&#xA;                        {"term": {"color": "blue"}}&#xA;                    ]&#xA;                }}&#xA;            ]&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;
<pre><code>$filterQuery = $this-&gt;queryFactory-&gt;create(QueryInterface::TYPE_BOOL, ['must' =&gt; $queries,'should'=&gt;$queriesGeo]);&#xA;</code></pre>&#xA;&#xA;<p>In <code>must</code> you need to add the query condition array which you want to work with <code>AND</code> and in <code>should</code> you need to add the query condition which you want to work with <code>OR</code>.</p>&#xA;&#xA;<p>You can check this: <a href="https://github.com/Smile-SA/elasticsuite/issues/972" rel="nofollow noreferrer">https://github.com/Smile-SA/elasticsuite/issues/972</a></p>&#xA;
<p>ElasticSearch is definitely horrible when it comes to simple queries like AND, OR or IN. But, you can go the smart way and write your query as SQL and then convert it to ElasticSearch syntax with this excellent online tool:</p>&#xA;&#xA;<p><strong>SQL to ElasticSearch converter</strong></p>&#xA;&#xA;<p><a href="https://www.toolsbuzz.com/query-converter" rel="nofollow noreferrer">https://www.toolsbuzz.com/query-converter</a></p>&#xA;&#xA;<p>You can thank me later :)</p>&#xA;