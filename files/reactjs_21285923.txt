21285923
ReactJS Two components communicating
<p>I just got started with ReactJS and am a little stuck on a problem that I have.</p>&#xA;&#xA;<p>My application is essentially a list with filters and a button to change the layout.&#xA;At the moment I'm using three components: <code>&lt;list /&gt;</code>, <code>&lt; Filters /&gt;</code> and <code>&lt;TopBar /&gt;</code>, now obviously when I change settings in <code>&lt; Filters /&gt;</code> I want to trigger some method in <code>&lt;list /&gt;</code> to update my view.</p>&#xA;&#xA;<p>How can I make those 3 components interact with each other, or do I need some sort of global data model where I can just make changes to?</p>&#xA;
<p>The best approach would depend on how you plan to arrange those components. A few example scenarios that come to mind right now:</p>&#xA;&#xA;<ol>&#xA;<li><code>&lt;Filters /&gt;</code> is a child component of <code>&lt;List /&gt;</code></li>&#xA;<li>Both <code>&lt;Filters /&gt;</code> and <code>&lt;List /&gt;</code> are children of a parent component</li>&#xA;<li><code>&lt;Filters /&gt;</code> and <code>&lt;List /&gt;</code> live in separate root components entirely.</li>&#xA;</ol>&#xA;&#xA;<p>There may be other scenarios that I'm not thinking of. If yours doesn't fit within these, then let me know. Here are some very rough examples of how I've been handling the first two scenarios:</p>&#xA;&#xA;<h2>Scenario #1</h2>&#xA;&#xA;<p>You could pass a handler from <code>&lt;List /&gt;</code> to <code>&lt;Filters /&gt;</code>, which could then be called on the <code>onChange</code> event to filter the list with the current value.</p>&#xA;&#xA;<p><a href="http://jsfiddle.net/iamlacroix/FPc9M/">JSFiddle for #1 &rarr;</a></p>&#xA;&#xA;<pre class="lang-js prettyprint-override"><code>/** @jsx React.DOM */&#xA;&#xA;var Filters = React.createClass({&#xA;  handleFilterChange: function() {&#xA;    var value = this.refs.filterInput.getDOMNode().value;&#xA;    this.props.updateFilter(value);&#xA;  },&#xA;  render: function() {&#xA;    return &lt;input type="text" ref="filterInput" onChange={this.handleFilterChange} placeholder="Filter" /&gt;;&#xA;  }&#xA;});&#xA;&#xA;var List = React.createClass({&#xA;  getInitialState: function() {&#xA;    return {&#xA;      listItems: ['Chicago', 'New York', 'Tokyo', 'London', 'San Francisco', 'Amsterdam', 'Hong Kong'],&#xA;      nameFilter: ''&#xA;    };&#xA;  },&#xA;  handleFilterUpdate: function(filterValue) {&#xA;    this.setState({&#xA;      nameFilter: filterValue&#xA;    });&#xA;  },&#xA;  render: function() {&#xA;    var displayedItems = this.state.listItems.filter(function(item) {&#xA;      var match = item.toLowerCase().indexOf(this.state.nameFilter.toLowerCase());&#xA;      return (match !== -1);&#xA;    }.bind(this));&#xA;&#xA;    var content;&#xA;    if (displayedItems.length &gt; 0) {&#xA;      var items = displayedItems.map(function(item) {&#xA;        return &lt;li&gt;{item}&lt;/li&gt;;&#xA;      });&#xA;      content = &lt;ul&gt;{items}&lt;/ul&gt;&#xA;    } else {&#xA;      content = &lt;p&gt;No items matching this filter&lt;/p&gt;;&#xA;    }&#xA;&#xA;    return (&#xA;      &lt;div&gt;&#xA;        &lt;Filters updateFilter={this.handleFilterUpdate} /&gt;&#xA;        &lt;h4&gt;Results&lt;/h4&gt;&#xA;        {content}&#xA;      &lt;/div&gt;&#xA;    );&#xA;  }&#xA;});&#xA;&#xA;React.renderComponent(&lt;List /&gt;, document.body);&#xA;</code></pre>&#xA;&#xA;<hr>&#xA;&#xA;<h2>Scenario #2</h2>&#xA;&#xA;<p>Similar to scenario #1, but the parent component will be the one passing down the handler function to <code>&lt;Filters /&gt;</code>, and will pass the filtered list to <code>&lt;List /&gt;</code>. I like this method better since it decouples the <code>&lt;List /&gt;</code> from the <code>&lt;Filters /&gt;</code>.</p>&#xA;&#xA;<p><a href="http://jsfiddle.net/iamlacroix/REg8Q/">JSFiddle for #2 &rarr;</a></p>&#xA;&#xA;<pre class="lang-js prettyprint-override"><code>/** @jsx React.DOM */&#xA;&#xA;var Filters = React.createClass({&#xA;  handleFilterChange: function() {&#xA;    var value = this.refs.filterInput.getDOMNode().value;&#xA;    this.props.updateFilter(value);&#xA;  },&#xA;  render: function() {&#xA;    return &lt;input type="text" ref="filterInput" onChange={this.handleFilterChange} placeholder="Filter" /&gt;;&#xA;  }&#xA;});&#xA;&#xA;var List = React.createClass({&#xA;  render: function() {&#xA;    var content;&#xA;    if (this.props.items.length &gt; 0) {&#xA;      var items = this.props.items.map(function(item) {&#xA;        return &lt;li&gt;{item}&lt;/li&gt;;&#xA;      });&#xA;      content = &lt;ul&gt;{items}&lt;/ul&gt;&#xA;    } else {&#xA;      content = &lt;p&gt;No items matching this filter&lt;/p&gt;;&#xA;    }&#xA;    return (&#xA;      &lt;div className="results"&gt;&#xA;        &lt;h4&gt;Results&lt;/h4&gt;&#xA;        {content}&#xA;      &lt;/div&gt;&#xA;    );&#xA;  }&#xA;});&#xA;&#xA;var ListContainer = React.createClass({&#xA;  getInitialState: function() {&#xA;    return {&#xA;      listItems: ['Chicago', 'New York', 'Tokyo', 'London', 'San Francisco', 'Amsterdam', 'Hong Kong'],&#xA;      nameFilter: ''&#xA;    };&#xA;  },&#xA;  handleFilterUpdate: function(filterValue) {&#xA;    this.setState({&#xA;      nameFilter: filterValue&#xA;    });&#xA;  },&#xA;  render: function() {&#xA;    var displayedItems = this.state.listItems.filter(function(item) {&#xA;      var match = item.toLowerCase().indexOf(this.state.nameFilter.toLowerCase());&#xA;      return (match !== -1);&#xA;    }.bind(this));&#xA;&#xA;    return (&#xA;      &lt;div&gt;&#xA;        &lt;Filters updateFilter={this.handleFilterUpdate} /&gt;&#xA;        &lt;List items={displayedItems} /&gt;&#xA;      &lt;/div&gt;&#xA;    );&#xA;  }&#xA;});&#xA;&#xA;React.renderComponent(&lt;ListContainer /&gt;, document.body);&#xA;</code></pre>&#xA;&#xA;<hr>&#xA;&#xA;<h2>Scenario #3</h2>&#xA;&#xA;<p>When the components can't communicate between any sort of parent-child relationship, the <a href="http://facebook.github.io/react/tips/communicate-between-components.html">documentation recommends setting up a global event system</a>.</p>&#xA;
<p>This is the way I handled this.<br>&#xA;Let's say you have a &lt;select&gt; for <strong>Month</strong> and a &lt;select&gt; for <strong>Day</strong>.&#xA;The number of days depends on the selected month.</p>&#xA;&#xA;<p>Both lists are owned by a third object, the left panel. Both &lt;select&gt; are also children of the leftPanel &lt;div&gt;<br>&#xA;It's a game with the callbacks and the handlers in the <em>LeftPanel</em> component.</p>&#xA;&#xA;<p>To test it, just copy the code into two separated files and run the <em>index.html</em>. Then select a month and see how the number of days changes.</p>&#xA;&#xA;<p><strong>dates.js</strong></p>&#xA;&#xA;<pre class="lang-jsx prettyprint-override"><code>    /** @jsx React.DOM */&#xA;&#xA;&#xA;    var monthsLength = [0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];&#xA;    var MONTHS_ARR = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];&#xA;&#xA;    var DayNumber = React.createClass({&#xA;        render: function() {&#xA;            return (&#xA;                &lt;option value={this.props.dayNum}&gt;{this.props.dayNum}&lt;/option&gt;&#xA;            );&#xA;        }&#xA;    });&#xA;&#xA;    var DaysList = React.createClass({&#xA;        getInitialState: function() {&#xA;            return {numOfDays: 30};&#xA;        },&#xA;        handleMonthUpdate: function(newMonthix) {&#xA;            this.state.numOfDays = monthsLength[newMonthix];&#xA;            console.log("Setting days to " + monthsLength[newMonthix] + " month = " + newMonthix);&#xA;&#xA;            this.forceUpdate();&#xA;        },&#xA;        handleDaySelection: function(evt) {&#xA;            this.props.dateHandler(evt.target.value);&#xA;        },&#xA;        componentDidMount: function() {&#xA;            this.props.readyCallback(this.handleMonthUpdate)&#xA;        },&#xA;        render: function() {&#xA;            var dayNodes = [];&#xA;            for (i = 1; i &lt;= this.state.numOfDays; i++) {&#xA;                dayNodes = dayNodes.concat([&lt;DayNumber dayNum={i} /&gt;]);&#xA;            }&#xA;            return (&#xA;                &lt;select id={this.props.id} onChange = {this.handleDaySelection}&gt;&#xA;                    &lt;option value="" disabled defaultValue&gt;Day&lt;/option&gt;&#xA;                        {dayNodes}&#xA;                &lt;/select&gt;&#xA;                );&#xA;        }&#xA;    });&#xA;&#xA;    var Month = React.createClass({&#xA;        render: function() {&#xA;            return (&#xA;                &lt;option value={this.props.monthIx}&gt;{this.props.month}&lt;/option&gt;&#xA;            );&#xA;        }&#xA;    });&#xA;&#xA;    var MonthsList = React.createClass({&#xA;        handleUpdate: function(evt) {&#xA;            console.log("Local handler:" + this.props.id + " VAL= " + evt.target.value);&#xA;            this.props.dateHandler(evt.target.value);&#xA;&#xA;            return false;&#xA;        },&#xA;        render: function() {&#xA;            var monthIx = 0;&#xA;&#xA;            var monthNodes = this.props.data.map(function (month) {&#xA;                monthIx++;&#xA;                return (&#xA;                    &lt;Month month={month} monthIx={monthIx} /&gt;&#xA;                    );&#xA;            });&#xA;&#xA;            return (&#xA;                &lt;select id = {this.props.id} onChange = {this.handleUpdate}&gt;&#xA;                    &lt;option value="" disabled defaultValue&gt;Month&lt;/option&gt;&#xA;                        {monthNodes}&#xA;                &lt;/select&gt;&#xA;                );&#xA;        }&#xA;    });&#xA;&#xA;    var LeftPanel = React.createClass({&#xA;        dayRefresh: function(newMonth) {&#xA;            // Nothing - will be replaced&#xA;        },&#xA;        daysReady: function(refreshCallback) {&#xA;            console.log("Regisering days list");&#xA;        this.dayRefresh = refreshCallback;&#xA;        },&#xA;        handleMonthChange: function(monthIx) {&#xA;            console.log("New month");&#xA;            this.dayRefresh(monthIx);&#xA;        },&#xA;        handleDayChange: function(dayIx) {&#xA;            console.log("New DAY: " + dayIx);&#xA;        },&#xA;        render: function() {&#xA;            return(&#xA;                &lt;div id="orderDetails"&gt;&#xA;                    &lt;DaysList id="dayPicker" dateHandler={this.handleDayChange} readyCallback = {this.daysReady} /&gt;&#xA;                    &lt;MonthsList data={MONTHS_ARR} id="monthPicker" dateHandler={this.handleMonthChange}  /&gt;&#xA;                &lt;/div&gt;&#xA;            );&#xA;        }&#xA;    });&#xA;&#xA;&#xA;&#xA;    React.renderComponent(&#xA;        &lt;LeftPanel /&gt;,&#xA;        document.getElementById('leftPanel')&#xA;    );&#xA;</code></pre>&#xA;&#xA;<p>And the HTML for running the left panel component&#xA;<strong>index.html</strong></p>&#xA;&#xA;<pre class="lang-html prettyprint-override"><code>&lt;!DOCTYPE html&gt;&#xA;&lt;html&gt;&#xA;&lt;head&gt;&#xA;    &lt;title&gt;Dates&lt;/title&gt;&#xA;&#xA;    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js"&gt;&lt;/script&gt;&#xA;    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/underscore.js/1.6.0/underscore-min.js"&gt;&lt;/script&gt;&#xA;    &lt;script src="//fb.me/react-0.11.1.js"&gt;&lt;/script&gt;&#xA;    &lt;script src="//fb.me/JSXTransformer-0.11.1.js"&gt;&lt;/script&gt;&#xA;&lt;/head&gt;&#xA;&#xA;    &lt;style&gt;&#xA;&#xA;        #dayPicker {&#xA;            position: relative;&#xA;            top: 97px;&#xA;            left: 20px;&#xA;            width: 60px;&#xA;            height: 17px;&#xA;        }&#xA;&#xA;        #monthPicker {&#xA;            position: relative;&#xA;            top: 97px;&#xA;            left: 22px;&#xA;            width: 95px;&#xA;            height: 17px;&#xA;        }&#xA;&#xA;        select {&#xA;            font-size: 11px;&#xA;        }&#xA;&#xA;    &lt;/style&gt;&#xA;&#xA;&#xA;    &lt;body&gt;&#xA;        &lt;div id="leftPanel"&gt;&#xA;        &lt;/div&gt;&#xA;&#xA;        &lt;script type="text/jsx" src="dates.js"&gt;&lt;/script&gt;&#xA;&#xA;    &lt;/body&gt;&#xA;&lt;/html&gt;&#xA;</code></pre>&#xA;
<p>There are multiple ways to make components communicate. Some can be suited to your usecase. Here is a list of some I've found useful to know.</p>&#xA;&#xA;<h1>React</h1>&#xA;&#xA;<h3>Parent / Child direct communication</h3>&#xA;&#xA;<pre><code>const Child = ({fromChildToParentCallback}) =&gt; (&#xA;  &lt;div onClick={() =&gt; fromChildToParentCallback(42)}&gt;&#xA;    Click me&#xA;  &lt;/div&gt;&#xA;);&#xA;&#xA;class Parent extends React.Component {&#xA;  receiveChildValue = (value) =&gt; {&#xA;    console.log("Parent received value from child: " + value); // value is 42&#xA;  };&#xA;  render() {&#xA;    return (&#xA;      &lt;Child fromChildToParentCallback={this.receiveChildValue}/&gt;&#xA;    )&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Here the child component will call a callback provided by the parent with a value, and the parent will be able to get the value provided by the children in the parent.</p>&#xA;&#xA;<p>If you build a feature/page of your app, it's better to have a single parent managing the callbacks/state (also called <code>container</code> or <code>smart component</code>), and all childs to be stateless, only reporting things to the parent. This way you can easily "share" the state of the parent to any child that need it.</p>&#xA;&#xA;<hr>&#xA;&#xA;<h3>Context</h3>&#xA;&#xA;<p>React Context permits to hold state at the root of your component hierarchy, and be able to inject this state easily into very deeply nested components, without the hassle to have to pass down props to every intermediate components.</p>&#xA;&#xA;<p>Until now, context was an experimental feature, but a new API is available in React 16.3. </p>&#xA;&#xA;<pre><code>const AppContext = React.createContext(null)&#xA;&#xA;class App extends React.Component {&#xA;  render() {&#xA;    return (&#xA;      &lt;AppContext.Provider value={{language: "en",userId: 42}}&gt;&#xA;        &lt;div&gt;&#xA;          ...&#xA;          &lt;SomeDeeplyNestedComponent/&gt;&#xA;          ...&#xA;        &lt;/div&gt;&#xA;      &lt;/AppContext.Provider&gt;&#xA;    )&#xA;  }&#xA;};&#xA;&#xA;const SomeDeeplyNestedComponent = () =&gt; (&#xA;  &lt;AppContext.Consumer&gt;&#xA;    {({language}) =&gt; &lt;div&gt;App language is currently {language}&lt;/div&gt;}&#xA;  &lt;/AppContext.Consumer&gt;&#xA;);&#xA;</code></pre>&#xA;&#xA;<p>The consumer is using the <a href="https://stackoverflow.com/a/31564812/82609">render prop / children function pattern</a></p>&#xA;&#xA;<p>Check this <a href="https://medium.com/dailyjs/reacts-%EF%B8%8F-new-context-api-70c9fe01596b" rel="nofollow noreferrer">blog post</a> for more details.</p>&#xA;&#xA;<p>Before React 16.3, I'd recommend using <a href="https://github.com/ReactTraining/react-broadcast" rel="nofollow noreferrer">react-broadcast</a> which offer quite similar API, and use former context API.</p>&#xA;&#xA;<hr>&#xA;&#xA;<h3>Portals</h3>&#xA;&#xA;<p>Use a portal when you'd like to keep 2 components close together to make them communicate with simple functions, like in normal parent / child, but you don't want these 2 components to have a parent/child relationship in the DOM, because of visual / CSS constraints it implies (like z-index, opacity...).</p>&#xA;&#xA;<p>In this case you can use a "portal". There are different react libraries using <a href="https://github.com/tajo/react-portal" rel="nofollow noreferrer">portals</a>, usually used for <a href="https://github.com/rackt/react-modal" rel="nofollow noreferrer">modals</a>, popups, tooltips... </p>&#xA;&#xA;<p>Consider the following:</p>&#xA;&#xA;<pre><code>&lt;div className="a"&gt;&#xA;    a content&#xA;    &lt;Portal target="body"&gt;&#xA;        &lt;div className="b"&gt;&#xA;            b content&#xA;        &lt;/div&gt;&#xA;    &lt;/Portal&gt;&#xA;&lt;/div&gt;&#xA;</code></pre>&#xA;&#xA;<p>Could produce the following DOM when rendered inside <code>reactAppContainer</code>:</p>&#xA;&#xA;<pre><code>&lt;body&gt;&#xA;    &lt;div id="reactAppContainer"&gt;&#xA;        &lt;div className="a"&gt;&#xA;             a content&#xA;        &lt;/div&gt;&#xA;    &lt;/div&gt;&#xA;    &lt;div className="b"&gt;&#xA;         b content&#xA;    &lt;/div&gt;&#xA;&lt;/body&gt;&#xA;</code></pre>&#xA;&#xA;<p><a href="https://stackoverflow.com/a/39828187/82609">More details here</a></p>&#xA;&#xA;<hr>&#xA;&#xA;<h1>Event bus</h1>&#xA;&#xA;<p>As stated in the React <a href="http://facebook.github.io/react/tips/communicate-between-components.html" rel="nofollow noreferrer">documentation</a>:</p>&#xA;&#xA;<blockquote>&#xA;  <p>For communication between two components that don't have a parent-child relationship, you can set up your own global event system. Subscribe to events in componentDidMount(), unsubscribe in componentWillUnmount(), and call setState() when you receive an event.</p>&#xA;</blockquote>&#xA;&#xA;<p>There are many things you can use to setup an event bus. You can just create an array of listeners, and on event publish, all listeners would receive the event. Or you can use something like <a href="https://github.com/Olical/EventEmitter" rel="nofollow noreferrer">EventEmitter</a> or <a href="https://github.com/postaljs/postal.js" rel="nofollow noreferrer">PostalJs</a></p>&#xA;&#xA;<hr>&#xA;&#xA;<h1>Flux</h1>&#xA;&#xA;<p><a href="https://facebook.github.io/flux/" rel="nofollow noreferrer">Flux</a> is basically an event bus, except the event receivers are stores. This is similar to the basic event bus system except the state is managed outside of React</p>&#xA;&#xA;<p>Original Flux implementation looks like an attempt to do Event-sourcing in a hacky way.</p>&#xA;&#xA;<p><a href="https://github.com/rackt/redux" rel="nofollow noreferrer">Redux</a> is for me the Flux implementation that is the closest from event-sourcing, an benefits many of event-sourcing advantages like the ability to time-travel. It is not strictly linked to React and can also be used with other functional view libraries.</p>&#xA;&#xA;<p>Egghead's Redux <a href="https://egghead.io/series/getting-started-with-redux" rel="nofollow noreferrer">video tutorial</a> is really nice and explains how it works internally (it really is simple).</p>&#xA;&#xA;<hr>&#xA;&#xA;<h1>Cursors</h1>&#xA;&#xA;<p>Cursors are coming from <a href="https://www.youtube.com/watch?v=DMtwq3QtddY" rel="nofollow noreferrer">ClojureScript/Om</a> and widely used in React projects. They permit to manage the state outside of React, and let multiple components have read/write access to the same part of the state, without needing to know anything about the component tree.</p>&#xA;&#xA;<p>Many implementations exists, including <a href="https://github.com/facebook/immutable-js/tree/master/contrib/cursor" rel="nofollow noreferrer">ImmutableJS</a>, <a href="https://github.com/dustingetz/react-cursor" rel="nofollow noreferrer">React-cursors</a> and <a href="https://github.com/omniscientjs/omniscient" rel="nofollow noreferrer">Omniscient</a></p>&#xA;&#xA;<p><strong>Edit 2016</strong>: it seems that people agree cursors work fine for smaller apps but it does not scale well on complex apps. Om Next does not have cursors anymore (while it's Om that introduced the concept initially)</p>&#xA;&#xA;<hr>&#xA;&#xA;<h1>Elm architecture</h1>&#xA;&#xA;<p>The <a href="https://github.com/evancz/elm-architecture-tutorial" rel="nofollow noreferrer">Elm architecture</a> is an architecture proposed to be used by the <a href="http://elm-lang.org/" rel="nofollow noreferrer">Elm language</a>. Even if Elm is not ReactJS, the Elm architecture can be done in React as well.</p>&#xA;&#xA;<p>Dan Abramov, the author of Redux, did an <a href="https://github.com/gaearon/react-elmish-example" rel="nofollow noreferrer">implementation</a> of the Elm architecture using React.</p>&#xA;&#xA;<p>Both Redux and Elm are really great and tend to empower event-sourcing concepts on the frontend, both allowing time-travel debugging, undo/redo, replay...</p>&#xA;&#xA;<p>The main difference between Redux and Elm is that Elm tend to be a lot more strict about state management. In Elm you can't have local component state or mount/unmount hooks and all DOM changes must be triggered by global state changes. Elm architecture propose a scalable approach that permits to handle <strong>ALL</strong> the state inside a single immutable object, while Redux propose an approach that invites you to handle <strong>MOST</strong> of the state in a single immutable object.</p>&#xA;&#xA;<p>While the conceptual model of Elm is very elegant and the architecture permits to scale well on large apps, it can in practice be difficult or involve more boilerplate to achieve simple tasks like giving focus to an input after mounting it, or integrating with an existing library with an imperative interface (ie JQuery plugin). <a href="https://github.com/evancz/elm-architecture-tutorial/issues/49" rel="nofollow noreferrer">Related issue</a>.</p>&#xA;&#xA;<p>Also, Elm architecture involves more code boilerplate. It's not that verbose or complicated to write but I think the Elm architecture is more suited to statically typed languages.</p>&#xA;&#xA;<hr>&#xA;&#xA;<h1>FRP</h1>&#xA;&#xA;<p>Libraries like RxJS, BaconJS or Kefir can be used to produce FRP streams to handle communication between components.</p>&#xA;&#xA;<p>You can try for example <a href="https://github.com/fdecampredon/rx-react" rel="nofollow noreferrer">Rx-React</a></p>&#xA;&#xA;<p>I think using these libs is quite similar to using what the ELM language offers with <a href="http://elm-lang.org/guide/reactivity#signals" rel="nofollow noreferrer">signals</a>.</p>&#xA;&#xA;<p><a href="https://github.com/cyclejs" rel="nofollow noreferrer">CycleJS</a> framework does not use ReactJS but uses <a href="https://github.com/Matt-Esch/vdom" rel="nofollow noreferrer">vdom</a>. It share a lot of similarities with the Elm architecture (but is more easy to use in real life because it allows vdom hooks) and it uses RxJs extensively instead of functions, and can be a good source of inspiration if you want to use FRP with React. <a href="https://egghead.io/series/cycle-js-fundamentals" rel="nofollow noreferrer">CycleJs Egghead videos</a> are nice to understand how it works.</p>&#xA;&#xA;<hr>&#xA;&#xA;<h1>CSP</h1>&#xA;&#xA;<p>CSP (Communicating Sequential Processes) are currently popular (mostly because of Go/goroutines and core.async/ClojureScript) but you can use them also in javascript with <a href="https://github.com/ubolonton/js-csp" rel="nofollow noreferrer">JS-CSP</a>.</p>&#xA;&#xA;<p>James Long has done a <a href="https://www.youtube.com/watch?v=W2DgDNQZOwo" rel="nofollow noreferrer">video</a> explaining how it can be used with React.</p>&#xA;&#xA;<h1>Sagas</h1>&#xA;&#xA;<p>A saga is a backend concept that comes from the DDD / EventSourcing / CQRS world, also called "process manager". &#xA;It is being popularized by the <a href="https://github.com/yelouafi/redux-saga" rel="nofollow noreferrer">redux-saga</a> project, mostly as a replacement to redux-thunk for handling side-effects (ie API calls etc). Most people currently think it only services for side-effects but it is actually more about decoupling components. </p>&#xA;&#xA;<p>It is more of a compliment to a Flux architecture (or Redux) than a totally new communication system, because the saga emit Flux actions at the end. The idea is that if you have widget1 and widget2, and you want them to be decoupled, you can't fire action targeting widget2 from widget1. So you make widget1 only fire actions that target itself, and the saga is a "background process" that listens for widget1 actions, and may dispatch actions that target widget2. The saga is the coupling point between the 2 widgets but the widgets remain decoupled.</p>&#xA;&#xA;<p>If you are interested take a look at <a href="https://stackoverflow.com/questions/34570758/why-do-we-need-middleware-for-async-flow-in-redux/34623840#34623840">my answer here</a></p>&#xA;&#xA;<hr>&#xA;&#xA;<h1>Conclusion</h1>&#xA;&#xA;<p>If you want to see an example of the same little app using these different styles, check the branches of this <a href="https://github.com/DjebbZ/react-meetup-data-flow" rel="nofollow noreferrer">repository</a>. </p>&#xA;&#xA;<p>I don't know what is the best option in the long term but I really like how Flux looks like event-sourcing. </p>&#xA;&#xA;<p>If you don't know event-sourcing concepts, take a look at this very pedagogic blog: <a href="http://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/" rel="nofollow noreferrer">Turning the database inside out with apache Samza</a>, it is a must-read to understand why Flux is nice (but this could apply to FRP as well)</p>&#xA;&#xA;<p>I think the community agrees that the most promising Flux implementation is <a href="https://github.com/gaearon/redux" rel="nofollow noreferrer">Redux</a>, which will progressively allow very productive developer experience thanks to hot reloading. Impressive livecoding ala Bret Victor's <a href="https://stackoverflow.com/questions/9448215/tools-to-support-live-coding-as-in-bret-victors-inventing-on-principle-talk/31388262#31388262">Inventing on Principle video</a> is possible!</p>&#xA;
<p>There is such possibility even if they are not Parent - Child relationship - and that's Flux. There is pretty good (for me personally) implementation for that called Alt.JS (with Alt-Container).</p>&#xA;&#xA;<p>For example you can have Sidebar that is dependent on what is set in component Details. Component Sidebar is connected with SidebarActions and SidebarStore, while Details is DetailsActions and DetailsStore.</p>&#xA;&#xA;<p>You could use then AltContainer like that</p>&#xA;&#xA;<pre><code>&lt;AltContainer stores={{&#xA;                    SidebarStore: SidebarStore&#xA;                }}&gt;&#xA;                    &lt;Sidebar/&gt;&#xA;&lt;/AltContainer&gt;&#xA;&#xA;{this.props.content}&#xA;</code></pre>&#xA;&#xA;<p>Which would keep stores (well I could use "store" instead of "stores" prop). Now, {this.props.content} CAN BE Details depending on the route. Lets say that /Details redirect us to that view.&#xA;Details would have for example a checkbox that would change Sidebar element from X to Y if it would be checked.</p>&#xA;&#xA;<p>Technically there is no relationship between them and it would be hard to do without flux. BUT WITH THAT it is rather easy.</p>&#xA;&#xA;<p>Now let's get to DetailsActions. We will create there</p>&#xA;&#xA;<pre><code>class SiteActions {&#xA;constructor() {&#xA;    this.generateActions(&#xA;        'setSiteComponentStore'&#xA;    );&#xA;}&#xA;&#xA;setSiteComponent(value) {&#xA;    this.dispatch({value: value});&#xA;}&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>and DetailsStore</p>&#xA;&#xA;<pre><code>class SiteStore {&#xA;constructor() {&#xA;    this.siteComponents = {&#xA;        Prop: true&#xA;    };&#xA;&#xA;    this.bindListeners({&#xA;        setSiteComponent: SidebarActions.COMPONENT_STATUS_CHANGED&#xA;    })&#xA;}&#xA;&#xA;setSiteComponent(data) {&#xA;    this.siteComponents.Prop = data.value;&#xA;}&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And now, this is the place where magic begin.</p>&#xA;&#xA;<p>As You can see there is bindListener to SidebarActions.ComponentStatusChanged which will be used IF setSiteComponent will be used.</p>&#xA;&#xA;<p>now in SidebarActions</p>&#xA;&#xA;<pre><code>    componentStatusChanged(value){&#xA;    this.dispatch({value: value});&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>We have such thing. It will dispatch that object on call. And it will be called if setSiteComponent in store will be used (that you can use in component for example during onChange on Button ot whatever)</p>&#xA;&#xA;<p>Now in SidebarStore we will have</p>&#xA;&#xA;<pre><code>    constructor() {&#xA;    this.structures = [];&#xA;&#xA;    this.bindListeners({&#xA;        componentStatusChanged: SidebarActions.COMPONENT_STATUS_CHANGED&#xA;    })&#xA;}&#xA;&#xA;    componentStatusChanged(data) {&#xA;    this.waitFor(DetailsStore);&#xA;&#xA;    _.findWhere(this.structures[0].elem, {title: 'Example'}).enabled = data.value;&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Now here you can see, that it will wait for DetailsStore. What does it mean? more or less it means that this method need to wait for DetailsStoreto update before it can update itself.</p>&#xA;&#xA;<p>tl;dr&#xA;One Store is listening on methods in a store, and will trigger an action from component action, which will update its own store.</p>&#xA;&#xA;<p>I hope it can help you somehow.</p>&#xA;
<p>If you want to explore options of communicating between components and feel like it is getting harder and harder, then you might consider adopting a good design pattern: <a href="https://facebook.github.io/flux/" rel="nofollow">Flux</a>.</p>&#xA;&#xA;<p>It is simply a collection of rules that defines how you store and mutate application wide state, and use that state to render components.</p>&#xA;&#xA;<p>There are many Flux implementations, and <a href="https://github.com/facebook/flux" rel="nofollow">Facebook's official implementation</a> is one of them. Although it is considered the one that contains most boilerplate code, but it is easier to understand since most of the things are explicit.</p>&#xA;&#xA;<p>Some of Other alternatives are <a href="https://github.com/acdlite/flummox/" rel="nofollow">flummox</a> <a href="https://github.com/BinaryMuse/fluxxor" rel="nofollow">fluxxor</a> <a href="https://github.com/yahoo/fluxible" rel="nofollow">fluxible</a> and <a href="https://github.com/rackt/redux" rel="nofollow">redux</a>.</p>&#xA;
<p>Extending answer of @MichaelLaCroix when a scenario is that the components can't communicate between any sort of parent-child relationship, the documentation recommends setting up a global event system.</p>&#xA;&#xA;<p>In the case of <code>&lt;Filters /&gt;</code> and <code>&lt;TopBar /&gt;</code> don't have any of the above relationship, a simple global emitter could be used like this:</p>&#xA;&#xA;<p><code>componentDidMount</code> - Subscribe to event</p>&#xA;&#xA;<p><code>componentWillUnmount</code> - Unsubscribe from event</p>&#xA;&#xA;<p><a href="https://gist.github.com/tsuz/1c584c248e63d3a9b835e3f4e2223571" rel="nofollow noreferrer">React.js and EventSystem code</a></p>&#xA;&#xA;<p><strong>EventSystem.js</strong></p>&#xA;&#xA;<pre class="lang-js prettyprint-override"><code>class EventSystem{&#xA;&#xA;    constructor() {&#xA;        this.queue = {};&#xA;        this.maxNamespaceSize = 50;&#xA;    }&#xA;&#xA;    publish(/** namespace **/ /** arguments **/) {&#xA;        if(arguments.length &lt; 1) {&#xA;            throw "Invalid namespace to publish";&#xA;        }&#xA;&#xA;        var namespace = arguments[0];&#xA;        var queue = this.queue[namespace];&#xA;&#xA;        if (typeof queue === 'undefined' || queue.length &lt; 1) {&#xA;            console.log('did not find queue for %s', namespace);&#xA;            return false;&#xA;        }&#xA;&#xA;        var valueArgs = Array.prototype.slice.call(arguments);&#xA;&#xA;        valueArgs.shift(); // remove namespace value from value args&#xA;&#xA;        queue.forEach(function(callback) {&#xA;            callback.apply(null, valueArgs);&#xA;        });&#xA;&#xA;        return true;&#xA;    }&#xA;&#xA;    subscribe(/** namespace **/ /** callback **/) {&#xA;        const namespace = arguments[0];&#xA;        if(!namespace) throw "Invalid namespace";&#xA;        const callback = arguments[arguments.length - 1];&#xA;        if(typeof callback !== 'function') throw "Invalid callback method";&#xA;&#xA;        if (typeof this.queue[namespace] === 'undefined') {&#xA;            this.queue[namespace] = [];&#xA;        }&#xA;&#xA;        const queue = this.queue[namespace];&#xA;        if(queue.length === this.maxNamespaceSize) {&#xA;            console.warn('Shifting first element in queue: `%s` since it reached max namespace queue count : %d', namespace, this.maxNamespaceSize);&#xA;            queue.shift();&#xA;        }&#xA;&#xA;        // Check if this callback already exists for this namespace&#xA;        for(var i = 0; i &lt; queue.length; i++) {&#xA;            if(queue[i] === callback) {&#xA;                throw ("The exact same callback exists on this namespace: " + namespace);&#xA;            }&#xA;        }&#xA;&#xA;        this.queue[namespace].push(callback);&#xA;&#xA;        return [namespace, callback];&#xA;    }&#xA;&#xA;    unsubscribe(/** array or topic, method **/) {&#xA;        let namespace;&#xA;        let callback;&#xA;        if(arguments.length === 1) {&#xA;            let arg = arguments[0];&#xA;            if(!arg || !Array.isArray(arg)) throw "Unsubscribe argument must be an array";&#xA;            namespace = arg[0];&#xA;            callback = arg[1];&#xA;        }&#xA;        else if(arguments.length === 2) {&#xA;            namespace = arguments[0];&#xA;            callback = arguments[1];&#xA;        }&#xA;&#xA;        if(!namespace || typeof callback !== 'function') throw "Namespace must exist or callback must be a function";&#xA;        const queue = this.queue[namespace];&#xA;        if(queue) {&#xA;            for(var i = 0; i &lt; queue.length; i++) {&#xA;                if(queue[i] === callback) {&#xA;                    queue.splice(i, 1); // only unique callbacks can be pushed to same namespace queue&#xA;                    return;&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;&#xA;    setNamespaceSize(size) {&#xA;        if(!this.isNumber(size)) throw "Queue size must be a number";&#xA;        this.maxNamespaceSize = size;&#xA;        return true;&#xA;    }&#xA;&#xA;    isNumber(n) {&#xA;        return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);&#xA;    }&#xA;&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>NotificationComponent.js</strong></p>&#xA;&#xA;<pre class="lang-js prettyprint-override"><code>class NotificationComponent extends React.Component {&#xA;&#xA;    getInitialState() {&#xA;        return {&#xA;            // optional. see alternative below&#xA;            subscriber: null&#xA;        };&#xA;    }&#xA;&#xA;    errorHandler() {&#xA;        const topic = arguments[0];&#xA;        const label = arguments[1];&#xA;        console.log('Topic %s label %s', topic, label);&#xA;    }&#xA;&#xA;    componentDidMount() {&#xA;        var subscriber = EventSystem.subscribe('error.http', this.errorHandler);&#xA;        this.state.subscriber = subscriber;&#xA;    }&#xA;&#xA;    componentWillUnmount() {&#xA;        EventSystem.unsubscribe('error.http', this.errorHandler);&#xA;&#xA;        // alternatively&#xA;        // EventSystem.unsubscribe(this.state.subscriber);&#xA;    }&#xA;&#xA;    render() {&#xA;&#xA;    }&#xA;}&#xA;</code></pre>&#xA;
<p>I saw that the question is already answered, but if you'd like to learn more details, there are a total of <strong>3 cases of communication between components</strong>:</p>&#xA;&#xA;<ul>&#xA;<li>Case 1: Parent to Child communication</li>&#xA;<li>Case 2: Child to Parent communication</li>&#xA;<li>Case 3: Not-related components (any component to any component) communication</li>&#xA;</ul>&#xA;
<p>I once was where you are right now, as a beginner you sometimes feel out of place on how the react way to do this. I'm gonna try to tackle the same way I think of it right now. </p>&#xA;&#xA;<h2>States are the cornerstone for communication</h2>&#xA;&#xA;<p>Usually what it comes down to is the way that you alter the states in this component in your case you point out three components.</p>&#xA;&#xA;<p><code>&lt;List /&gt;</code> : Which probably will display a list of items depending on a filter&#xA;<code>&lt;Filters /&gt;</code>: Filter options that will alter your data.&#xA;<code>&lt;TopBar /&gt;</code>: List of options.</p>&#xA;&#xA;<p>To orchestrate all of this interaction you are going to need a higher component let's call it App, that will pass down actions and data to each one of this components so for instance can look like this</p>&#xA;&#xA;<pre><code>&lt;div&gt;&#xA;  &lt;List items={this.state.filteredItems}/&gt;&#xA;  &lt;Filter filter={this.state.filter} setFilter={setFilter}/&gt;&#xA;&lt;/div&gt;&#xA;</code></pre>&#xA;&#xA;<p>So when <code>setFilter</code> is called it will affect the filteredItem and re-render both component;. In case this is not entirely clear I made you an example with checkbox that you can check in a single file:</p>&#xA;&#xA;<pre><code>import React, {Component} from 'react';&#xA;import {render} from 'react-dom';&#xA;&#xA;const Person  = ({person, setForDelete}) =&gt; (&#xA;          &lt;div&gt;&#xA;            &lt;input type="checkbox" name="person" checked={person.checked} onChange={setForDelete.bind(this, person)} /&gt;&#xA;            {person.name}&#xA;          &lt;/div&gt;&#xA;);&#xA;&#xA;&#xA;class PeopleList extends Component {&#xA;&#xA;  render() {&#xA;&#xA;    return(&#xA;      &lt;div&gt;&#xA;       {this.props.people.map((person, i) =&gt; {&#xA;         return &lt;Person key={i} person={person} setForDelete={this.props.setForDelete} /&gt;;&#xA;       })}&#xA;       &lt;div onClick={this.props.deleteRecords}&gt;Delete Selected Records&lt;/div&gt;&#xA;     &lt;/div&gt;&#xA;    );&#xA;  }&#xA;&#xA;} // end class&#xA;&#xA;class App extends React.Component {&#xA;&#xA;  constructor(props) {&#xA;    super(props)&#xA;    this.state = {people:[{id:1, name:'Cesar', checked:false},{id:2, name:'Jose', checked:false},{id:3, name:'Marbel', checked:false}]}&#xA;  }&#xA;&#xA;  deleteRecords() {&#xA;    const people = this.state.people.filter(p =&gt; !p.checked);&#xA;&#xA;    this.setState({people});&#xA; }&#xA;&#xA;  setForDelete(person) {&#xA;    const checked = !person.checked;&#xA;    const people = this.state.people.map((p)=&gt;{&#xA;      if(p.id === person.id)&#xA;        return {name:person.name, checked};&#xA;      return p;&#xA;    });&#xA;&#xA;    this.setState({people});&#xA;  }&#xA;&#xA;  render () {&#xA;&#xA;    return &lt;PeopleList people={this.state.people} deleteRecords={this.deleteRecords.bind(this)} setForDelete={this.setForDelete.bind(this)}/&gt;;&#xA;  }&#xA;}&#xA;&#xA;render(&lt;App/&gt;, document.getElementById('app'));&#xA;</code></pre>&#xA;
<p>The following code helps me to setup communication between two siblings. The setup is done in their parent during render() and componentDidMount() calls.&#xA;It is based on <a href="https://reactjs.org/docs/refs-and-the-dom.html" rel="nofollow noreferrer">https://reactjs.org/docs/refs-and-the-dom.html</a>&#xA;Hope it helps.</p>&#xA;&#xA;<pre><code>class App extends React.Component&lt;IAppProps, IAppState&gt; {&#xA;    private _navigationPanel: NavigationPanel;&#xA;    private _mapPanel: MapPanel;&#xA;&#xA;    constructor() {&#xA;        super();&#xA;        this.state = {};&#xA;    }&#xA;&#xA;    // `componentDidMount()` is called by ReactJS after `render()`&#xA;    componentDidMount() {&#xA;        // Pass _mapPanel to _navigationPanel&#xA;        // It will allow _navigationPanel to call _mapPanel directly&#xA;        this._navigationPanel.setMapPanel(this._mapPanel);&#xA;    }&#xA;&#xA;    render() {&#xA;        return (&#xA;            &lt;div id="appDiv" style={divStyle}&gt;&#xA;                // `ref=` helps to get reference to a child during rendering&#xA;                &lt;NavigationPanel ref={(child) =&gt; { this._navigationPanel = child; }} /&gt;&#xA;                &lt;MapPanel ref={(child) =&gt; { this._mapPanel = child; }} /&gt;&#xA;            &lt;/div&gt;&#xA;        );&#xA;    }&#xA;}&#xA;</code></pre>&#xA;
<p><strong>OK,</strong> there are few ways to do it, but I exclusively want focus on using store using <strong>Redux</strong> which make your life much easier for these situation rather than give you a quick solution only for this case, using pure React will end up mess up in real big application and communicating between <strong>Components</strong> becomes harder and harder as the application grows...</p>&#xA;&#xA;<p>So what <strong>Redux</strong> does for you?</p>&#xA;&#xA;<p>Redux is like local storage in your application which can be used whenever you need a data be used in different places in your application...</p>&#xA;&#xA;<p>Basically Redux idea comes from flux originally, but with some fundamental changes including concept of having one source of truth by creating only one store...</p>&#xA;&#xA;<p>Look at the graph below to see some differences between <strong>Flux</strong> and <strong>Redux</strong>...</p>&#xA;&#xA;<p><a href="https://i.stack.imgur.com/nUM2P.jpg" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/nUM2P.jpg" alt="Redux and Flux"></a></p>&#xA;&#xA;<p>Consider applying <strong>Redux</strong> in your application from the start if your application needs communication between Components...</p>&#xA;&#xA;<p>Also reading these words from Redux Documentation could be helpful to start with: </p>&#xA;&#xA;<blockquote>&#xA;  <p>As the requirements for JavaScript single-page applications have&#xA;  become increasingly complicated, <strong>our code must manage more state than&#xA;  ever before</strong>. This state can include server responses and cached data,&#xA;  as well as locally created data that has not yet been persisted to the&#xA;  server. UI state is also increasing in complexity, as we need to&#xA;  manage active routes, selected tabs, spinners, pagination controls,&#xA;  and so on.</p>&#xA;  &#xA;  <p>Managing this ever-changing state is hard. If a model can update&#xA;  another model, then a view can update a model, which updates another&#xA;  model, and this, in turn, might cause another view to update. At some&#xA;  point, you no longer understand what happens in your app as you have&#xA;  lost control over the when, why, and how of its state. When a system&#xA;  is opaque and non-deterministic, it's hard to reproduce bugs or add&#xA;  new features.</p>&#xA;  &#xA;  <p>As if this wasn't bad enough, consider the new requirements becoming&#xA;  common in front-end product development. As developers, we are&#xA;  expected to handle optimistic updates, server-side rendering, fetching&#xA;  data before performing route transitions, and so on. We find ourselves&#xA;  trying to manage a complexity that we have never had to deal with&#xA;  before, and we inevitably ask the question: is it time to give up? The&#xA;  answer is no.</p>&#xA;  &#xA;  <p>This complexity is difficult to handle as we're mixing two concepts&#xA;  that are very hard for the human mind to reason about: mutation and&#xA;  asynchronicity. I call them Mentos and Coke. Both can be great in&#xA;  separation, but together they create a mess. Libraries like React&#xA;  attempt to solve this problem in the view layer by removing both&#xA;  asynchrony and direct DOM manipulation. However, managing the state of&#xA;  your data is left up to you. This is where Redux enters.</p>&#xA;  &#xA;  <p>Following in the steps of <strong>Flux, CQRS, and Event Sourcing</strong>, <strong>Redux&#xA;  attempts to make state mutations predictable by imposing certain&#xA;  restrictions on how and when updates can happen</strong>. These restrictions&#xA;  are reflected in the three principles of Redux.</p>&#xA;</blockquote>&#xA;