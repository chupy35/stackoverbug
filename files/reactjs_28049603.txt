28049603
Get reference to React component in event handler
<p>I can attach my event handler to a React component. Is there a way to get a reference to this component inside event hander?</p>&#xA;&#xA;<pre class="lang-js prettyprint-override"><code>var Foobar = React.createClass({&#xA;    action: function () {&#xA;        // ...&#xA;    },&#xA;    render: function () {&#xA;        var child = React.Children.only(this.props.children),&#xA;            props = _.omit(this.props, 'children');&#xA;        return React.addons.cloneWithProps(child, props);&#xA;    }&#xA;});&#xA;&#xA;var App = React.createClass({&#xA;    handleMouseEnter: function (event) {&#xA;        // How to get reference to Foobar without using this.refs['foo']?&#xA;        // I need to call *action* on it.&#xA;    },&#xA;    render: function () {&#xA;        return (&#xA;            &lt;div&gt;&#xA;                &lt;Foobar ref="foo" onMouseEnter={this.handleMouseEnter}&gt;&#xA;                    ...&#xA;                &lt;/Foobar&gt;&#xA;            &lt;/div&gt;&#xA;        );&#xA;    }&#xA;});&#xA;</code></pre>&#xA;
<p><code>handleMouseEnter</code> in the example you offered (and the clarification that onClick would be a handler passed to Foobar) is by default auto-bound by React to the context of the <code>App</code> instance in both cases.</p>&#xA;&#xA;<p>With this in mind, <code>this.refs.foo</code> or <code>this.refs['foo']</code> should work fine in the context you've described, and would be the correct approach.</p>&#xA;&#xA;<p>A more clean solution assuming there's no compelling reason to keep the handler in App would be to keep the handler entirely contained within Foobar, something like this:</p>&#xA;&#xA;<pre><code>var Foobar = React.createClass({&#xA;    action: function () {&#xA;        // ...&#xA;    },&#xA;    render: function () {&#xA;        var child = React.Children.only(this.props.children),&#xA;            props = _.omit(this.props, 'children');&#xA;        return (&#xA;            &lt;div onClick={this.action} onMouseEnter={this.action}&gt;&#xA;                React.addons.cloneWithProps(child, props);&#xA;            &lt;/div&gt;&#xA;        );&#xA;    }&#xA;});&#xA;&#xA;var App = React.createClass({&#xA;    render: function () {&#xA;        return (&#xA;            &lt;Foobar /&gt;&#xA;        );&#xA;    }&#xA;});&#xA;</code></pre>&#xA;
<p>You'll have to propagate the handler to the root element of your child component, something like this:</p>&#xA;&#xA;<pre><code>var Foobar = React.createClass({&#xA;    action: function (e) {&#xA;        this.props.onClick(this);&#xA;    },&#xA;    render: function () {&#xA;        return &lt;div onClick={this.action}&gt;{this.props.children}&lt;/div&gt;;&#xA;    }&#xA;});&#xA;&#xA;var App = React.createClass({&#xA;    handleMouseEnter: function (foobar) {&#xA;       console.log(foobar);&#xA;    },&#xA;    render: function () {&#xA;        return (&#xA;            &lt;Foobar ref="foo" onClick={this.handleMouseEnter} /&gt;&#xA;        );&#xA;    }&#xA;});&#xA;</code></pre>&#xA;
<p>I think I understand the question vbarbarosh is asking, or at least I had a similar one that led me to this post. So if this doesn't answer the original question hopefully it can help others who land here.</p>&#xA;&#xA;<p>In my case I have a React component with <em>n</em> number of children for defining configuration options for a UI action. Each child has a different ref identifying what config option the input represents and I want to be able to directly access the ref so I can then call methods exposed on my child component. (I could expose data attrs and use jQuery to extract, but that seems like a lot of extra hoops &amp; performance issues)</p>&#xA;&#xA;<p>My first attempt was this:</p>&#xA;&#xA;<pre><code>...&#xA;&lt;Config ref="showDetails" onChange={this.handleChange} /&gt;&#xA;&lt;Config ref="showAvatar" onChange={this.handleChange} /&gt;&#xA;...&#xA;</code></pre>&#xA;&#xA;<p>Ideally, I wanted to bind all the change events to a single handler, then extract the ref from the target that dispatched the event. Unfortunately the dispatched <code>SyntheticEvent</code> does <strong>not</strong> provide a way to get the ref of the target so I can't make a direct call to <code>this.ref[name].methodIWantToCall()</code>.</p>&#xA;&#xA;<p>What I did find was an article in the React docs that lead me to a solution:</p>&#xA;&#xA;<p><a href="https://facebook.github.io/react/tips/communicate-between-components.html">https://facebook.github.io/react/tips/communicate-between-components.html</a></p>&#xA;&#xA;<p>What we can do is take advantage of JavaScript binding and pass in additional arguments.</p>&#xA;&#xA;<pre><code>...&#xA;&lt;Config ref="showDetails" onChange={this.handleChange.bind(this, 'showDetails')} /&gt;&#xA;...&#xA;</code></pre>&#xA;&#xA;<p>Now in my handler I get the addition data and can access my refs:</p>&#xA;&#xA;<pre><code>handleChange: function(refName, event) {&#xA;  this.refs[refName].myMethodIWantToCall()&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>The trick is that when binding, the argument order is changed and the first argument is now the bound value passed in and the event is now the second argument. Hope that helps!</p>&#xA;
<p>In case you added the handler programatically you can pass the component as a param just by wrapping the handler callback with another function at the  <code>addEventListener</code>.</p>&#xA;&#xA;<p>I have this example using the scroll event:</p>&#xA;&#xA;<pre><code>componentDidMount() {&#xA;    document.getElementById('theElementId').addEventListener('scroll', (e) =&gt; {&#xA;        this.handleScroll(e, this);&#xA;    });&#xA;}&#xA;&#xA;handleScroll(event, _self) {&#xA;    // Now you can access to the element using the param _self&#xA;}&#xA;&#xA;render() {&#xA;    return (&#xA;        &lt;div id="theElementId"&gt;&lt;/div&gt;&#xA;    )&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Another option is to use the bind method which will change the value of <code>this</code>:</p>&#xA;&#xA;<pre><code>componentDidMount() {&#xA;    document.getElementById('theElementId').addEventListener('scroll', this.handleScroll.bind(this));&#xA;}&#xA;&#xA;handleScroll(event) {&#xA;    // Now you can access to the element using the param this&#xA;}&#xA;</code></pre>&#xA;
<p>Well looking at your App Component, you could try this:</p>&#xA;&#xA;<pre><code>var App = React.createClass({&#xA;handleMouseEnter: function (event) {&#xA;    // reference it by using: this.refs[event._targetInst._currentElement.ref]&#xA;    // same result as calling: this.refs.foo&#xA;    console.log(this.refs[event._targetInst._currentElement.ref])&#xA;},&#xA;render: function () {&#xA;    return (&#xA;        &lt;div&gt;&#xA;            &lt;Foobar ref="foo" onMouseEnter={this.handleMouseEnter}&gt;&#xA;                ...&#xA;            &lt;/Foobar&gt;&#xA;        &lt;/div&gt;&#xA;        );&#xA;    }&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>Hope this helps. :)&#xA;Also, I'm using the ES6 way of writing/declaring React Components, which also changes the behaviour of "this" a little bit. Not sure if this might also play a role here.</p>&#xA;