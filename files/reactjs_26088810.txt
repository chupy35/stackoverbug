26088810
How to avoid 'children with same key' when replacing state in ReactJs component
<p>I have created a React Component that renders a set of sub-elements given an array of ids. The array of ids is kept in the state of the parent component, and then I run some ajax calls based on the ids to fetch data to render. The fetched data is stored in a separate data array in the state. The rendered components <em>use the id as key</em>. </p>&#xA;&#xA;<p>The ids can change based on actions outside of the component, so I use setState on the component to replace the array. <em>The updated id-state will probably contain some of the same ids as the in the original array.</em>  At the same time I empty the 'data array' so that everything will be rendered again.</p>&#xA;&#xA;<p>When I do this I sometimes get the key-warning:</p>&#xA;&#xA;<blockquote>&#xA;  <p>Warning: flattenChildren(...): Encountered two children with the same&#xA;  key. Child keys must be unique; when two children share a key, only&#xA;  the first child will be used.</p>&#xA;</blockquote>&#xA;&#xA;<p>The new array does not contain any duplicates. So why does it happen, and what can I do to avoid this? </p>&#xA;&#xA;<p>Edit: Added some code by request. Note: I am using the <a href="https://www.npmjs.org/package/react-infinite-scroll">Infinite Scroll module</a>. Could this be causing it?</p>&#xA;&#xA;<h2>Initial state:</h2>&#xA;&#xA;<pre><code>getInitialState: function() {&#xA;  return {&#xA;    hasMore: true,&#xA;    num: 0,&#xA;    movieIds: this.props.movieIds,&#xA;    movies: []&#xA;  };&#xA;},&#xA;</code></pre>&#xA;&#xA;<h2>Render function:</h2>&#xA;&#xA;<pre><code>render: function() {&#xA;  var InfiniteScroll = React.addons.InfiniteScroll;&#xA;&#xA;  return (&#xA;    &lt;InfiniteScroll&#xA;        pageStart={0}&#xA;        loadMore={this.loadMore}&#xA;        threshold='20'&#xA;        hasMore={this.state.hasMore}&gt;&#xA;        &lt;ul className="movieList"&gt;&#xA;          {this.state.movies}&#xA;        &lt;/ul&gt;&#xA;    &lt;/InfiniteScroll&gt;       &#xA;);&#xA;}&#xA;</code></pre>&#xA;&#xA;<h2>Simplified load more:</h2>&#xA;&#xA;<pre><code>comp = this;&#xA;$.ajax( {&#xA;  url: url,&#xA;  contentType: "json",&#xA;  success: function (data) {&#xA;    var m = createMovieLi(data);&#xA;    var updatedMovies = comp.state.movies;&#xA;    updatedMovies[num] = m;&#xA;    comp.setState({movies: updatedMovies});&#xA;  }&#xA;});&#xA;</code></pre>&#xA;&#xA;<p>And finally when updating outside the component:</p>&#xA;&#xA;<pre><code>movieBox.setState({&#xA;  hasMore: true,&#xA;  num: 0,&#xA;  movieIds: filteredIds,&#xA;  movies: []&#xA;});&#xA;</code></pre>&#xA;
<p>I wouldn't use the ID from a back-end as key property in React.  If you do, you're relying on some logic that's a bit far away from your component to make sure that your keys are unique.  If they keys are not unique, you can break react's rendering so this is quite important.</p>&#xA;&#xA;<p>This is why you should, in my opinion, just stick to using the index within a for loop or similar to set key properties.  That way you know they can never be non-unique, and it's the simplest way of doing exactly that.</p>&#xA;&#xA;<p>Without knowing exactly how your IDs work it's impossible to say what's causing the non-unique clash here.  However since <code>key</code> is just to allow React to correctly identify elements, and nothing else, it doesn't really make sense for it to be anything other than a simple count or index.</p>&#xA;&#xA;<pre><code>var children = [];&#xA;for (var i=0; i&lt;yourArray.length; i++) {&#xA;    children.push(&#xA;        &lt;div key={i}&gt;{yourArray[i].someProp}&lt;/div&gt;&#xA;    );&#xA;}&#xA;</code></pre>&#xA;
<p>I figured out my mistake, and it had nothing to do with React per se. It was a classic case of <a href="https://stackoverflow.com/questions/750486/javascript-closure-inside-loops-simple-practical-example">missing javascript closure inside a loop</a>.</p>&#xA;&#xA;<p>Because of the possibility of duplicates I stored each ajax response in window.localStorage, on the movieId. Or so I thought. </p>&#xA;&#xA;<p>In React Inifinite Scroll each item in your list is drawn sequentially with a call to the loadMore-function. Inside this function I did my ajax call, and stored the result in the browser cache. The code looked something like this:</p>&#xA;&#xA;<pre><code>  var cachedValue = window.localStorage.getItem(String(movieId));&#xA;  var cachedData = cachedValue ? JSON.parse(cachedValue) : cachedValue;&#xA;&#xA;  if (cachedData != null) {&#xA;    comp.drawNextMovie(cachedData);&#xA;  } else { &#xA;    $.ajax( {&#xA;      type: "GET",&#xA;      url: this.state.movieUrl + movieId,&#xA;      contentType: "json",&#xA;      success: function (movieData) {&#xA;        window.localStorage.setItem(String(movieId), JSON.stringify(movieData));&#xA;        comp.drawNextMovie(movieData);&#xA;      }&#xA;    });  &#xA;  }    &#xA;</code></pre>&#xA;&#xA;<p>Can you spot the mistake? When the ajax-call returns, movieId is no longer what is was. So I end up storing the data by the wrong id, and get some strange React warnings in return. Because this was done inside the loadMore function called by the InfiniteScroll-module, I was not aware that this function was not properly scoped. </p>&#xA;&#xA;<p>I fixed it by adding a <a href="http://en.wikipedia.org/wiki/Immediately-invoked_function_expression" rel="noreferrer">Immediately-invoked function expression</a>.</p>&#xA;