24470852
Reactjs with LinkedStateMixin and select with multiple options
<p>Using Reactjs, I want to have a single handleChange method handling the modifications of all my form elements.</p>&#xA;&#xA;<p>I understand that the <a href="http://facebook.github.io/react/docs/two-way-binding-helpers.html" rel="nofollow">LinkedStateMixin</a> exists for this reason, and that I should use </p>&#xA;&#xA;<pre><code>render: function() {&#xA;    return &lt;select multiple={{ true }} valueLink={this.linkState('value')}&gt;...options...&lt;/select&gt;;&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>to bind the status of my select element.</p>&#xA;&#xA;<p>But it seems that this way of doing things does not work with multiple selects : the state.value is updated but with only one value (when I select 2 options, I can see React update the DOM and it systematically removes one of the selection).</p>&#xA;&#xA;<p>So my question is : is LinkedStateMixin a dead-end for this use case ? How do you handle this select-multiple use case ?</p>&#xA;
<p>The root problem is that <code>.value</code> for select elements with the <code>multiple</code> attribute only returns the value of the first selected option element it contains. So, when the ValueLink mixin calls <code>event.target.value</code> to get the <code>select</code>'s new value, it doesn't return the required array to make the <code>value</code> property work.</p>&#xA;&#xA;<p>You could build a little wrapper around <code>select</code> to make this work; here's my version (<a href="http://jsfiddle.net/BinaryMuse/wQ4MP/" rel="nofollow">plus a JSFiddle example</a>):</p>&#xA;&#xA;<pre class="lang-javascript prettyprint-override"><code>// A select element that supports `multiple` and `valueLink` correctly&#xA;var BetterSelect = React.createClass({&#xA;  render: function() {&#xA;    if (this.props.valueLink) {&#xA;      return this.transferPropsTo(&#xA;        &lt;select value={this.props.valueLink.value}&#xA;                valueLink={null} onChange={this.handleChange}&gt;&#xA;          {this.props.children}&#xA;        &lt;/select&gt;&#xA;      );&#xA;    } else {&#xA;      return this.transferPropsTo(&#xA;        &lt;select onChange={this.handleChange}&gt;&#xA;          {this.props.children}&#xA;        &lt;/select&gt;&#xA;      );&#xA;    }&#xA;  },&#xA;&#xA;  handleChange: function(e) {&#xA;    var selectedValue;&#xA;    if (this.props.multiple) {&#xA;      // We have to iterate the `options` elements&#xA;      // to figure out which ones are selected.&#xA;      selectedValue = [];&#xA;      var options = e.target.options;&#xA;      for (var i = 0, l = options.length; i &lt; l; i++) {&#xA;        if (options[i].selected) {&#xA;          selectedValue.push(options[i].value);&#xA;        }&#xA;      }&#xA;    } else {&#xA;      selectedValue = e.target.value;&#xA;    }&#xA;&#xA;    // Fire onChange manually if it exists since we overwrote it&#xA;    this.props.onChange &amp;&amp; this.props.onChange(e);&#xA;&#xA;    // Finally, manually take care of any valueLink passed&#xA;    if (this.props.valueLink) {&#xA;      this.props.valueLink.requestChange(selectedValue);&#xA;    }&#xA;  }&#xA;});&#xA;&#xA;&#xA;// Let's try it out:&#xA;var Application = React.createClass({&#xA;  mixins: [React.addons.LinkedStateMixin],&#xA;&#xA;  getInitialState: function() {&#xA;    return { value: ['Apples', 'Oranges'] };&#xA;  },&#xA;&#xA;  render: function() {&#xA;    return (&#xA;      &lt;div&gt;&#xA;        &lt;pre&gt;{JSON.stringify(this.state.value)}&lt;/pre&gt;&#xA;        &lt;BetterSelect multiple valueLink={this.linkState('value')}&gt;&#xA;          &lt;option value='Apples'&gt;Apples&lt;/option&gt;&#xA;          &lt;option value='Bananas'&gt;Bananas&lt;/option&gt;&#xA;          &lt;option value='Oranges'&gt;Oranges&lt;/option&gt;&#xA;        &lt;/BetterSelect&gt;&#xA;      &lt;/div&gt;&#xA;    );&#xA;  }&#xA;});&#xA;</code></pre>&#xA;