31940254
getting complete tree from elastic search in single call
<p>I want to store employee hierarchy in elastic search. where CFO, CTO, COO etc report to CEO. And each employee can have their own reportees. </p>&#xA;&#xA;<p>I think above can be done using elastic search parent-child relationship. Can we write a query to get the all reportees(direct reportees and sub-reportees) in a single call.&#xA;For example if we query for CEO we should get all employees and for CFO we should get employees in finance dept.</p>&#xA;&#xA;<p>Something similar exists in RDMS like SQL server's CTE.</p>&#xA;
<p>Parent-child relations in ES is:</p>&#xA;&#xA;<ol>&#xA;<li>Parent knows nothing about children</li>&#xA;<li>Children must provide <code>_parent</code> to connect with it and to be routed accodringly.</li>&#xA;<li>Parent-child mapping is handled by ES via mapping in memory.</li>&#xA;<li>Parent/child documents is independent in any other aspect.</li>&#xA;</ol>&#xA;&#xA;<p>So, there is no easy way to do it (there's no way to actually store normal form of any relational data as well, because ES in non-relational DB). Workarounds about this:</p>&#xA;&#xA;<ul>&#xA;<li>query documents with <code>has_parent</code>/<code>has_child</code> queries (only 1 level of relation works for this)</li>&#xA;<li>store documents as <code>nested</code> objects (pay attention, that this model reindexes whole document if any of members changes)</li>&#xA;<li>denormalize data (most natural way for non-relational storages, IMO)</li>&#xA;</ul>&#xA;
<p>First and foremost, avoid thinking about ES in a relational database way. ES isn't so suited for joins/relations, though it can achieve similar effect via the parent/child relations. Don't even think about joins that might involve a undetermined number of depths. CTE can handle without much difficulty but not all relational databases support CTE AFAIK (MySQL being one).</p>&#xA;&#xA;<p>The parent-child relations is more trouble than its worth IMMO. Child docs are routed to shards where their parents reside. In your case of a tree, all documents will eventually trace back to the root document, which will result all your documents to reside in a single shard. The depth of your tree could be quite large (more than 4 or 5 in a not-so-small organization). Also, if you go with this solution, it is quite inconvenient to retrieve (via the <code>GET</code> API) a particular child doc from ES based on its ID, because you have to specify its parent IDs all the way up to its root.</p>&#xA;&#xA;<p>I think it's best to store the <code>PATH</code> from root up to but not including the current employee as a list of IDs. So each employee has a field like:</p>&#xA;&#xA;<pre><code>"superiors": [CEO_ID, CTO_ID, ... , HER_DIRECT_MANAGER_ID],&#xA;</code></pre>&#xA;&#xA;<p>So it is completely denormalized and your application has to prepare for this list.</p>&#xA;&#xA;<p>With this setup, to get all subordinates of an employee:</p>&#xA;&#xA;<ol>&#xA;<li>filtering out IDs in this employee's own <code>superiors</code> field plus her own ID, either using a filter agg or a filtered query.</li>&#xA;<li>do a <code>terms</code> agg on the <code>superiors</code> field and you will have all subordinates of this employee.</li>&#xA;</ol>&#xA;&#xA;<p>I must admit that at least two queries are needed. The first one is a <code>GET</code> request to retrieve the <code>superiors</code> field of this employee and then the second query to do what I described above.</p>&#xA;&#xA;<p>Also, don't worry about the duplications due to denormalization. ES can handle way more data than you can save here.</p>&#xA;