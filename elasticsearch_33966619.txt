33966619
ElasticSearch - is aggregation only perform on term?
<p>Suppose I use <code>keyword</code> tokenizer and <code>lowercase</code> filter, thus my <code>my_name</code> field "It is a Nike shoe." is tokenized to only one <strong><em>term</em></strong>: <code>["it is a nike shoe."]</code>.</p>&#xA;&#xA;<p>Use aggregation query:</p>&#xA;&#xA;<pre><code>{&#xA;"size": 0,&#xA;"aggs" : {&#xA;    "my_aggs" : {&#xA;        "terms" : { "field" : "my_name" }&#xA;    }&#xA;}}&#xA;</code></pre>&#xA;&#xA;<p>It returns </p>&#xA;&#xA;<pre><code>"aggregations" : {&#xA;    "my_aggs" : {&#xA;      "doc_count_error_upper_bound" : 0,&#xA;      "sum_other_doc_count" : 0,&#xA;      "buckets" : [ {&#xA;        "key" : "it is a nike shoe.",&#xA;        "doc_count" : 1&#xA;      } ]&#xA;    }&#xA;  }&#xA;</code></pre>&#xA;&#xA;<p>So I think aggregation is act on term. Which means I cannot get original <code>desc</code> field "It is a Nike shoe.".</p>&#xA;&#xA;<p>My question is:</p>&#xA;&#xA;<ol>&#xA;<li><p>Is aggregation only perform on <strong><em>term</em></strong>, which means aggregate by term?</p></li>&#xA;<li><p>For my case, is it possible to get original <code>my_name</code> field using aggregation (I want to know unique <code>my_name</code> values, not after tokenized term...)? </p></li>&#xA;</ol>&#xA;
<p>1)Yes, Aggregations are only performed on <strong>terms</strong> stored in <em>Inverted Index</em></p>&#xA;&#xA;<p>2)Yes, You can get the original value using <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.1/search-aggregations-metrics-top-hits-aggregation.html" rel="nofollow">top hits aggregation</a></p>&#xA;&#xA;<p>Try this</p>&#xA;&#xA;<pre><code>{&#xA;  "aggs": {&#xA;    "my_aggs": {&#xA;      "terms": {&#xA;        "field": "my_name",&#xA;        "size": 10&#xA;      },&#xA;      "aggs": {&#xA;        "include_original": {&#xA;          "top_hits": {&#xA;            "size": 1,&#xA;            "_source": {&#xA;              "include": "my_name"&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  },&#xA;  "size": 0&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Does this help?</p>&#xA;
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-top-hits-aggregation.html" rel="nofollow">Top hits Aggregation</a> can include more info, we can include original name. Aggregation can also work together with <code>bool</code> query, which makes it very flexible.</p>&#xA;&#xA;<p>Here is a sample, we group by "brandName":</p>&#xA;&#xA;<pre><code>curl -XGET 'my-elasticsearch.com/test-aggs/_search?pretty=true' -d '{&#xA;  "size": 0,&#xA;  "query" : {&#xA;    "bool" : {&#xA;      "must" : [ {&#xA;        "match" : {&#xA;          "state" : {&#xA;            "query" : ["Active"],&#xA;            "type" : "boolean"&#xA;          }&#xA;        }&#xA;      }, {&#xA;        "match" : {&#xA;          "brandName" : {&#xA;            "query" : "nik",&#xA;            "type" : "phrase_prefix"&#xA;          }&#xA;        }&#xA;      } ]&#xA;    }&#xA;  },&#xA;  "aggs": {&#xA;    "my_aggs": {&#xA;      "terms": {&#xA;        "field": "brandName"&#xA;      },&#xA;      "aggs": {&#xA;        "my_top_hits": {&#xA;          "top_hits": {&#xA;            "size": 1, // for each term, how many matched "hit" are return ("_source" is included in "hit")&#xA;            "_source": {&#xA;              "include": "brandName"&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}'&#xA;</code></pre>&#xA;&#xA;<p>Sample output:</p>&#xA;&#xA;<pre><code>{&#xA;  "took" : 37,&#xA;  "timed_out" : false,&#xA;  "_shards" : {&#xA;    "total" : 5,&#xA;    "successful" : 5,&#xA;    "failed" : 0&#xA;  },&#xA;  "hits" : {&#xA;    "total" : 10,&#xA;    "max_score" : 0.0,&#xA;    "hits" : [ ]&#xA;  },&#xA;  "aggregations" : {&#xA;    "my_aggs" : {&#xA;      "doc_count_error_upper_bound" : 0,&#xA;      "sum_other_doc_count" : 0,&#xA;      "buckets" : [ {&#xA;        "key" : "nike inc. international company",&#xA;        "doc_count" : 6,&#xA;        "my_top_hits" : {&#xA;          "hits" : {&#xA;            "total" : 6,&#xA;            "max_score" : 1.1467223,&#xA;            "hits" : [ {&#xA;              "_index" : "test-agg",&#xA;              "_type" : "Brand",&#xA;              "_id" : "AVFMf2jW9vvU7GxqHawa",&#xA;              "_score" : 1.1467223,&#xA;              "_source":{"brandName":"Nike Inc. International company"}&#xA;            } ]&#xA;          }&#xA;        }&#xA;      }, {&#xA;        "key" : "nike company",&#xA;        "doc_count" : 3,&#xA;        "my_top_hits" : {&#xA;          "hits" : {&#xA;            "total" : 3,&#xA;            "max_score" : 1.5016319,&#xA;            "hits" : [ {&#xA;              "_index" : "test-agg",&#xA;              "_type" : "Brand",&#xA;              "_id" : "AVFMjXOl9kfxoaJKgdxV",&#xA;              "_score" : 1.5016319,&#xA;              "_source":{"brandName":"NIKE Company"}&#xA;            } ]&#xA;          }&#xA;        }&#xA;      }, {&#xA;        "key" : "nikee...",&#xA;        "doc_count" : 1,&#xA;        "my_top_hits" : {&#xA;          "hits" : {&#xA;            "total" : 1,&#xA;            "max_score" : 1.6866593,&#xA;            "hits" : [ {&#xA;              "_index" : "test-agg",&#xA;              "_type" : "Brand",&#xA;              "_id" : "AVFMjaXi9vvU7GxqHawe",&#xA;              "_score" : 1.6866593,&#xA;              "_source":{"brandName":"NIKEE..."}&#xA;            } ]&#xA;          }&#xA;        }&#xA;      } ]&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Original "brandName" is returned.</p>&#xA;&#xA;<p>While there is big limitation:</p>&#xA;&#xA;<p>For term "nike", there maybe several "brandName" tokenized to "nike". E.x: ["NIKE", "NIKE", "Nike", "nike", "NIKE", "Nike", "Nike"]. That means it is impossible to specify "size" in "top_hits", because we don't know how many "brandName"s are tokenized to term "nike" (that makes no benefit than return all results and you program to get unique records).</p>&#xA;&#xA;<p>Another cons is that aggregation is not high performance, it is much slower than match/term query.</p>&#xA;