31258959
Elasticsearch documents that only have terms intersecting a list of terms but no other terms
<p>I have documents that have a list of labels:</p>&#xA;&#xA;<pre>&#xA;&#xA;    {&#xA;       "fields": {&#xA;          "label": [&#xA;               "foo",&#xA;               "bar",&#xA;               "baz"&#xA;          ],&#xA;          "name": [&#xA;             "Document One"&#xA;          ],&#xA;          "description" : "A fine first document",&#xA;          "id" : 1&#xA;       }&#xA;    },&#xA;    {&#xA;       "fields": {&#xA;          "label": [&#xA;               "foo",&#xA;               "dog"&#xA;          ],&#xA;          "name": [&#xA;             "Document Two"&#xA;          ],&#xA;          "description" : "A fine second document",&#xA;          "id" : 2&#xA;       }&#xA;    }&#xA;&#xA;</pre>&#xA;&#xA;<p>I have a list of terms:</p>&#xA;&#xA;<pre>&#xA;&#xA;    [ "foo", "bar", "qux", "zip", "baz"]&#xA;&#xA;</pre>&#xA;&#xA;<p>I want a query that will return documents that have labels in the list of terms - but no other terms.</p>&#xA;&#xA;<p>So given the list above, the query would return <code>Document One</code>, but <strong>not</strong> <code>Document Two</code> (because it has the term <code>dog</code> that is not in the list of terms.</p>&#xA;&#xA;<p>I've tried doing a query using a <code>not</code> <code>terms</code> filter, like this:</p>&#xA;&#xA;<pre>&#xA;&#xA;    POST /documents/_search?size=1000&#xA;    {&#xA;       "fields": [&#xA;          "id",&#xA;          "name",&#xA;          "label"&#xA;       ],&#xA;       "filter": {&#xA;           "not": {&#xA;               "filter" : {&#xA;                   "bool" : {&#xA;                       "must_not": {&#xA;                          "terms": {&#xA;                             "label": [&#xA;                                "foo",&#xA;                                "bar",&#xA;                                "qux",&#xA;                                "zip",&#xA;                                "baz"&#xA;                             ]&#xA;                          }&#xA;                       }&#xA;                   }&#xA;               }&#xA;           }&#xA;       }&#xA;    }&#xA;</pre>&#xA;&#xA;<p>But that didn't work.</p>&#xA;&#xA;<p>How can I create a query that, given a list of terms, will match documents that only contain terms in the list, and no other terms? In other words, all documents should contain a list of labels that are a subset of the list of supplied terms.</p>&#xA;
<p>You can script filter to check if the array terms has all the values of label array in a document. I suggest you to make a separate groovy file or plain javascript file, put it in config/scripts/folderToYourScript, and use it in your query in<code>filter: { script : {script_file: file } }</code></p>&#xA;&#xA;<p>While in script file you can use loop to check the requirement</p>&#xA;
<p>I followed Rohit's suggestion, and implemented an <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-script-filter.html?q=script" rel="nofollow">Elasticsearch script filter</a>. You will need to <a href="https://www.elastic.co/guide/en/elasticsearch/reference/1.6/modules-scripting.html" rel="nofollow">configure your Elasticsearch server to allow dynamic (inline) Groovy scripts</a>.</p>&#xA;&#xA;<p>Here's the code for the Groovy script filter:</p>&#xA;&#xA;<pre><code>def label_map = labels.collectEntries { entry -&gt; [entry, 1] };&#xA;def count = 0;&#xA;&#xA;for (def label : doc['label'].values) {&#xA;    if (!label_map.containsKey(label)) {&#xA;        return 0&#xA;    } else {&#xA;        count += 1&#xA;    }&#xA;};&#xA;&#xA;return count&#xA;</code></pre>&#xA;&#xA;<p>To use it in an Elasticsearch query, you either need to escape all the newline characters, or place the script on one line like this:</p>&#xA;&#xA;<pre><code>def label_map = labels.collectEntries { entry -&gt; [entry, 1] }; def count = 0; for (def label : doc['label'].values) { if (!label_map.containsKey(label)) { return 0 } else { count += 1 } }; return count&#xA;</code></pre>&#xA;&#xA;<p>Here's an Elasticsearch query that's very similar to what I did, including the script filter:</p>&#xA;&#xA;<pre><code>POST /documents/_search&#xA;{&#xA;   "fields": [&#xA;      "id",&#xA;      "name",&#xA;      "label",&#xA;      "description"&#xA;   ],&#xA;   "query": {&#xA;      "function_score": {&#xA;         "query": {&#xA;            "filtered": {&#xA;               "query": {&#xA;                  "bool": {&#xA;                     "minimum_should_match": 1,&#xA;                     "should" : {&#xA;                        "term" : {&#xA;                           "description" : "fine" &#xA;                        }&#xA;                     }&#xA;                 }&#xA;               },&#xA;               "filter": {&#xA;                  "script": {&#xA;                     "script": "def label_map = labels.collectEntries { entry -&gt; [entry, 1] }; def count = 0; for (def label : doc['label'].values) { if (!label_map.containsKey(label)) { return 0 } else { count += 1 } }; return count",&#xA;                     "lang": "groovy",&#xA;                     "params": {&#xA;                        "labels": [&#xA;                           "foo", &#xA;                           "bar", &#xA;                           "qux", &#xA;                           "zip", &#xA;                           "baz"&#xA;                        ]&#xA;                     }&#xA;                  }&#xA;               }&#xA;            }&#xA;         },&#xA;         "functions": [&#xA;            {&#xA;               "filter": {&#xA;                  "query": {&#xA;                     "match": {&#xA;                        "label": "qux"&#xA;                     }&#xA;                  }&#xA;               },&#xA;               "boost_factor": 25&#xA;            }&#xA;         ],&#xA;         "score_mode": "multiply"&#xA;      }&#xA;   },&#xA;   "size": 10&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>My actual query required combining the script filter with a function score query, which was hard to figure out how to do, so I'm including it here as an example.</p>&#xA;&#xA;<p>What this does is use the script filter to select documents whose labels are a subset of the labels passed in the query. For my use case (thousands of documents, not millions) this works very quickly - tens of milliseconds.</p>&#xA;&#xA;<p>The first time the script is used, it takes a long time (about 1000 ms), probably due to compilation and caching. But later invocations are 100 times faster.</p>&#xA;&#xA;<p>A couple of notes:</p>&#xA;&#xA;<ul>&#xA;<li>I used the <a href="https://chrome.google.com/webstore/detail/sense-beta/lhjgkmllcaadmopgmanpapmpjgmfcfig?hl=en" rel="nofollow">Sense console Chrome plugin</a> to debug the Elasticsearch query. Much better than using curl on the commandline! (Note that Sense is now part of <a href="https://www.elastic.co/guide/en/marvel/current/dashboards.html#sense" rel="nofollow">Marvel</a>, so you can also get it there.</li>&#xA;<li>To implement the Groovy script, I first installed the <a href="http://www.groovy-lang.org/" rel="nofollow">Groovy language</a> on my laptop, and wrote some unit tests, and implemented the script. Once I was sure that the script was working, I formatted it to fit on one line and put it into Sense.</li>&#xA;</ul>&#xA;