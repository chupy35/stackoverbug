33349315
Find distinct inner objects in Elasticsearch
<p>We're trying to find distinct inner objects in Elasticsearch. This would be a minimum example for our case.&#xA;We're stuck with something like the following mapping (changing types or indices or adding new fields wouldn't be a problem, but the structure should remain as it is):</p>&#xA;&#xA;<pre><code>{&#xA;  "building": {&#xA;    "properties": {&#xA;      "street": {&#xA;        "type": "string",&#xA;        "store": "yes",&#xA;        "index": "not_analyzed"&#xA;      },&#xA;      "house number": {&#xA;        "type": "string",&#xA;        "store": "yes",&#xA;        "index": "not_analyzed"&#xA;      },&#xA;      "city": {&#xA;        "type": "string",&#xA;        "store": "yes",&#xA;        "index": "not_analyzed"&#xA;      },&#xA;      "people": {&#xA;        "type": "object",&#xA;        "store": "yes",&#xA;        "index": "not_analyzed",&#xA;        "properties": {&#xA;          "firstName": {&#xA;            "type": "string",&#xA;            "store": "yes",&#xA;            "index": "not_analyzed"&#xA;          },&#xA;          "lastName": {&#xA;            "type": "string",&#xA;            "store": "yes",&#xA;            "index": "not_analyzed"&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Assuming we have this example data:</p>&#xA;&#xA;<pre><code>{&#xA;  "buildings": [&#xA;    {&#xA;      "street": "Baker Street",&#xA;      "house number": "221 B",&#xA;      "city": "London",&#xA;      "people": [&#xA;        {&#xA;          "firstName": "John",&#xA;          "lastName": "Doe"&#xA;        },&#xA;        {&#xA;          "firstName": "Jane",&#xA;          "lastName": "Doe"&#xA;        }&#xA;      ]&#xA;    },&#xA;    {&#xA;      "street": "Baker Street",&#xA;      "house number": "5",&#xA;      "city": "London",&#xA;      "people": [&#xA;        {&#xA;          "firstName": "John",&#xA;          "lastName": "Doe"&#xA;        }&#xA;      ]&#xA;    },&#xA;    {&#xA;      "street": "Garden Street",&#xA;      "house number": "1",&#xA;      "city": "London",&#xA;      "people": [&#xA;        {&#xA;          "firstName": "Jane",&#xA;          "lastName": "Smith"&#xA;        }&#xA;      ]&#xA;    }&#xA;  ]&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>When we query for the street "Baker Street" (and whatever additional options needed), we expect to get the following list:</p>&#xA;&#xA;<pre><code>[&#xA;    {&#xA;      "firstName": "John",&#xA;      "lastName": "Doe"&#xA;    },&#xA;    {&#xA;      "firstName": "Jane",&#xA;      "lastName": "Doe"&#xA;    }&#xA;]&#xA;</code></pre>&#xA;&#xA;<p>The format does not matter too much, but we should be able to parse the first and last name. Just, as our actual data-set is much larger, we need the entries to be distinct.</p>&#xA;&#xA;<p>We are using Elasticsearch 1.7.</p>&#xA;
<p>As suggested in the comment your mapping of people should be of type <code>nested</code> rather than <code>object</code> as it could give unexpected results. You also need to reindex your data after that.</p>&#xA;&#xA;<p>As for the question, You need to aggregate results based on your query.</p>&#xA;&#xA;<pre><code>{&#xA;  "query": {&#xA;    "term": {&#xA;      "street": "Baker Street"&#xA;    }&#xA;  },&#xA;  "aggs": {&#xA;    "distinct_people": {&#xA;      "terms": {&#xA;        "field": "people",&#xA;        "size": 1000&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Please note that I have set <code>size</code> to 1000 inside aggregation, you might have to use bigger number to get all distinct people, ES returns only 10 results by default.</p>&#xA;&#xA;<p>You could set the query <code>size</code> to 0 or use the parameter <code>search_type=count</code> if you are interested only in aggregated buckets.&#xA;You can read more about aggregations here. <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html" rel="nofollow">https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html</a></p>&#xA;&#xA;<p>I hope this helps!Let me know if this does not work out.</p>&#xA;
<p>We finally solved our problem.</p>&#xA;&#xA;<p>Our solution is (as we expected) a pre-calculated <code>people_all</code> field. But instead of using <code>copy_to</code> or <code>transform</code> we're just writing it as we are writing the other fields when importing our data. The field looks as follows:</p>&#xA;&#xA;<pre><code>"people": {&#xA;  "type": "nested",&#xA;  ..&#xA;  "properties": {&#xA;    "firstName": {&#xA;      "type": "string",&#xA;      "store": "yes",&#xA;      "index": "not_analyzed"&#xA;    },&#xA;    "lastName": {&#xA;      "type": "string",&#xA;      "store": "yes",&#xA;      "index": "not_analyzed"&#xA;    },&#xA;    "people_all": {&#xA;      "type": "string",&#xA;      "index": "not_analyzed"&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Please pay attention on the <code>"index": "not_analyzed"</code> at the <code>people_all</code> field. This is important to have complete buckets. If you don't use it, our example will return 3 buckets "john", "jane" and "doe".</p>&#xA;&#xA;<p>After writing this new field we can run an aggragetion as follows:</p>&#xA;&#xA;<pre><code>{&#xA;  "size": 0,&#xA;  "query": {&#xA;    "term": {&#xA;      "street": "Baker Street"&#xA;    }&#xA;  },&#xA;  "aggs": {&#xA;    "people_distinct": {&#xA;      "nested": {&#xA;        "path": "people"&#xA;      },&#xA;      "aggs": {&#xA;        "people_all_distinct": {&#xA;          "terms": {&#xA;            "field": "people.people_all",&#xA;            "size": 0&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>And we return the following response:</p>&#xA;&#xA;<pre><code>{&#xA;  "took": 2,&#xA;  "timed_out": false,&#xA;  "_shards": {&#xA;    "total": 5,&#xA;    "successful": 5,&#xA;    "failed": 0&#xA;  },&#xA;  "hits": {&#xA;    "total": 2,&#xA;    "max_score": 0.0,&#xA;    "hits": []&#xA;  },&#xA;  "aggregations": {&#xA;    "people_distinct": {&#xA;      "doc_count": 3,&#xA;      "people_name_distinct": {&#xA;        "doc_count_error_upper_bound": 0,&#xA;        "sum_other_doc_count": 0,&#xA;        "buckets": [&#xA;          {&#xA;            "key": "John Doe",&#xA;            "doc_count": 2&#xA;          },&#xA;          {&#xA;            "key": "Jane Doe",&#xA;            "doc_count": 1&#xA;          }&#xA;        ]&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Out of the buckets in the response we are now able to create the distinct people objects.</p>&#xA;&#xA;<p><strong>Please let us know if there is a better way to reach our goal.</strong>&#xA;Parsing the buckets is not an optimal solution and it would be more fancy to have the fields <code>firstName</code> and <code>lastName</code> in each bucket.</p>&#xA;