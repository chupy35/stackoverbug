34556584
Is it possible to search for specific scopes with elasticsearch?
<p>I need to perform text searches on documents based on the following scopes:</p>&#xA;&#xA;<ol>&#xA;<li>Whole document</li>&#xA;<li>Chapters</li>&#xA;<li>Paragraphs</li>&#xA;<li>Sentences</li>&#xA;</ol>&#xA;&#xA;<p>Is it possible to index a document so that you I can filter the scope of the query based on this requirement?</p>&#xA;&#xA;<p><strong>Edit due to the answers</strong></p>&#xA;&#xA;<p>I have now created the following index</p>&#xA;&#xA;<pre><code>{&#xA;  "settings": {&#xA;    "analysis": {&#xA;      "analyzer": {&#xA;        "folding": {&#xA;          "tokenizer": "standard",&#xA;          "filter": [ "lowercase", "asciifolding" ]&#xA;        }&#xA;      }&#xA;    }&#xA;  },&#xA;  "mappings": {&#xA;    "books": {&#xA;      "properties": {&#xA;        "content": {&#xA;          "type": "string",&#xA;          "fields": {&#xA;            "english": {&#xA;              "type": "string",&#xA;              "analyzer": "english"&#xA;            },&#xA;            "folded": {&#xA;              "type": "string",&#xA;              "analyzer": "folding"&#xA;            }&#xA;          }&#xA;        },&#xA;        "author": {&#xA;          "type": "string",&#xA;          "fields": {&#xA;            "raw": {&#xA;              "type": "string",&#xA;              "index": "not_analyzed"&#xA;            }&#xA;          }&#xA;        },&#xA;        "language": {&#xA;          "type": "string",&#xA;          "fields": {&#xA;            "raw": {&#xA;              "type": "string",&#xA;              "index": "not_analyzed"&#xA;            }&#xA;          }&#xA;        },&#xA;        "source": {&#xA;          "type": "string",&#xA;          "fields": {&#xA;            "raw": {&#xA;              "type": "string",&#xA;              "index": "not_analyzed"&#xA;            }&#xA;          }&#xA;        },&#xA;        "title": {&#xA;          "type": "string",&#xA;          "fields": {&#xA;            "raw": {&#xA;              "type": "string",&#xA;              "index": "not_analyzed"&#xA;            }&#xA;          }&#xA;        },&#xA;        "fileType": {&#xA;          "type": "string",&#xA;          "fields": {&#xA;            "raw": {&#xA;              "type": "string",&#xA;              "index": "not_analyzed"&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    },&#xA;    "sections": {&#xA;      "_parent": { "type": "books" },&#xA;      "properties": {&#xA;        "content": {&#xA;          "type": "string",&#xA;          "fields": {&#xA;            "english": {&#xA;              "type": "string",&#xA;              "analyzer": "english"&#xA;            },&#xA;            "folded": {&#xA;              "type": "string",&#xA;              "analyzer": "folding"&#xA;            }&#xA;          }&#xA;        },&#xA;        "paragraphs": {&#xA;          "type": "nested",&#xA;          "properties": {&#xA;            "paragraph": {&#xA;              "properties": {&#xA;                "page": { "type": "integer" },&#xA;                "number": { "type": "integer" },&#xA;                "html_tag": { "type": "string" },&#xA;                "content": { "type": "string" }&#xA;&#xA;              }&#xA;            }&#xA;          }&#xA;        },&#xA;        "author": {&#xA;          "type": "string",&#xA;          "fields": {&#xA;            "raw": {&#xA;              "type": "string",&#xA;              "index": "not_analyzed"&#xA;            }&#xA;          }&#xA;        },&#xA;        "language": {&#xA;          "type": "string",&#xA;          "fields": {&#xA;            "raw": {&#xA;              "type": "string",&#xA;              "index": "not_analyzed"&#xA;            }&#xA;          }&#xA;        },&#xA;        "source": {&#xA;          "type": "string",&#xA;          "fields": {&#xA;            "raw": {&#xA;              "type": "string",&#xA;              "index": "not_analyzed"&#xA;            }&#xA;          }&#xA;        },&#xA;        "title": {&#xA;          "type": "string",&#xA;          "fields": {&#xA;            "raw": {&#xA;              "type": "string",&#xA;              "index": "not_analyzed"&#xA;            }&#xA;          }&#xA;        },&#xA;        "fileType": {&#xA;          "type": "string",&#xA;          "fields": {&#xA;            "raw": {&#xA;              "type": "string",&#xA;              "index": "not_analyzed"&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    },&#xA;    "messages": {&#xA;      "properties": {&#xA;        "content": {&#xA;          "type": "string",&#xA;          "fields": {&#xA;            "english": {&#xA;              "type": "string",&#xA;              "analyzer": "english"&#xA;            },&#xA;            "folded": {&#xA;              "type": "string",&#xA;              "analyzer": "folding"&#xA;            }&#xA;          }&#xA;        },&#xA;        "paragraphs": {&#xA;          "type": "nested",&#xA;          "properties": {&#xA;            "paragraph": {&#xA;              "properties": {&#xA;                "page": { "type": "integer" },&#xA;                "number": { "type": "integer" },&#xA;                "html_tag": { "type": "string" },&#xA;                "content": { "type": "string" }&#xA;&#xA;              }&#xA;            }&#xA;          }&#xA;        },&#xA;        "author": {&#xA;          "type": "string",&#xA;          "fields": {&#xA;            "raw": {&#xA;              "type": "string",&#xA;              "index": "not_analyzed"&#xA;            }&#xA;          }&#xA;        },&#xA;        "language": {&#xA;          "type": "string",&#xA;          "fields": {&#xA;            "raw": {&#xA;              "type": "string",&#xA;              "index": "not_analyzed"&#xA;            }&#xA;          }&#xA;        },&#xA;        "source": {&#xA;          "type": "string",&#xA;          "fields": {&#xA;            "raw": {&#xA;              "type": "string",&#xA;              "index": "not_analyzed"&#xA;            }&#xA;          }&#xA;        },&#xA;        "title": {&#xA;          "type": "string",&#xA;          "fields": {&#xA;            "raw": {&#xA;              "type": "string",&#xA;              "index": "not_analyzed"&#xA;            }&#xA;          }&#xA;        },&#xA;        "fileType": {&#xA;          "type": "string",&#xA;          "fields": {&#xA;            "raw": {&#xA;              "type": "string",&#xA;              "index": "not_analyzed"&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Which gives me the following types: Books, Sections(parent Books) and Messages. Sections and Messages has the nested type Paragraphs and I have skipped the sentence level.</p>&#xA;&#xA;<p>I can now perform searches on content on the book level, content on the section level. Which allows me to search for words between paragraphs. I can also search directly on the paragraph level which is helpful if I want to match two words in a paragraph.</p>&#xA;&#xA;<p>Example: Let say  I have the following document</p>&#xA;&#xA;<pre><code>paragraph 1: It is a beautiful warm day.&#xA;paragraph 2: The cloud is clear.&#xA;</code></pre>&#xA;&#xA;<p>I can now search for beautiful AND cloud on the content level and get back the document. I do however not get back the document if I search for beautiful AND cloud on the paragraph level using nested search, which is what I wanted.</p>&#xA;&#xA;<p>The problems I see width this solution are:</p>&#xA;&#xA;<ol>&#xA;<li>I need to index the same paragraph 3 times. Once on the Paragraph level, once in the content Section level and once in the content Book level.</li>&#xA;<li>I do not understand what benefit I am getting from having parent/child relationship between Books and Sections. I haven't found any way of searching both at the same time using highlighting.</li>&#xA;<li>I need a separate Message type which is exactly the same as Section type without parent. Is there no way of having a children type without parents so that I can avoid an extra type?</li>&#xA;</ol>&#xA;
<p>To achieve this you can index all sentences and along with the words of the sentence you include the information about the enclosing context, i.e. in which paragraph, chapter and book is the given sentence. </p>&#xA;&#xA;<p>Then querying for terms will return you sentences and along with them the information about the chapter and book. With this information you know which sentence, paragraph, chapter or book is meant. </p>&#xA;&#xA;<p>Then you simply use whatever scope you're interested in. </p>&#xA;&#xA;<p>Example document to index:</p>&#xA;&#xA;<pre><code>{&#xA;    "book": &lt;book-id&gt;,&#xA;    "chapter": &lt;chapter-id&gt;,&#xA;    "paragraph": &lt;paragraph-id&gt;,&#xA;    "sentence": &lt;sentence-id&gt;,&#xA;    "sentence_text": "Here comes the text from a sentence in the indexed book"&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><strong>Additional answer after question clarification</strong></p>&#xA;&#xA;<p>To achieve this you could use different document types stored in the same index. Then you can use one query which will return documents of possibly different types (paragraphs, books, etc). Afterwards by filtering the result type, you get what you want. Here is an example:</p>&#xA;&#xA;<p><em>Entire book:</em></p>&#xA;&#xA;<pre><code>POST /books/book/1&#xA;{&#xA;    "text": "It is a beautiful warm day. The cloud is clear."&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><em>1st paragraph:</em></p>&#xA;&#xA;<pre><code>POST /books/para/1&#xA;{&#xA;    "text": "It is a beautiful warm day."&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><em>2nd paragraph:</em></p>&#xA;&#xA;<pre><code>POST /books/para/2&#xA;{&#xA;    "text": "The cloud is clear."&#xA;}&#xA;</code></pre>&#xA;&#xA;<p><em>Query to retrieve documents:</em></p>&#xA;&#xA;<pre><code>POST /books/_search&#xA;{&#xA;    "query": {&#xA;        "match": {&#xA;           "text": {&#xA;                "query": "beautiful cloud",&#xA;                "operator": "and"&#xA;           }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Does this solve your problem?</p>&#xA;
<p>An other alternative is to have a single document / book but have many <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/nested.html" rel="nofollow">nested documents</a> within, this way they can all share the same "book" context at the root level. It is up to you if you'd have one level of hierarchy (all sentences as nested documents) or more (capter => paragrap => sentence). A single level would keep queries simpler to write.</p>&#xA;&#xA;<pre><code>{&#xA;    "book": 123,&#xA;    "author": "Harry",&#xA;    "written": 1995,&#xA;    "sentences": [&#xA;        {&#xA;            "chapter": 1,&#xA;            "paragraph": 2,&#xA;            "sentence": 3,&#xA;            "text": "abc def"&#xA;        },&#xA;        {&#xA;            "chapter": 2,&#xA;            "paragraph": 3,&#xA;            "sentence": 4,&#xA;            "text": "ghi jkl"&#xA;        },&#xA;        { ... }&#xA;    ]&#xA;}&#xA;</code></pre>&#xA;