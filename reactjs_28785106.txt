28785106
ReactJS: Why is passing the component initial state a prop an anti-pattern?
<p>I've created a small ReactJS dashboard with the help of SocketIO for live updates. Even though I have the dashboard updating, it bugs me that I'm not quite sure if I did it correctly.</p>&#xA;&#xA;<p>What bugs me the most is the <a href="http://facebook.github.io/react/tips/props-in-getInitialState-as-anti-pattern.html">Props in getInitialState as anti-pattern</a> post. I've created a dashboard that gets live updates from a server, requiring no user interaction beyond loading the page. From what I've read, <code>this.state</code> should contain things that will determine whether the component should be re-rendered, and <code>this.props</code>.... I don't know yet.</p>&#xA;&#xA;<p>However, when you initially call <code>React.render(&lt;MyComponent /&gt;, ...)</code>, you can only pass props. In my case, I get all data from the server, so the initial props just end up in <code>this.state</code> anyway. So all of my components have something like this:</p>&#xA;&#xA;<pre><code>getInitialState: function() {&#xA;    return {&#xA;        progress: this.props.progress,&#xA;        latest_update: this.props.latest_update,&#xA;        nearest_center: this.props.nearest_center&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Which, unless I've misinterpreted the aforementioned blog post, is an anti-pattern. But I see no other way of injecting the state into the Component, and I don't understand why it's an anti-pattern unless I relabel all of my props to prepend <code>initial</code> on them. If anything, I feel like <em>that's</em> an anti-pattern because now I have to keep track of more variables than I did before (those prepended with <code>initial</code> and those without). </p>&#xA;
<blockquote>&#xA;  <p><strong>Disclaimer</strong>: When I answered this question I was learning / trying to&#xA;  implement vanilla Flux and I was a bit skeptic about it. Later on I&#xA;  migrated everything to Redux. So, an advice: Just go with Redux or&#xA;  MobX. Chances are you won't even need the answer to this question&#xA;  anymore (except for the science).</p>&#xA;</blockquote>&#xA;&#xA;<p>Passing the intial state to a component as a <code>prop</code> is an anti-pattern because the <code>getInitialState</code> method is only called the first time the component renders. Never more. Meaning that, if you re-render that component passing a <strong>different</strong> value as a <code>prop</code>, the component will not react accordingly, because the component will keep the state from the first time it was rendered. It's very error prone.</p>&#xA;&#xA;<p>And here is what you should do:</p>&#xA;&#xA;<p>Try to make your components as stateless as possible. Stateless components are easier to test because they render an <strong>output</strong> based on an <strong>input</strong>. Simple like that.</p>&#xA;&#xA;<p><strong>But hey.. my components data change.. I can't make them stateless</strong></p>&#xA;&#xA;<p>Yes you can, for most of them. In order to do that, select an outer component to be the state holder. Using your example, you could create a <code>Dashboard</code> component that contains the data, and a <code>Widget</code> component that is completely stateless. The <code>Dashboard</code> is responsible for getting all the data and then rendering multiple <code>Widgets</code> that receive everything they need through <code>props</code>.</p>&#xA;&#xA;<p><strong>But my widgets have some state.. the user can configure them. How do I make them stateless?</strong></p>&#xA;&#xA;<p>Your <code>Widget</code> can expose events that, when handled, cause the state contained in <code>Dashboard</code> to change, causing every <code>Widget</code> to be rerendered. You create "events" in your <code>Widget</code> by having <code>props</code> that receive a function.</p>&#xA;&#xA;<p><strong>Ok, so now, Dashboard keeps the state, but how do I pass the initial state to it?</strong></p>&#xA;&#xA;<p>You have two options. The most recomended one, is that you make an Ajax call in the <code>Dashboard</code> <code>getInitialState</code> method to get the initial state from the server. You can also use <a href="https://facebook.github.io/flux/" rel="noreferrer">Flux</a>, which is a more sophisticated way for managing data. Flux is more of a pattern, rather than an implementation. You can use pure Flux with the Facebook's implementation of the <code>Dispatcher</code>, but you can use third-party implementations like <a href="https://github.com/gaearon/redux" rel="noreferrer">Redux</a>, <a href="https://github.com/goatslacker/alt" rel="noreferrer">Alt</a> or <a href="https://github.com/BinaryMuse/fluxxor" rel="noreferrer">Fluxxor</a>.</p>&#xA;&#xA;<p>Alternatively, you can pass this initial state as a <code>prop</code> to the <code>Dashboard</code>, explicitly declaring that this is just the initial state.. like <code>initialData</code>, for instance. If you choose this path, though, you can't pass a different initial state to it aftwards, because it will "remember" the state after the first render.</p>&#xA;&#xA;<p><strong>OBS</strong></p>&#xA;&#xA;<p>You are not quite right in your definitions.</p>&#xA;&#xA;<p><strong>State</strong> is used to store mutable data, that is, data that is going to change during the component life-cycle. Changes in the state should be made through the <code>setState</code> method and will cause the component to re-render.</p>&#xA;&#xA;<p><strong>Props</strong> are used to pass in imutable data to the components. They should not change during the component life-cycle. Components that only use props are stateless.</p>&#xA;&#xA;<p><a href="https://stackoverflow.com/questions/27928296/reactjs-how-to-pass-the-initial-state-while-rendering-a-component">This</a> is a relevant source on the "how to pass the initial state to components".</p>&#xA;