31360902
Multiple document types with same mapping in Elasticseach
<p>I have index named <code>test</code> which can be associated to <code>n</code> number of documents types named <code>sub_test_1</code> to <code>sub_text_n</code>. But all will have same mapping.</p>&#xA;&#xA;<p>Is there any way to make an index such all document types have same mapping for their documents? I.e. <code>test\sub_text1\_mapping</code> should be same as <code>test\sub_text2\_mapping</code>.</p>&#xA;&#xA;<p>Otherwise if I have like <code>1000</code> document types, I will we having 1000 mappings of the same type referring to each document types.</p>&#xA;&#xA;<p>UPDATE:</p>&#xA;&#xA;<pre><code>PUT /test_index/&#xA;{&#xA;  "settings": {&#xA;    "index.store.type": "default",&#xA;    "index": {&#xA;        "number_of_shards": 5,&#xA;        "number_of_replicas": 1,&#xA;        "refresh_interval": "60s"&#xA;    },&#xA;    "analysis": {&#xA;        "filter": {&#xA;            "porter_stemmer_en_EN": {&#xA;                "type": "stemmer",&#xA;                "name": "porter"&#xA;            },&#xA;            "default_stop_name_en_EN": {&#xA;                "type": "stop",&#xA;                "name": "_english_"&#xA;            },&#xA;            "snowball_stop_words_en_EN": {&#xA;                "type": "stop",&#xA;                "stopwords_path": "snowball.stop"&#xA;            },&#xA;            "smart_stop_words_en_EN": {&#xA;                "type": "stop",&#xA;                "stopwords_path": "smart.stop"&#xA;            },&#xA;            "shingle_filter_en_EN": {&#xA;                "type": "shingle",&#xA;                "min_shingle_size": "2",&#xA;                "max_shingle_size": "2",&#xA;                "output_unigrams": true&#xA;            }&#xA;        }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Intended mapping:</p>&#xA;&#xA;<pre><code>{&#xA;  "sub_text" : {&#xA;    "properties" : {&#xA;      "_id" : {&#xA;        "include_in_all" : false,&#xA;        "type" : "string",&#xA;        "store" : true,&#xA;        "index" : "not_analyzed"&#xA;      },&#xA;      "alternate_id" : {&#xA;        "include_in_all" : false,&#xA;        "type" : "string",&#xA;        "store" : true,&#xA;        "index" : "not_analyzed"&#xA;      },&#xA;      "text" : {&#xA;        "type" : "multi_field",&#xA;        "fields" : {&#xA;          "text" : {&#xA;            "type" : "string",&#xA;            "store" : true,&#xA;            "index" : "analyzed",&#xA;          },&#xA;          "pdf": {&#xA;            "type" : "attachment",&#xA;            "fields" : {&#xA;                "pdf" : {&#xA;                    "type" : "string",&#xA;                    "store" : true,&#xA;                    "index" : "analyzed",&#xA;                }&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>I want this mapping to be an individual mapping for all <code>sub_text</code>s I create so that I can change it for one <code>sub_text</code> without affecting others e.g. I may want to add two custom analyzers to <code>sub_text1</code> and three analyzers to <code>sub_text3</code>, rest others will stay same.</p>&#xA;&#xA;<p>UPDATE:</p>&#xA;&#xA;<pre><code>PUT /my-index/document_set/_mapping&#xA;{&#xA;  "properties": {&#xA;    "type": {&#xA;      "type": "string",&#xA;      "index": "not_analyzed"&#xA;    },&#xA;    "doc_id": {&#xA;      "type": "string",&#xA;      "index": "not_analyzed"&#xA;    },&#xA;    "plain_text": {&#xA;      "type": "string",&#xA;      "store": true,&#xA;      "index": "analyzed"&#xA;    },&#xA;    "pdf_text": {&#xA;      "type": "attachment",&#xA;      "fields": {&#xA;        "pdf_text": {&#xA;          "type": "string",&#xA;          "store": true,&#xA;          "index": "analyzed"&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;POST /my-index/document_set/1&#xA;{&#xA;  "type": "d1",&#xA;  "doc_id": "1",&#xA;  "plain_text": "simple text for doc1."&#xA;}&#xA;&#xA;POST /my-index/document_set/2&#xA;{&#xA;  "type": "d1",&#xA;  "doc_id": "2",&#xA;  "pdf_text": "cGRmIHRleHQgaXMgaGVyZS4="&#xA;}&#xA;&#xA;POST /my-index/document_set/3&#xA;{&#xA;  "type": "d2",&#xA;  "doc_id": "3",&#xA;  "plain_text": "simple text for doc3 in d2."&#xA;}&#xA;&#xA;POST /my-index/document_set/4&#xA;{&#xA;  "type": "d2",&#xA;  "doc_id": "4",&#xA;  "pdf_text": "cGRmIHRleHQgaXMgaGVyZSBpbiBkMi4="&#xA;}&#xA;&#xA;GET /my-index/document_set/_search&#xA;{&#xA;  "query" : {&#xA;    "filtered" : {&#xA;      "filter" : {&#xA;        "term" : {&#xA;          "type" : "d1"&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>This gives me the documents related to type "d1". How to add analyzers only to document of type "d1"?</p>&#xA;
<p>At the moment a possible solution is to use <a href="https://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-templates.html" rel="nofollow">index templates</a> or <a href="https://www.elastic.co/guide/en/elasticsearch/reference/1.6/mapping-dynamic-mapping.html" rel="nofollow">dynamic mapping</a>. However they do not allow wildcard type matching so you would have to use the <code>_default_</code> root type to apply the mappings to all types in the index and thus it would be up to you to ensure that all your types can be applied to the same dynamic mapping. This template example may work for you:</p>&#xA;&#xA;<pre><code>curl -XPUT localhost:9200/_template/template_1 -d '&#xA;{&#xA;    "template" : "test",&#xA;    "mappings" : {&#xA;        "_default_" : {&#xA;            "dynamic": true,&#xA;            "properties": {&#xA;                "field1": {&#xA;                   "type": "string",&#xA;                   "index": "not_analyzed"&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;'&#xA;</code></pre>&#xA;
<p>Do not do this.</p>&#xA;&#xA;<blockquote>&#xA;  <p>Otherwise if I have like 1000 document types, I will we having 1000 mappings of the same type referring to each document types.</p>&#xA;</blockquote>&#xA;&#xA;<p>You're exactly right. For every additional <code>_type</code> <em>with an identical mapping</em> you are needlessly adding to the size of your index's mapping. They will not be merged, nor will any compression save you.</p>&#xA;&#xA;<p>A much better solution is to simply create a shared <code>_type</code> and to create a field that represents the intended type. This completely avoids having wasted mappings and all of the negatives associated with it, including an unnecessary increase for your cluster state's size.</p>&#xA;&#xA;<p>From there, you can imitate what Elasticsearch is doing for you and filter on <em>your</em> custom type without ballooning your mappings.</p>&#xA;&#xA;<pre><code>$ curl -XPUT localhost:9200/my-index -d '{&#xA;  "mappings" : {&#xA;    "my-type" : {&#xA;      "properties" : {&#xA;        "type" : {&#xA;          "type" : "string",&#xA;          "index" : "not_analyzed"&#xA;        },&#xA;        # ... whatever other mappings exist ...&#xA;      }&#xA;    }&#xA;  }&#xA;}'&#xA;</code></pre>&#xA;&#xA;<p>Then, for any search against <code>sub_text1</code> (etc.), then you can do a <code>term</code> (for one) or <code>terms</code> (for more than one) filter to imitate the <code>_type</code> filter that would happen for you.</p>&#xA;&#xA;<pre><code>$ curl -XGET localhost:9200/my-index/my-type/_search -d '{&#xA;  "query" : {&#xA;    "filtered" : {&#xA;      "filter" : {&#xA;        "term" : {&#xA;          "type" : "sub_text1"&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}'&#xA;</code></pre>&#xA;&#xA;<p>This is doing the same thing as the <code>_type</code> filter and you can create <code>_alias</code>es that contain the filter <em>if</em> you want to have the higher level search capability without exposing client-level logic to the filtering.</p>&#xA;