24147331
React – the right way to pass form element state to sibling/parent elements?
<ul>&#xA;<li>Suppose I have a React class P, which renders two child classes, C1 and C2.  </li>&#xA;<li>C1 contains an input field. I'll refer to this input field as Foo.  </li>&#xA;<li>My goal is to let C2 react to changes in Foo.  </li>&#xA;</ul>&#xA;&#xA;<p>I've come up with two solutions, but neither of them feels quite right.</p>&#xA;&#xA;<p>First solution:  </p>&#xA;&#xA;<ol>&#xA;<li>Assign P a state, <code>state.input</code>.</li>&#xA;<li>Create an <code>onChange</code> function in P, which takes in an event and sets <code>state.input</code>.</li>&#xA;<li>Pass this <code>onChange</code> to C1 as a <code>props</code>, and let C1 bind <code>this.props.onChange</code> to the <code>onChange</code> of Foo.</li>&#xA;</ol>&#xA;&#xA;<p>This works. Whenever the value of Foo changes, it triggers a <code>setState</code> in P, so P will have the input to pass to C2.</p>&#xA;&#xA;<p>But it doesn't feel quite right for the same reason: I'm setting the state of a parent element from a child element. This seems to betray the design principle of React: single-direction data flow.<br>&#xA;<strong>Is this how I'm supposed to do it, or is there a more React-natural solution?</strong></p>&#xA;&#xA;<p>Second solution:</p>&#xA;&#xA;<p>Just put Foo in P.</p>&#xA;&#xA;<p><strong>But is this a design principle I should follow when I structure my app—putting all form elements in the <code>render</code> of the highest-level class?</strong></p>&#xA;&#xA;<p>Like in my example, if I have a large rendering of C1, I really don't want to put the whole <code>render</code> of C1 to <code>render</code> of P just because C1 has a form element.</p>&#xA;&#xA;<p>How should I do it?</p>&#xA;
<p>So, if I'm understanding you correctly, your first solution is suggesting that you're keeping state in your root component? I can't speak for the creators of React, but generally, I find this to be a proper solution. </p>&#xA;&#xA;<p>Maintaining state is one of the reasons (at least I think) that React was created. If you've ever implemented your own state pattern client side for dealing with a dynamic UI that has a lot of interdependent moving pieces, then you'll love React, because it alleviates a lot of this state management pain. </p>&#xA;&#xA;<p>By keeping state further up in the hierarchy, and updating it through eventing, your data flow is still pretty much unidirectional, you're just responding to events in the Root component, you're not really getting the data there via two way binding, you're telling the Root component that "hey, something happened down here, check out the values" or you're passing the state of some data in the child component up in order to update the state. You changed the state in C1, and you want C2 to be aware of it, so, by updating the state in the Root component and re-rendering, C2's props are now in sync since the state was updated in the Root component and passed along.</p>&#xA;&#xA;<pre class="lang-jsx prettyprint-override"><code>class Example extends React.Component {&#xA;  constructor (props) {&#xA;    super(props)&#xA;    this.state = { data: 'test' }&#xA;  }&#xA;  render () {&#xA;    return (&#xA;      &lt;div&gt;&#xA;        &lt;C1 onUpdate={this.onUpdate.bind(this)}/&gt;&#xA;        &lt;C2 data={this.state.data}/&gt;&#xA;      &lt;/div&gt;&#xA;    )&#xA;  }&#xA;  onUpdate (data) { this.setState({ data }) }&#xA;}&#xA;&#xA;class C1 extends React.Component {&#xA;    render () {&#xA;      return (&#xA;        &lt;div&gt;&#xA;          &lt;input type='text' ref='myInput'/&gt;&#xA;          &lt;input type='button' onClick={this.update.bind(this)} value='Update C2'/&gt;&#xA;        &lt;/div&gt;&#xA;      )&#xA;    }&#xA;    update () {&#xA;      this.props.onUpdate(this.refs.myInput.getDOMNode().value)&#xA;    }&#xA;})&#xA;&#xA;class C2 extends React.Component {&#xA;    render () {&#xA;      return &lt;div&gt;{this.props.data}&lt;/div&gt;&#xA;    }&#xA;})&#xA;&#xA;ReactDOM.renderComponent(&lt;Example/&gt;, document.body)&#xA;</code></pre>&#xA;
<p>Having used React to build an app now, I'd like to share some thoughts to this question I asked half a year ago.</p>&#xA;&#xA;<p>I recommend you to read</p>&#xA;&#xA;<ul>&#xA;<li><a href="https://facebook.github.io/react/docs/thinking-in-react.html">Thinking in React</a></li>&#xA;<li><a href="https://facebook.github.io/flux/">Flux</a></li>&#xA;</ul>&#xA;&#xA;<p>The first post is extremely helpful to understanding how you should structure your React app. </p>&#xA;&#xA;<p>Flux answers the question <strong>why</strong> should you structure your React app this way (as opposed to <strong>how</strong> to structure it). React is only 50% of the system, and with Flux you get to see the whole picture and see how they constitute a coherent system. </p>&#xA;&#xA;<p>Back to the question.</p>&#xA;&#xA;<p>As for my first solution, it is totally OK to let the <strong>handler</strong> go the reverse direction, as the <strong>data</strong> is still going single-direction.</p>&#xA;&#xA;<p>However, whether letting a handler trigger a setState in P can be right or wrong depending on your situation.</p>&#xA;&#xA;<p>If the app is a simple Markdown converter, C1 being the raw input and C2 being the HTML output, it's OK to let C1 trigger a setState in P, but some might argue this is not the recommended way to do it.</p>&#xA;&#xA;<p>However, if the app is a todo list, C1 being the input for creating a new todo, C2 the todo list in HTML, you probably want to handler to go two level up than P -- to the <code>dispatcher</code>, which let the <code>store</code> update the <code>data store</code>, which then send the data to P and populate the views. See that Flux article. Here is an example: <a href="https://github.com/facebook/flux/tree/master/examples/flux-todomvc">Flux - TodoMVC</a></p>&#xA;&#xA;<p>Generally, I prefer the way described in the todo list example. The less state you have in your app the better. </p>&#xA;
<p>You should learn Redux and ReactRedux library.It will structure your states and props in one store and you can access them later in your components .</p>&#xA;
<ol>&#xA;<li>The right thing to do is to have the <strong>state in the parent component</strong>, to avoid ref and what not</li>&#xA;<li>An issue is to avoid <strong>constantly updating all children</strong> when typing into a field</li>&#xA;<li>Therefore, each child should be a Component (as in not a PureComponent) and implement <code>shouldComponentUpdate(nextProps, nextState)</code></li>&#xA;<li>This way, when typing into a form field, only that field updates</li>&#xA;</ol>&#xA;&#xA;<p>The code below uses <code>@bound</code> annotations from <strong>ES.Next</strong> <code>babel-plugin-transform-decorators-legacy</code> of <strong>BabelJS 6</strong> and class-properties (the annotation  sets this value on member functions similar to bind):</p>&#xA;&#xA;<pre class="lang-js prettyprint-override"><code>/*&#xA;© 2017-present Harald Rudell &lt;harald.rudell@gmail.com&gt; (http://www.haraldrudell.com)&#xA;All rights reserved.&#xA;*/&#xA;import React, {Component} from 'react'&#xA;import {bound} from 'class-bind'&#xA;&#xA;const m = 'Form'&#xA;&#xA;export default class Parent extends Component {&#xA;  state = {one: 'One', two: 'Two'}&#xA;&#xA;  @bound submit(e) {&#xA;    e.preventDefault()&#xA;    const values = {...this.state}&#xA;    console.log(`${m}.submit:`, values)&#xA;  }&#xA;&#xA;  @bound fieldUpdate({name, value}) {&#xA;    this.setState({[name]: value})&#xA;  }&#xA;&#xA;  render() {&#xA;    console.log(`${m}.render`)&#xA;    const {state, fieldUpdate, submit} = this&#xA;    const p = {fieldUpdate}&#xA;    return (&#xA;      &lt;form onSubmit={submit}&gt; {/* loop removed for clarity */}&#xA;        &lt;Child name='one' value={state.one} {...p} /&gt;&#xA;        &lt;Child name='two' value={state.two} {...p} /&gt;&#xA;        &lt;input type="submit" /&gt;&#xA;      &lt;/form&gt;&#xA;    )&#xA;  }&#xA;}&#xA;&#xA;class Child extends Component {&#xA;  value = this.props.value&#xA;&#xA;  @bound update(e) {&#xA;    const {value} = e.target&#xA;    const {name, fieldUpdate} = this.props&#xA;    fieldUpdate({name, value})&#xA;  }&#xA;&#xA;  shouldComponentUpdate(nextProps) {&#xA;    const {value} = nextProps&#xA;    const doRender = value !== this.value&#xA;    if (doRender) this.value = value&#xA;    return doRender&#xA;  }&#xA;&#xA;  render() {&#xA;    console.log(`Child${this.props.name}.render`)&#xA;    const {value} = this.props&#xA;    const p = {value}&#xA;    return &lt;input {...p} onChange={this.update} /&gt;&#xA;  }&#xA;}&#xA;</code></pre>&#xA;
<p>The first solution, with <a href="https://kolosek.com/react-props-communication" rel="nofollow noreferrer">keeping the state in parent component</a>, is <em>the correct one</em>. However, for more complex problems, you should think about some <em>state management library</em>, <a href="https://redux.js.org/" rel="nofollow noreferrer">redux</a> is the most popular one used with react.</p>&#xA;
<p>The concept of passing data from parent to child and vice versa is explained. </p>&#xA;&#xA;<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">&#xD;&#xA;<div class="snippet-code">&#xD;&#xA;<pre class="snippet-code-js lang-js prettyprint-override"><code>import React, { Component } from "react";&#xD;&#xA;import ReactDOM from "react-dom";&#xD;&#xA;&#xD;&#xA;// taken refrence from https://gist.github.com/sebkouba/a5ac75153ef8d8827b98&#xD;&#xA;&#xD;&#xA;//example to show how to send value between parent and child&#xD;&#xA;&#xD;&#xA;//  props is the data which is passed to the child component from the parent component&#xD;&#xA;&#xD;&#xA;class Parent extends Component {&#xD;&#xA;  constructor(props) {&#xD;&#xA;    super(props);&#xD;&#xA;&#xD;&#xA;    this.state = {&#xD;&#xA;      fieldVal: ""&#xD;&#xA;    };&#xD;&#xA;  }&#xD;&#xA;&#xD;&#xA;  onUpdateParent = val =&gt; {&#xD;&#xA;    this.setState({&#xD;&#xA;      fieldVal: val&#xD;&#xA;    });&#xD;&#xA;  };&#xD;&#xA;&#xD;&#xA;  render() {&#xD;&#xA;    return (&#xD;&#xA;      // To achieve the child-parent communication, we can send a function&#xD;&#xA;      // as a Prop to the child component. This function should do whatever&#xD;&#xA;      // it needs to in the component e.g change the state of some property.&#xD;&#xA;      //we are passing the function onUpdateParent to the child&#xD;&#xA;      &lt;div&gt;&#xD;&#xA;        &lt;h2&gt;Parent&lt;/h2&gt;&#xD;&#xA;        Value in Parent Component State: {this.state.fieldVal}&#xD;&#xA;        &lt;br /&gt;&#xD;&#xA;        &lt;Child onUpdate={this.onUpdateParent} /&gt;&#xD;&#xA;        &lt;br /&gt;&#xD;&#xA;        &lt;OtherChild passedVal={this.state.fieldVal} /&gt;&#xD;&#xA;      &lt;/div&gt;&#xD;&#xA;    );&#xD;&#xA;  }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;class Child extends Component {&#xD;&#xA;  constructor(props) {&#xD;&#xA;    super(props);&#xD;&#xA;&#xD;&#xA;    this.state = {&#xD;&#xA;      fieldValChild: ""&#xD;&#xA;    };&#xD;&#xA;  }&#xD;&#xA;&#xD;&#xA;  updateValues = e =&gt; {&#xD;&#xA;    console.log(e.target.value);&#xD;&#xA;    this.props.onUpdate(e.target.value);&#xD;&#xA;    // onUpdateParent would be passed here and would result&#xD;&#xA;    // into onUpdateParent(e.target.value) as it will replace this.props.onUpdate&#xD;&#xA;    //with itself.&#xD;&#xA;    this.setState({ fieldValChild: e.target.value });&#xD;&#xA;  };&#xD;&#xA;&#xD;&#xA;  render() {&#xD;&#xA;    return (&#xD;&#xA;      &lt;div&gt;&#xD;&#xA;        &lt;h4&gt;Child&lt;/h4&gt;&#xD;&#xA;        &lt;input&#xD;&#xA;          type="text"&#xD;&#xA;          placeholder="type here"&#xD;&#xA;          onChange={this.updateValues}&#xD;&#xA;          value={this.state.fieldVal}&#xD;&#xA;        /&gt;&#xD;&#xA;      &lt;/div&gt;&#xD;&#xA;    );&#xD;&#xA;  }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;class OtherChild extends Component {&#xD;&#xA;  render() {&#xD;&#xA;    return (&#xD;&#xA;      &lt;div&gt;&#xD;&#xA;        &lt;h4&gt;OtherChild&lt;/h4&gt;&#xD;&#xA;        Value in OtherChild Props: {this.props.passedVal}&#xD;&#xA;        &lt;h5&gt;&#xD;&#xA;          the child can directly get the passed value from parent by this.props{" "}&#xD;&#xA;        &lt;/h5&gt;&#xD;&#xA;      &lt;/div&gt;&#xD;&#xA;    );&#xD;&#xA;  }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;ReactDOM.render(&lt;Parent /&gt;, document.getElementById("root"));</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;