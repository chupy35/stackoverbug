32400244
How to get count of distinct values meeting certain minimum date
<p>I have documents with the following structure (simplified):</p>&#xA;&#xA;<pre><code>curl -XPOST "http://localhost:9200/test/aggtest/1" -d "{&#xA;    \"user_id\": 123,&#xA;    \"date_created\": \"2015-05-12T10:29:49-04:00\"&#xA;}"&#xA;&#xA;curl -XPOST "http://localhost:9200/test/aggtest/2" -d "{&#xA;    \"user_id\": 123,&#xA;    \"date_created\": \"2014-05-12T10:29:49-04:00\"&#xA;}"&#xA;&#xA;curl -XPOST "http://localhost:9200/test/aggtest/3" -d "{&#xA;    \"user_id\": 123,&#xA;    \"date_created\": \"2013-05-12T10:29:49-04:00\"&#xA;}"&#xA;&#xA;curl -XPOST "http://localhost:9200/test/aggtest/4" -d "{&#xA;    \"user_id\": 456,&#xA;    \"date_created\": \"2015-05-12T10:29:49-04:00\"&#xA;}"&#xA;&#xA;curl -XPOST "http://localhost:9200/test/aggtest/5" -d "{&#xA;    \"user_id\": 456,&#xA;    \"date_created\": \"2012-05-12T10:29:49-04:00\"&#xA;}"&#xA;&#xA;curl -XPOST "http://localhost:9200/test/aggtest/6" -d "{&#xA;    \"user_id\": 456,&#xA;    \"date_created\": \"2011-05-12T10:29:49-04:00\"&#xA;}"&#xA;</code></pre>&#xA;&#xA;<p>How can i get a count of <code>user_ids</code> which was created before or after a certain date? E.g. In aforementioned documents there will be only one unique <code>user_id</code> who has records after 2012. </p>&#xA;&#xA;<p>In mongodb it's fairly simple. Using aggregation framework i can transform documents where will be one unique user id and its minimum creation date. Then just filter results by date and count. I'm unable to write similar query in elasticsearch. Any help appreciated.</p>&#xA;&#xA;<p>In SQL this query should look like this:</p>&#xA;&#xA;<pre><code> SELECT COUNT(DISTINCT(user_id)) FROM aggtest WHERE date_created &gt;= 2015 AND user_id NOT IN (SELECT user_id FROM aggtest WHERE date_created &lt; 2015)&#xA;</code></pre>&#xA;
<p>Use the cardinality aggregation to get the distinct count of values in a field: <a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/cardinality.html" rel="nofollow">https://www.elastic.co/guide/en/elasticsearch/guide/current/cardinality.html</a></p>&#xA;&#xA;<p>Combine the aggregation with the range filter to limit the results to a time frame: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-filter.html" rel="nofollow">https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-filter.html</a></p>&#xA;&#xA;<p>Example:</p>&#xA;&#xA;<pre><code>GET /test/aggtest/_search&#xA;{&#xA;  "size": 0,&#xA;  "query": {&#xA;    "filtered" : {&#xA;        "filter" : {&#xA;            "range" : {&#xA;                "date_created" : {&#xA;                    "gte": "2015-09-01"&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;  },&#xA;  "aggs" : {&#xA;    "distinct_user_ids" : {&#xA;      "cardinality" : {&#xA;        "field" : "user_id"&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>You will get an aggregation result with a <code>doc_count</code> for the <code>distinct_user_ids</code> aggregation.</p>&#xA;
<p>From reading the comments I think I understand what you're asking, though it's not completely clear from the original question.</p>&#xA;&#xA;<p>It sounds like you want to find unique <code>user_id</code>s for which there are <code>creation_date</code>s after some date, but none before.</p>&#xA;&#xA;<p>I can't think of a way to do that with your current data structure, but if you're willing to reorganize your data using the <a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/parent-child.html" rel="nofollow">parent/child relationship</a>, it's fairly straightforward to set up the query you want.</p>&#xA;&#xA;<p>To test it, I set up an index with two types, as follows:</p>&#xA;&#xA;<pre><code>PUT /test_index&#xA;{&#xA;   "mappings": {&#xA;      "user": {&#xA;         "_id": {&#xA;            "path": "user_id"&#xA;         },&#xA;         "properties": {&#xA;            "user_id": {&#xA;               "type": "integer"&#xA;            }&#xA;         }&#xA;      },&#xA;      "creation_date": {&#xA;         "_parent": {&#xA;            "type": "user"&#xA;         }, &#xA;         "properties": {&#xA;            "date_created": {&#xA;               "type": "date",&#xA;               "format": "dateOptionalTime"&#xA;            }&#xA;         }&#xA;      }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Then I indexed the data you provided using the new schema:</p>&#xA;&#xA;<pre><code>POST /test_index/_bulk&#xA;{"index":{"_type":"user"}}&#xA;{"user_id":123}&#xA;{"index":{"_type":"creation_date","_parent":123}}&#xA;{"date_created":"2015-05-12T10:29:49-04:00"}&#xA;{"index":{"_type":"creation_date","_parent":123}}&#xA;{"date_created":"2014-05-12T10:29:49-04:00"}&#xA;{"index":{"_type":"creation_date","_parent":123}}&#xA;{"date_created":"2013-05-12T10:29:49-04:00"}&#xA;{"index":{"_type":"user"}}&#xA;{"user_id":456}&#xA;{"index":{"_type":"creation_date","_parent":456}}&#xA;{"date_created":"2015-05-12T10:29:49-04:00"}&#xA;{"index":{"_type":"creation_date","_parent":456}}&#xA;{"date_created":"2012-05-12T10:29:49-04:00"}&#xA;{"index":{"_type":"creation_date","_parent":456}}&#xA;{"date_created":"2011-05-12T10:29:49-04:00"}&#xA;</code></pre>&#xA;&#xA;<p>Now I can get back what you're asking (assuming I understand correctly) with the following query. In words, I want to filter the (parent) <code>user</code> documents by those who have at least one (child) <code>creation_date</code> greater than or equal to <code>"2012-05-12"</code>, but DO NOT have any (child) <code>creation_date</code>s less than <code>"2012-05-12"</code>, and then I want to show those ids in an aggregation (the aggregation is sort of redundant here, but I'm assuming your real index is more complicated so it could be useful not to return the full <code>user</code> documents):</p>&#xA;&#xA;<pre><code>POST /test_index/user/_search?search_type=count&#xA;{&#xA;   "query": {&#xA;      "filtered": {&#xA;         "filter": {&#xA;            "bool": {&#xA;               "must": [&#xA;                  {&#xA;                     "has_child": {&#xA;                        "type": "creation_date",&#xA;                        "filter": {&#xA;                           "range": {&#xA;                              "date_created": {&#xA;                                 "gte": "2012-05-12"&#xA;                              }&#xA;                           }&#xA;                        }&#xA;                     }&#xA;                  },&#xA;                  {&#xA;                     "not": {&#xA;                        "filter": {&#xA;                           "has_child": {&#xA;                              "type": "creation_date",&#xA;                              "filter": {&#xA;                                 "range": {&#xA;                                    "date_created": {&#xA;                                       "lt": "2012-05-12"&#xA;                                    }&#xA;                                 }&#xA;                              }&#xA;                           }&#xA;                        }&#xA;                     }&#xA;                  }&#xA;               ]&#xA;            }&#xA;         }&#xA;      }&#xA;   },&#xA;   "aggs": {&#xA;      "distinct_user_ids": {&#xA;         "terms": {&#xA;            "field": "user_id"&#xA;         }&#xA;      }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>which returns:</p>&#xA;&#xA;<pre><code>{&#xA;   "took": 2,&#xA;   "timed_out": false,&#xA;   "_shards": {&#xA;      "total": 1,&#xA;      "successful": 1,&#xA;      "failed": 0&#xA;   },&#xA;   "hits": {&#xA;      "total": 1,&#xA;      "max_score": 0,&#xA;      "hits": []&#xA;   },&#xA;   "aggregations": {&#xA;      "distinct_user_ids": {&#xA;         "doc_count_error_upper_bound": 0,&#xA;         "sum_other_doc_count": 0,&#xA;         "buckets": [&#xA;            {&#xA;               "key": 123,&#xA;               "doc_count": 1&#xA;            }&#xA;         ]&#xA;      }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Here is all the code I used to test it:</p>&#xA;&#xA;<p><a href="http://sense.qbox.io/gist/1fbe448a85b9c74cb25cd5245d4e77f1eec46ea7" rel="nofollow">http://sense.qbox.io/gist/1fbe448a85b9c74cb25cd5245d4e77f1eec46ea7</a></p>&#xA;