30900043
ElasticSearch: How to search on different fields that are not related that are arrays of objects
<p><strong><em>I want to search on different fields that are not related that are arrays of objects. I cannot find out how.</em></strong></p>&#xA;&#xA;<p>Given the following mapping and data entry: I want to give the user the ability to search all possible fields in any combination. The user would use a form with a keyword input, exclude keyword input, date ranges and multi-select drop down lists. What does that query look like? I have included a couple of my failed queries and filters below the data entry.</p>&#xA;&#xA;<p><strong>Mapping</strong></p>&#xA;&#xA;<p><div class="snippet" data-lang="js" data-hide="false">&#xD;&#xA;<div class="snippet-code">&#xD;&#xA;<pre class="snippet-code-js lang-js prettyprint-override"><code>{&#xD;&#xA;    "plants" : {&#xD;&#xA;        "properties" : {&#xD;&#xA;            "name" : {"type" : "string"},&#xD;&#xA;            "description" : {"type" : "string"},&#xD;&#xA;            "planting" : {"type" : "string"},&#xD;&#xA;            "maintenance" : {"type" : "string"},&#xD;&#xA;            "type" : {"type" : "integer"},&#xD;&#xA;            "petals" : {&#xD;&#xA;                "properties" : {&#xD;&#xA;                    "color" : {"type" : "string"}&#xD;&#xA;                }&#xD;&#xA;            },&#xD;&#xA;            "species" : {&#xD;&#xA;                "properties" : {&#xD;&#xA;                    "name" : {"type" : "string"},&#xD;&#xA;                    "subspecies" : {&#xD;&#xA;                        "properties" : {&#xD;&#xA;                            "name" : {"type" : "string"}&#xD;&#xA;                        }&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;            },&#xD;&#xA;            "pests" : {&#xD;&#xA;                "properties" : {&#xD;&#xA;                    "pest" : {"type" : "string"}&#xD;&#xA;                }&#xD;&#xA;            },&#xD;&#xA;            "diseases" : {&#xD;&#xA;                "properties" : {&#xD;&#xA;                    "disease" : {"type" : "string"}&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;&#xA;<p><strong>Data Entry: Rose</strong></p>&#xA;&#xA;<p><div class="snippet" data-lang="js" data-hide="false">&#xD;&#xA;<div class="snippet-code">&#xD;&#xA;<pre class="snippet-code-js lang-js prettyprint-override"><code>{&#xD;&#xA;    "name" : "Rose",&#xD;&#xA;    "description" : "A few paragraphs of text",&#xD;&#xA;    "planting" : "A few paragraphs of text",&#xD;&#xA;    "maintenance" : "A few paragraphs of text",&#xD;&#xA;    "type" : "Perennial",&#xD;&#xA;    "petals" : [&#xD;&#xA;        {"color" : "Red"},&#xD;&#xA;        {"color" : "White"},&#xD;&#xA;        {"color" : "Yellow"},&#xD;&#xA;        {"color" : "Pink"},&#xD;&#xA;        {"color" : "Orange"},&#xD;&#xA;        {"color" : "Purple"}&#xD;&#xA;    ],&#xD;&#xA;    "species" : [&#xD;&#xA;        {&#xD;&#xA;            "name" : "Hulthemia",&#xD;&#xA;            "description" : "A few paragraphs of text",&#xD;&#xA;            "subspecies" : []&#xD;&#xA;        },&#xD;&#xA;        {&#xD;&#xA;            "name" : "Hesperrhodos",&#xD;&#xA;            "description" : "A few paragraphs of text",&#xD;&#xA;            "subspecies" : []&#xD;&#xA;        },&#xD;&#xA;        {&#xD;&#xA;            "name" : "Platyrhodon",&#xD;&#xA;            "description" : "A few paragraphs of text",&#xD;&#xA;            "subspecies" : []&#xD;&#xA;        },&#xD;&#xA;        {&#xD;&#xA;            "name" : "Rosa",&#xD;&#xA;            "description" : "A few paragraphs of text",&#xD;&#xA;            "subspecies" : [&#xD;&#xA;                {"name" : "Banksianae"},&#xD;&#xA;                {"name" : "Bracteatae"},&#xD;&#xA;                {"name" : "Caninae"},&#xD;&#xA;                {"name" : "Carolinae"},&#xD;&#xA;                {"name" : "Chinensis"},&#xD;&#xA;                {"name" : "Gallicanae"},&#xD;&#xA;                {"name" : "Gymnocarpae"},&#xD;&#xA;                {"name" : "Laevigatae"},&#xD;&#xA;                {"name" : "Pimpinellifoliae"},&#xD;&#xA;                {"name" : "Cinnamomeae"},&#xD;&#xA;                {"name" : "Synstylae"}&#xD;&#xA;            ]&#xD;&#xA;        }&#xD;&#xA;    ],&#xD;&#xA;    "pests" : [],&#xD;&#xA;    "diseases" : []&#xD;&#xA;}</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;&#xA;<p><strong>Query</strong></p>&#xA;&#xA;<p>For example I have success with the following query, but it's not accurate on a large data set of 100k to 10M data entries (not flowers and MANY fields). I am searching on multiple fields that have multiple exact value matches while wanting to have a relevance score for each entry. The option for "minimum_should_match" does not make sense when I want flowers that "petal.color" are "purple", "pink" and/or "white" as well as searching against two more fields that are lists like "petals" or strings like "type". I could set "minimum_should_match" equal to two, but then <strong>flowers with multiple "petal.color" will meet that requirement and I will get "type" that are not "Perennial" or "Annual" such as "Biennials"</strong>. I looked into filter and have that as my next example.</p>&#xA;&#xA;<p><div class="snippet" data-lang="js" data-hide="false">&#xD;&#xA;<div class="snippet-code">&#xD;&#xA;<pre class="snippet-code-js lang-js prettyprint-override"><code>{&#xD;&#xA;    "query" : {&#xD;&#xA;        "bool" : {&#xD;&#xA;            "must" : [&#xD;&#xA;                {&#xD;&#xA;                    "multi_match":{&#xD;&#xA;                        "query":"disease resistant",&#xD;&#xA;                        "type":"cross_fields",&#xD;&#xA;                        "fields":[&#xD;&#xA;                            "description",&#xD;&#xA;                            "planting",&#xD;&#xA;                            "maintenance",&#xD;&#xA;                            "name"&#xD;&#xA;                        ],&#xD;&#xA;                        "tie_breaker":0.3&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;            ],&#xD;&#xA;            "must_not" : [&#xD;&#xA;                {&#xD;&#xA;                    "multi_match":{&#xD;&#xA;                        "query":"lavender",&#xD;&#xA;                        "type":"cross_fields",&#xD;&#xA;                        "fields":[&#xD;&#xA;                            "description",&#xD;&#xA;                            "planting",&#xD;&#xA;                            "maintenance",&#xD;&#xA;                            "name"&#xD;&#xA;                        ],&#xD;&#xA;                        "tie_breaker":0.3&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;            ],&#xD;&#xA;            "should" : [&#xD;&#xA;                {"match" : {"type" : "Perennial"}},&#xD;&#xA;                {"match" : {"type" : "Annual"}},&#xD;&#xA;                {"match" : {"petals.color" : "purple"}},&#xD;&#xA;                {"match" : {"petals.color" : "pink"}},&#xD;&#xA;                {"match" : {"petals.color" : "white"}}&#xD;&#xA;            ]&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;&#xA;<p><strong>Query using Terms</strong></p>&#xA;&#xA;<p>The following is an attempt on using "terms". I'm not sure why it does not work.</p>&#xA;&#xA;<p><div class="snippet" data-lang="js" data-hide="false">&#xD;&#xA;<div class="snippet-code">&#xD;&#xA;<pre class="snippet-code-js lang-js prettyprint-override"><code>{&#xD;&#xA;    "query" : {&#xD;&#xA;        "bool" : {&#xD;&#xA;            "must" : [&#xD;&#xA;                {&#xD;&#xA;                    "multi_match":{&#xD;&#xA;                        "query":"disease resistant",&#xD;&#xA;                        "type":"cross_fields",&#xD;&#xA;                        "fields":[&#xD;&#xA;                            "description",&#xD;&#xA;                            "planting",&#xD;&#xA;                            "maintenance",&#xD;&#xA;                            "name"&#xD;&#xA;                        ],&#xD;&#xA;                        "tie_breaker":0.3&#xD;&#xA;                    }&#xD;&#xA;                },&#xD;&#xA;                {&#xD;&#xA;                    "terms" : {&#xD;&#xA;                        "type" : ["Perennial","Annual"],&#xD;&#xA;                        "minimum_should_match" : 1&#xD;&#xA;                    }&#xD;&#xA;                },&#xD;&#xA;                {&#xD;&#xA;                    "terms" : {&#xD;&#xA;                        "petals.color" : ["purple","pink","white"],&#xD;&#xA;                        "minimum_should_match" : 1&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;            ],&#xD;&#xA;            "must_not" : [&#xD;&#xA;                {&#xD;&#xA;                    "multi_match":{&#xD;&#xA;                        "query":"lavender",&#xD;&#xA;                        "type":"cross_fields",&#xD;&#xA;                        "fields":[&#xD;&#xA;                            "description",&#xD;&#xA;                            "planting",&#xD;&#xA;                            "maintenance",&#xD;&#xA;                            "name"&#xD;&#xA;                        ],&#xD;&#xA;                        "tie_breaker":0.3&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;            ],&#xD;&#xA;            "should" : [&#xD;&#xA;&#xD;&#xA;            ]&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;&#xA;<p><strong>Query using Query/Filter</strong></p>&#xA;&#xA;<p>The following is attempting to combine query and filter to use a mix of and/or filters. <strong>I feel the issue is on "or" "petals.color" where "petals.color" is a list of colors and not an exact value.</strong> </p>&#xA;&#xA;<p>Another option is a permutation list of petals.color to solve the "or" issue (i.e. purple + pink + white, purple + pink, purple + white, pink + white, purple, pink, white.) That would get exhaustive on a list that can have hundreds of possible values and you're searching for a subset of them. Such as a list of countries and your matching only countries of a specific continent. </p>&#xA;&#xA;<p>Another option is an inverse selection of "petals.color" and put in "bool" "must_not". This is less work than the permutation list as elasticsearch supports aggregates. </p>&#xA;&#xA;<p><div class="snippet" data-lang="js" data-hide="false">&#xD;&#xA;<div class="snippet-code">&#xD;&#xA;<pre class="snippet-code-js lang-js prettyprint-override"><code>{&#xD;&#xA;    "query" : {&#xD;&#xA;        "filtered" : {&#xD;&#xA;            "query" : {&#xD;&#xA;                "bool" : {&#xD;&#xA;                     "must" : [&#xD;&#xA;                        {&#xD;&#xA;                            "multi_match":{&#xD;&#xA;                                "query":"disease resistant",&#xD;&#xA;                                "type":"cross_fields",&#xD;&#xA;                                "fields":[&#xD;&#xA;                                    "description",&#xD;&#xA;                                    "planting",&#xD;&#xA;                                    "maintenance",&#xD;&#xA;                                    "name"&#xD;&#xA;                                ],&#xD;&#xA;                                "tie_breaker":0.3&#xD;&#xA;                            }&#xD;&#xA;                        }&#xD;&#xA;                     ],&#xD;&#xA;                     "must_not" : [&#xD;&#xA;                        {&#xD;&#xA;                            "multi_match":{&#xD;&#xA;                                "query":"lavender",&#xD;&#xA;                                "type":"cross_fields",&#xD;&#xA;                                "fields":[&#xD;&#xA;                                    "description",&#xD;&#xA;                                    "planting",&#xD;&#xA;                                    "maintenance",&#xD;&#xA;                                    "name"&#xD;&#xA;                                ],&#xD;&#xA;                                "tie_breaker":0.3&#xD;&#xA;                            }&#xD;&#xA;                        }&#xD;&#xA;                     ],&#xD;&#xA;                     "should" : [&#xD;&#xA;         &#xD;&#xA;                     ]&#xD;&#xA;                 }&#xD;&#xA;            },&#xD;&#xA;            "filter" : {&#xD;&#xA;                "and" : [&#xD;&#xA;                    {&#xD;&#xA;                        "or" : [&#xD;&#xA;                            {"match" : {"type" : "Perennial"}},&#xD;&#xA;                            {"match" : {"type" : "Annual"}}&#xD;&#xA;                        ]&#xD;&#xA;                    },&#xD;&#xA;                    {&#xD;&#xA;                        "or" : [&#xD;&#xA;                            {"match" : {"petals.color" : "purple"}},&#xD;&#xA;                            {"match" : {"petals.color" : "pink"}},&#xD;&#xA;                            {"match" : {"petals.color" : "white"}}&#xD;&#xA;                        ]&#xD;&#xA;                    }&#xD;&#xA;                ]&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;
<p>Nesting [bool][must][bool][should] isolating "minimum_should_match" to only the list (array of objects) being searched on. See the below example.</p>&#xA;&#xA;<p><div class="snippet" data-lang="js" data-hide="false">&#xD;&#xA;<div class="snippet-code">&#xD;&#xA;<pre class="snippet-code-js lang-js prettyprint-override"><code>{&#xD;&#xA;    "query" : {&#xD;&#xA;        "bool" : {&#xD;&#xA;            "must" : [&#xD;&#xA;                {&#xD;&#xA;                    "multi_match":{&#xD;&#xA;                        "query":"disease resistant",&#xD;&#xA;                        "type":"cross_fields",&#xD;&#xA;                        "fields":[&#xD;&#xA;                            "description",&#xD;&#xA;                            "planting",&#xD;&#xA;                            "maintenance",&#xD;&#xA;                            "name"&#xD;&#xA;                        ],&#xD;&#xA;                        "tie_breaker":0.3&#xD;&#xA;                    }&#xD;&#xA;                },&#xD;&#xA;                "bool" : {&#xD;&#xA;                    "should" : [&#xD;&#xA;                        {"match" : {"type" : "Perennial"}},&#xD;&#xA;                        {"match" : {"type" : "Annual"}}&#xD;&#xA;                    ],&#xD;&#xA;                    "minimum_should_match" : 1&#xD;&#xA;                },&#xD;&#xA;                "bool" : {&#xD;&#xA;                    "should" : [&#xD;&#xA;                        {"match" : {"petals.color" : "purple"}},&#xD;&#xA;                        {"match" : {"petals.color" : "pink"}},&#xD;&#xA;                        {"match" : {"petals.color" : "white"}}&#xD;&#xA;                    ],&#xD;&#xA;                    "minimum_should_match" : 1&#xD;&#xA;                }&#xD;&#xA;            ],&#xD;&#xA;            "must_not" : [&#xD;&#xA;                {&#xD;&#xA;                    "multi_match":{&#xD;&#xA;                        "query":"lavender",&#xD;&#xA;                        "type":"cross_fields",&#xD;&#xA;                        "fields":[&#xD;&#xA;                            "description",&#xD;&#xA;                            "planting",&#xD;&#xA;                            "maintenance",&#xD;&#xA;                            "name"&#xD;&#xA;                        ],&#xD;&#xA;                        "tie_breaker":0.3&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;            ]&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}</code></pre>&#xD;&#xA;</div>&#xD;&#xA;</div>&#xD;&#xA;</p>&#xA;