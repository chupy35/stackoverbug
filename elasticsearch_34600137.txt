34600137
Elasticsearch Filtering Parents by Filtered Child Document Count
<p>I'm attempting to do some elasticsearch query fu on a set of data I have.&#xA;I have a user document that is the parent to many child page view documents.  I'm looking to return all users that have viewed a specific page an arbitrary amount of times (defined by user input box).  So far, I've got a has_child query that will return me all the users that have a page view with certain ids.  However, this will return those parents with all their children.  Next, I've tried to write an aggregation on those query results, that will essentially do the same has_child query in aggregation form.  Now, I have the right document count for my filtered child documents.  I need to use this document count to go back and filter the parents.  To explain the query in words, "return to me all the users that have viewed a specific page more than 4 times".  It's possible that I may need to restructure my data.  Any thoughts?</p>&#xA;&#xA;<p>Here is my query thus far:</p>&#xA;&#xA;<pre><code>curl -XGET 'http://localhost:9200/development_users/_search?pretty=true' -d '&#xA;{&#xA;    "query" : { &#xA;      "has_child" : {&#xA;        "type" : "page_view",&#xA;        "query" : {&#xA;          "terms" : {&#xA;            "viewed_id" : [175,180]&#xA;          }&#xA;        }&#xA;      }&#xA;    },&#xA;    "aggs" : {&#xA;      "to_page_view": {&#xA;        "children": {&#xA;          "type" : "page_view"&#xA;        },&#xA;        "aggs" : {&#xA;          "page_views_that_match" : {&#xA;            "filter" : { "terms": { "viewed_id" : [175,180] } }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;}'&#xA;</code></pre>&#xA;&#xA;<p>This returns me a response like:</p>&#xA;&#xA;<pre><code>{&#xA;  "took" : 3,&#xA;  "timed_out" : false,&#xA;  "_shards" : {&#xA;    "total" : 5,&#xA;    "successful" : 5,&#xA;    "failed" : 0&#xA;  },&#xA;  "hits" : {&#xA;    "total" : 1,&#xA;    "max_score" : 1.0,&#xA;    "hits" : [ {&#xA;      "_index" : "development_users",&#xA;      "_type" : "user",&#xA;      "_id" : "22548",&#xA;      "_score" : 1.0,&#xA;      "_source":{"id":22548,"account_id":1009}&#xA;    } ]&#xA;  },&#xA;  "aggregations" : {&#xA;    "to_page_view" : {&#xA;      "doc_count" : 53,&#xA;      "page_views_that_match" : {&#xA;        "doc_count" : 2&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Associated Mappings:</p>&#xA;&#xA;<pre><code>{&#xA;  "development_users" : {&#xA;    "mappings" : {&#xA;      "page_view" : {&#xA;        "dynamic" : "false",&#xA;        "_parent" : {&#xA;          "type" : "user"&#xA;        },&#xA;        "_routing" : {&#xA;          "required" : true&#xA;        },&#xA;        "properties" : {&#xA;          "created_at" : {&#xA;            "type" : "date",&#xA;            "format" : "date_time"&#xA;          },&#xA;          "id" : {&#xA;            "type" : "integer"&#xA;          },&#xA;          "viewed_id" : {&#xA;            "type" : "integer"&#xA;          },&#xA;          "time_on_page" : {&#xA;            "type" : "integer"&#xA;          },&#xA;          "title" : {&#xA;            "type" : "string"&#xA;          },&#xA;          "type" : {&#xA;            "type" : "string"&#xA;          },&#xA;          "updated_at" : {&#xA;            "type" : "date",&#xA;            "format" : "date_time"&#xA;          },&#xA;          "url" : {&#xA;            "type" : "string"&#xA;          }&#xA;        }&#xA;      },&#xA;      "user" : {&#xA;        "dynamic" : "false",&#xA;        "properties" : {&#xA;          "account_id" : {&#xA;            "type" : "integer"&#xA;          },&#xA;          "id" : {&#xA;            "type" : "integer"&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;</code></pre>&#xA;
<p>Okay, so this is kind of involved. I made a few simplifications to keep it straight in my head. First, I used this mapping:</p>&#xA;&#xA;<pre><code>PUT /test_index&#xA;{&#xA;    "mappings": {&#xA;        "page_view": {&#xA;            "_parent": {&#xA;               "type": "development_user"&#xA;            },&#xA;            "properties": {&#xA;                "viewed_id": {&#xA;                    "type": "string"&#xA;                }&#xA;            }&#xA;        },&#xA;        "development_user": {&#xA;            "properties": {&#xA;                "id": {&#xA;                    "type": "string"&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Then I added some data. In this little universe, I have three users and two pages. I want to find users who have viewed <code>"page_a"</code> at least twice, so if I construct the correct query only user <code>3</code> will be returned.</p>&#xA;&#xA;<pre><code>POST /test_index/development_user/_bulk&#xA;{"index":{"_type":"development_user","_id":1}}&#xA;{"id":"user_1"}&#xA;{"index":{"_type":"page_view","_parent":1}}&#xA;{"viewed_id":"page_a"}&#xA;{"index":{"_type":"development_user","_id":2}}&#xA;{"id":"user_2"}&#xA;{"index":{"_type":"page_view","_parent":2}}&#xA;{"viewed_id":"page_b"}&#xA;{"index":{"_type":"development_user","_id":3}}&#xA;{"id":"user_3"}&#xA;{"index":{"_type":"page_view","_parent":3}}&#xA;{"viewed_id":"page_a"}&#xA;{"index":{"_type":"page_view","_parent":3}}&#xA;{"viewed_id":"page_a"}&#xA;{"index":{"_type":"page_view","_parent":3}}&#xA;{"viewed_id":"page_b"}&#xA;</code></pre>&#xA;&#xA;<p>To get that answer we'll use aggregations. Notice that I don't want documents returned (the normal way), but I do want to filter down the documents we analyze, because it will make things more efficient. So I use the same basic filter you had before.</p>&#xA;&#xA;<p>So the aggregation tree starts with <code>terms_parent_id</code> which will just separate parent documents. Inside that I have <code>children_page_view</code> which filters the child documents down to the ones I want (<code>"page_a"</code>), and next to it in the hierarchy is <code>bucket_selector_page_id_term_count</code> which uses a <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.1/search-aggregations-pipeline-bucket-selector-aggregation.html" rel="nofollow">bucket selector</a> (you'll need ES 2.x) to filter the <em>parent</em> documents by those meeting the criterium, and then finally a <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.1/search-aggregations-metrics-top-hits-aggregation.html" rel="nofollow">top hits aggregation</a> which shows us the documents that match the requirements. </p>&#xA;&#xA;<pre><code>POST /test_index/development_user/_search&#xA;{&#xA;   "size": 0,&#xA;   "query": {&#xA;      "has_child": {&#xA;         "type": "page_view",&#xA;         "query": {&#xA;            "terms": {&#xA;               "viewed_id": [&#xA;                  "page_a"&#xA;               ]&#xA;            }&#xA;         }&#xA;      }&#xA;   },&#xA;   "aggs": {&#xA;      "terms_parent_id": {&#xA;         "terms": {&#xA;            "field": "id"&#xA;         },&#xA;         "aggs": {&#xA;            "children_page_view": {&#xA;               "children": {&#xA;                  "type": "page_view"&#xA;               },&#xA;               "aggs": {&#xA;                  "filter_page_ids": {&#xA;                     "filter": {&#xA;                        "terms": {&#xA;                           "viewed_id": [&#xA;                              "page_a"&#xA;                           ]&#xA;                        }&#xA;                     }&#xA;                  }&#xA;               }&#xA;            },&#xA;            "bucket_selector_page_id_term_count": {&#xA;               "bucket_selector": {&#xA;                  "buckets_path": {&#xA;                     "children_count": "children_page_view&gt;filter_page_ids._count"&#xA;                  },&#xA;                  "script": "children_count &gt;= 2"&#xA;               }&#xA;            },&#xA;            "top_hits_users": {&#xA;               "top_hits": {&#xA;                  "_source": {&#xA;                     "include": [&#xA;                        "id"&#xA;                     ]&#xA;                  }&#xA;               }&#xA;            }&#xA;         }&#xA;      }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>which returns:</p>&#xA;&#xA;<pre><code>{&#xA;   "took": 14,&#xA;   "timed_out": false,&#xA;   "_shards": {&#xA;      "total": 5,&#xA;      "successful": 5,&#xA;      "failed": 0&#xA;   },&#xA;   "hits": {&#xA;      "total": 2,&#xA;      "max_score": 0,&#xA;      "hits": []&#xA;   },&#xA;   "aggregations": {&#xA;      "terms_parent_id": {&#xA;         "doc_count_error_upper_bound": 0,&#xA;         "sum_other_doc_count": 0,&#xA;         "buckets": [&#xA;            {&#xA;               "key": "user_3",&#xA;               "doc_count": 1,&#xA;               "children_page_view": {&#xA;                  "doc_count": 3,&#xA;                  "filter_page_ids": {&#xA;                     "doc_count": 2&#xA;                  }&#xA;               },&#xA;               "top_hits_users": {&#xA;                  "hits": {&#xA;                     "total": 1,&#xA;                     "max_score": 1,&#xA;                     "hits": [&#xA;                        {&#xA;                           "_index": "test_index",&#xA;                           "_type": "development_user",&#xA;                           "_id": "3",&#xA;                           "_score": 1,&#xA;                           "_source": {&#xA;                              "id": "user_3"&#xA;                           }&#xA;                        }&#xA;                     ]&#xA;                  }&#xA;               }&#xA;            }&#xA;         ]&#xA;      }&#xA;   }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>Here's all the code I used:</p>&#xA;&#xA;<p><a href="http://sense.qbox.io/gist/43f24461448519dc884039db40ebd8e2f5b7304f" rel="nofollow">http://sense.qbox.io/gist/43f24461448519dc884039db40ebd8e2f5b7304f</a></p>&#xA;